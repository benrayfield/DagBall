<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" /> 
<title>2D Resizable Rectangle Simulation</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
<script>
//This software is offered by Ben F Rayfield under opensource MIT license.
console.log('Opensource MIT. This software (for now called Blob Monsters Game) is offered by Ben F Rayfield under opensource MIT license. What would cause them to sync? Those who want to play the same online game by the same rules would naturally want to be in sync while playing it, anything to the contrary adding to loss function and accelerated by negative gradient of the whole game state across the earth which is a sparse dimensional vector. Blob Monsters Game has 3 teams (red green blue), displays distance to nearest voxel of each. 9 bytes per pixel. 26 bits counts num of monsters touching this pixel. 6 bit color of voxels (24 bit color for the distance fields). 10 bits for distance up to 255. 3 bits for team masks. See game.rps.team, game.rps.tridist, game.board, and game.gob[int].m.team. The 3 teams are REDTEAM, GREENTEAM, BLUETEAM, and BLACKTEAM==0 means no gob is at that pixel.\n\nmonster = V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e is the name of some "blob monster" (object), identified by whatever JS code controls its vector & voxels it computes at that vec. To create monster: monster.p = 1; To delete: monster.p = 0; V.testnet[\'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])\'].sideA.path(). V.testnet[\'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])\'].sideA.path() returns "V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e.sideA".\n\nIts an in-memory high dimensional vector database designed for gaming-low-lag massively multiplayer sync, where any simple javascript lambda, that takes Var objects as named params, fits into that database and can be added and deleted by changing 1 of the vars/dimensions. The JS prototype of the Var class is a Proxy, but the Var itself is a normal object so can still be optimized without touching the Proxy. I dont need await/async cuz each Var has a t (UTC time) var with enough digits for slightly better than microsecond. If it hasnt been updated in a while, thats how to mark it. ');


/*TODOS
-- make BloomTree/BitPic based gobs/vars and use Var.searchYXR to find them, and make there be an easy way to know which to replace when painting with mouse 2 buttons 1 to paint walls and 1 to paint open areas aka delete walls.
-- Decide if I want mutid or not, where at most 1 of varnameABC.p can be nonzero (to say it exists) which have same mutid, so you can edit the code of a gob/blobMonster which means its primaryKey changes, so its 2 different gobs/vars, but thru mutid would automatically exclude eachother. Should it be in the Var.name, like mutidBob_sha256$sdfasdfasdfasdfasdf vs mutidBob_sha256$ssssssfdfddddddddddd or something like that? but mutidBob_sha256$sdfasdfasdfasdfasdf.mutid would be a string that would be derived from the name. Seems overly complex, but it does something useful. Figure out how to get it simple and useful, or choose not to use it. How else would it know to replace a powOf2 sized square of BloomTree compressed wall with another edited such wall? mutid is useful in dagball. It might be here too.
-- use Var.searchYXR to find gobs/vars to display sparsely, and scroll the 8kX8k area by wrapping, not by copying. its already displaying that way, so simply remove some gobs/vars and add others, where gobnameABC.p==0 or ==1 determines if exists or if displays here. Maybe should be a separate gobnameABC.existsInView55 or something. or just use game.gobs which is a js [] list.
-- fix the duplication bug in Vars that possibly involves V.testnet.gobname.vars (list) and .pu ({} map) and they seem to have duplicates and .p changes in one but not the other.
-- make game state loadable/saveable as json (V.toMap()).
-- start using V.testnet.gobnameABC.p==0 to mean delete that gobnameABC and ==1 to create or keep gobnameABC.
-- make 1 JSP file that remembers some basic serverMoney shortterm as a way to rate limit possibly spammers and uploaders of huge amount of content, but start creating content in browser and uploading/downloading it there. Put searchYXR etc there too, have queries go by that.
-- Make a kind of object with an ed25519 publickey generated by a password (have code in Dagverse.js to modify) to put 1 mouse circle in the shared game area per publicKey. The rest are whatever gobs are there, but each mouse gets to move around. Will have more advanced controls later.
*/












//
/*
checkForUnexpectedEvalsInJsParsingBeforeCrossSiteScriptingReactor

//quote from farther below 2024-11-17, in progress of making Var instances be a tree with V as its root then namespace...
//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = new Var('V'); //var Var = function(optionalName, optionalGob, optionalParentVar, optionalBig)


TODO "or what if I divided them into each their own mini game world, in a 3kX3k square that mostly reads and syncs from outside the 2kX2k square in its
center (so border width 512). I could make these sizes parameters. But I think it would be more efficient to swarm many small ones"


[[[2024-11-11 https://x.com/benrayfield/status/1855944895057268971
Post
Conversation
Lambda Rick /acc
@benrayfield
·
5h
See that slightly jagged line between the 2 green blobs. Thats cuz its doing dijkstra shortest path finding, between each pixel and the 8 adjacent pixels. Thats where the colors come from. They estimate distance: 3 to up down left right. 4 to upleft upright downleft downright.
Image
Lambda Rick /acc
@benrayfield
·
1h
4/3 is a poor substitute for sqrt(2). Id have liked to use 7/5 but i only had 2 extra bits in 10 bit distance if i want about max distance of 256. I can compute ddistance squared exactly for every pixel to every voxel but its alot slower
Lambda Rick /acc
@benrayfield
·
1h
As long as the distance-like algorithm is the same within a peer to peer net sharing a 8k X 8k canvas, it will sync exactly. Theres a correct 10 bits for every pixel (times 3 teams) for each possible world state.
Lambda Rick /acc
@benrayfield
·
55m
It does 3 dijkstras at once in the same int array. State of dijkstra is entirely in that array and 2 loops, one forward then one backward, each reading 5 of the 9 ints as 3x3 (like in conways game of life) and writes the center int. All 9 ints are in CPU L1 cache, hella fast
Lambda Rick /acc
@benrayfield
·
49m
A world state is a set of javascript lambdas and a position and velocity for each param. The pambda returns an int array of any size, even varying the size based on params, 1 int per 2d voxel in 8k X 8k shared canvas and 64 possible colors. It changes by high dimensional gradient
Lambda Rick /acc
@benrayfield
·
38m
To approx high dimensional gradient, it removes a lambda (of n params) from world state, computes total potential energy, then calls lambda n+1 times to get n+1 arrays of voxels, counts collisions where pixels (of 64 megapixels) are written twice. Also can add to energy directly
Lambda Rick /acc
@benrayfield
·
25m
Each pixel can store, in just 9 bytes, up to 2^26-1 voxels which have the same (x,y) coordinate and may differ in color and team. There are 3 teams. Usually stores 0-2 voxels. It can do this cuz its entirely reversible by xor and counting of color and team mask.
Lambda Rick /acc
@benrayfield
I had to support 64 million voxels overlapping in the same pixel, without any slowdown in computing gradient, cuz some users will likely DoSAttack a shared canvas. They will fail.
7:05 AM · Nov 11, 2024
·
39
 Views
]]]
 I dont know what to call it, but its doing something like raytracing. But instead of the usual rays its a triple dijkstra per pixel, emitted from every voxel in all directions. Nothing in there is just for graphics. These rays will for teams to chase and run from eachother.
 I have 2 bits unused in the triple dijkstra. 10 bits per distance. 3 distances to nearest team (of 3 teams). So I could put a wall bit in there, which would make the raytracing curve around walls, take a longer path, and display darker the longer the path goes.
If I did this, and once i hook the blob monsters into it to chase and run from the other 2 teams, then they would automatically do basic pathfinding, would automatically take the correct path thru a maze, for example.
If I had 3 bits left I would have used 11 bits per distance instead of 10. but there is no int33. its int32.
but I'd have to go back to the priority-queue of what order to update the pixels, instead of the constant order it is now, which would make it take 3 times longer cuz i couldnt do 3 dijkstras at once, and would take log(numPixels) times longer cuz of the priority queue. nevermind.

also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints

[[[[2024-10-26 https://x.com/benrayfield/status/1850224874586837004
Lambda Rick /acc
@benrayfield
I'm building a cross-site-scripting reactor. Anything could come up in the form of small strings of javascript code. Basic thing, dont let them call functions except Math.exp Math.sin Math.pow etc. Check for number of flops, no infinite loops, so sub-turing but turing up as MMG
1:16 PM · Oct 26, 2024
·
29
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
Now
also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints.
Lambda Rick /acc
@benrayfield
·
10m
The power of a cross-site-scripting reactor is not supposed to be by security flaw, tho its designed to safely contain any bit strings even if theyre computer viruses (if given execute permission, so do ur own proofs 1st if u do that). The power is in the shared worlds it builds.

If such code is valid under the rules of the simulation (and which sim you want to do is up to you, its your billions of transistors), then in theory (if it ended up being coded this way, which im still in early research about) it just another way to write the same thing.
]]]]
<<<<<https://x.com/benrayfield/status/1850234847731527956
Lambda Rick /acc
@benrayfield
·
11m
Got a GPU doing nothing in your house? What if u could store GPU power in opensource peer to peer network in a tit-for-tat way, so that you could instead of just locally having a burst-rate of 1 teraflop, have a burst rate of 1 petaflop, but can only do so 1/1000'th of the time?
Lambda Rick /acc
@benrayfield
If 10^12 calculations per second isnt doing it for u then what good is 10^15? I went back to CPU only. I made turing complete autodiff using JS funcs as blackboxes and have 12 of em bouncing around using 2d voxels. And if ppl wanna burst-rate petaflops in certain forks, go for it
2:00 PM · Oct 26, 2024
·
7
 Views
View post engagements
>>>>>
{{{
t
Conversation
Lambda Rick /acc
@benrayfield
NP-complete game object in blue at the top
Image
12:59 PM · Nov 11, 2024
·
31
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
4s
#TripleDijkstra graphics
Lambda Rick /acc
@benrayfield
·
13m
this is the most basic level of my new game system. CPU only. about a 100kB html file. only 1 file. and its currently running about 25FPS and doesnt have enuf objects on screen. but i do have teraflops available thru shaders
Lambda Rick /acc
@benrayfield
·
9m
every javascript function added can write sparsely to any address 0 to (2**26)-1, write to it by making a voxel there which repels any other voxels written there such as by 2 javascript functions trying to kick eachothers asses in a game or such as NSAT solving.
Lambda Rick /acc
@benrayfield
·
8m
even if distance calculations are only calculated in some parts (cuz expensive), the exact potential energy of the collisions part of the 64 megapixel canvas, is ALREADY how it works.
}}}
In #TripleDijkstra graphics, I compute the dijkstra shortest path between all pairs of about 50,000 voxels and 1,048,576 nodes (pixels), 25 (todo 60) times per second. Ok thats just normal optimizing. The advanced part is I do it 3 times in parallel, same order of nodes for all 3 --2024-11-11 https://x.com/benrayfield/status/1856040659221713292
*/
//
//The code anonymously shared and spread thru my tiny game engine should be thought of as an antivirus-quarantine but
//not a quarantine cuz its opensource and anyone can make copies and swarm and stream it. Just be warned,
//it might want to hack u so dont give it execute permission. Html can generate any file type and offer it for download
//or give you a string of hex to paste into a hex tool or something which can turn it into bytes in a file.
//If those are just other html or json files, fine, but dont trust executable types.
//js run in browser is not executing. js run in nodejs/npm is executing. Depends where you run it.
//Also it could run an infinite loop or redirect the page to a spammers website, but u can just close the browser tab if so.
//Files by themself are not dangerous, even if they contain viruses, as long as you dont give them execute permission.
//
//My tiny game engine does something the others dont: If you bend it certain ways, it will bend back in other ways,
//not just like a spring but like a computer thinking about how it wants to bend.
//I'm making a #web3 compatible system that runs in thousands of browsers at once, sharing a 8192x8192 (64 colors)
//interactive video at 60 FPS gaming-low-lag, which 2d voxels are painted by a high dimensional scalar-field simulation.
//Shapeshifting blobs move by constraint solving
//How many colors do you really need for a video game to be fun? If I use 6 bits for color I can expand the game area
//to 8192x8192 pixels, and voxel still fits in an int. If you can see a 512x512 area at a time, thats 16 screens wide
//and tall, so could fit a scrollable game level
//This 8192x8192 pixel object will be a #web3 data structure, sparse and gaming-low-lag and stored very compressed.
//It might have thousands of players per 8kX8k square. Physics happens in each pixel individually by accelerating
//away from gradient, might add differential equations.
//The voxels are general problem solvers though come in many tiny pieces. They are N-SAT solvers, fourier solvers,
//fractal solvers, and generally anything thats not TOO hard a puzzle, cuz they will get stuck in local minimums.
//But it works as a video game. We expand from there.
//My area of web3 is things that spread cuz they are fun or useful, instead of to buy and sell them. Any system,
//nomatter what it is, must produce at least as much as it consumes, to survive. I count progress in units of
//KFactor, will this spread more than it fades away?
//I have turing-complete autodiff, but just a little of it, not very deep, and I'm gonna have it paint 64 megapixels
//per shared virtual screen, per pixel. Each pixel has 6 bit color, 64 possible colors, and a 26 bit (8192x8192) address.
//What I'm about to build, a scaleable prototype of turing-complete-autodiff that paints 64 megapixels live, is the
//result of over and over asking myself, how could I raise KFactor of this tech while still being turing complete?
//So Cut off parts didnt need, adjusted bit sizes etc.
//Its CPU only for now. The older versions used GPU, but I optimized it so well I can do it  without,
//leaving GPU for more advanced stuff to add on later, maybe some neuralnets or something.
//The difference between AI and physics is not clear cut. Theres gradual levels between. I've been training small
//neuralnets with a physics algorithm in many dimensions. And when I make 2d shapeshifting game objects, thats a
//little like AI. They learn live, which is the gameplay.
//In turing-complete-autodiff, u make 1 mechanical part, which may be in multiple parts
//(return whatever set of voxels u want, no judgement on if theyre connected), and return an extra
//amount of loss (like neuralnet loss, more general) and physics is by automatic constraint solver
//Theres 67,108,864 pixels in 1 game state. Each keeps a count of number of objects currently
//touching/painting it, a count which can go up to 67,108,863 objects. Each pixel can store 1 NSAT bit
//and 6 color bits. 2**26 pixels can be 8k x 8k, 512 x 512 x 256, or 26 dimensions size 2
//Game state also TODO... includes a string of javascript code of a lambda of n float params, named
//whatever that function likes. Func object is scanned for its parameter list, and 1 dimension in the
//game world created for each, with a position and velocity. It returns an int array
//potential energy ranges 0 to 2**53-1 so fits in a float64. Add max(0,count-1) for each pixel,
//of counting number of objects which touch/paint that pixel. Each game object can also add an
//arbitrary integer to potential energy for things like springs, least squares. Multiverse...
//Turing-complete-autodiff will use this API:
//game.addFunc((centerY, centerX, varA, varB, nameVarsWhateverYouWant)=>{...return a list of int voxels...}).
//Doesnt matter what javascript function you put in there, as long as all its parameters
//are a Var instance, like centerY.p varA.p .
//I computed potential-energy across multiple black-boxes and the game survived and physics kept working. They are
//basically simulated graygoo if u didnt have to worry about how to physically make tiny computers,
//just a fun software API for it.
//
/*
My 36kB game engine will be a serious game-theory research platform with lots of AIs and people building and playing
and experimenting together. Each "blob monster" can include a loss function, used like:
centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract
All the .poten are summed. You only need 1 of them, and it doesnt matter which you add into. There was just nowhere
else to put it than in the Var objects that are auto generated as the params of any JS func you write.
--- https://x.com/benrayfield/status/1850497760463647137
*

In peer to peer network, the whole 8192x8192 shared canvas would be updated, each computer computing physics locally in the parts they're near. but its just on 1 computer for now. game state is very compressed, just the code strings of JS that make voxels and 2 numbers per param. -- https://x.com/benrayfield/status/1856413738741457180
*


I should probably make neural-shapeshifter plugin for Blob Monsters Game. I could fork out of dagball, built on my Ap.js GPU programming language, which is built on my TinyGLSL stateless synchronous (no async/await) way to call GPU from browser.
youtube.com
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained...
My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet. It does 
https://www.youtube.com/watch?v=4boQ9OvRz5U
this blob species "neural shapeshifter" would be just another JS func that happens to call the GPU thru my opensource local API,
but I'd have to upgrade Blob Monsters Game to have a parallel API where you can call monster.brain(...(monster.vars))
monster.length+1 times at once.
If i copy a 80x80 pic of 1 bit per pixel, into GPU, I can copy it into EVERY GPU core at once, or at least usefully 1000 of them,
and compute collisions inside the GPU cores, so return the loss function. 1001 GPU threads to compute the gradient of float[1000]
loss function.loss function.


The fun game content should come from that Blob Monsters Game is a turing-complete constraint solver that can solve about a million vars at once. Thats what I gotta build on. When you zoom out to 64 million it updates most of the 64 megapixels slower, those near the mouse fast.
Imagine players build forts or stacks or chains and other simple machines, of combos of these shapeshifting blob monsters (which can shapeshift in far more advanced ways than shown here). 50 players in one fort. 70 players in another. Try to invade cuz colors spread exponentially -- https://x.com/benrayfield/status/1857501980366672174
What kinda "simple machines" could u build? Maybe... catapult, gearbox with stick shift and realistic torque, 2 squares that if u turn them relative to eachother they wormscrew closer/farther from eachother, a wrench to grab such a square, 3 elevators which total constant height.
The game is open-ended. In general a team wins by turning the game world to their own color (red, green, or blue), but as its turing-complete and has a code editor on every player's screen (select any object), I cant know all the possible ways to win. I will be surprised.

Blob Monsters Game 019 has decentralized sync built in among its hundreds of megabytes of memory (in browser) already. Doesnt update all the pixels at once, but does update all of them soon and those near mouse instantly and near any random voxel of any random game object #web3 -- https://x.com/benrayfield/status/1857518756324585793

...
TODO still use ints in gob.brain but have it check game.offsetY game.offsetX or something like that, or put it in Var instances in params somehow
maybe but dont complicate them. Define it in math this way?...
binheapY 21 bits, binheapX 21 bits, 6 bits color, mask 5 bits, fits in uint53 which fits in float64.
The 5 bits are for teams REDTEAM GREENTEAM BLUETEAM WALLTEAM and a bit for is it moveable vs constant,
which it should be constant (todo fix mouse gob to have more than 0 params, and set those params
by Var.mn and Var.mx (min and max truncation) by Controls.mouseY etc, so anything which has 0 params automatically is marked as constant in that bit,
so 53 bit voxels in the expanded form that can handle powOf2 aligned voxels in a 1 terapixel space (2**20 each of y and x, with an extra bit for binheap).
Dont do variable size voxels. Use 2 voxels if u wanna do that, to define a top left and bottom right corner, or something like that.
How about y22 x22 color6 teamMask3, where neutralTeam is teamMask of 0?
Or I could just use 2 bits for team, for 4 teams red green blue wall.
Probably best to leave a few extra bits for future expansion.
Go with y20 x20 color6 teamMask4 reservedForFutureExpansion3. fits in uint53 that fits in float64.
Choose a place to put offsetY and offsetX which are each uint20 and never get too close to the millionXmillion square for the 8kX8k to fall off or wrap.
1mX1m space, 64 colors, and 4 team bits, comes to 50 bits.
I could use just 2 team bits if its 1 of 4 specific teams (red green blue wall), but what if i want more teams for powerups or something later?
I should just put Var.m.offsetY Var.m.offsetX as a place to put extra variables like this?
I like using 5 hex digits for y and x as coords. that seems like something players would prefer over a partial hex digit which u get with
2million or 4milllion or 8million but next hex digit as 16million. 1million seems a good size to snap that to.
or should offsetY and offsetX just be global vars? var offsetY = 0x576bb;
Go with 20 bits of y, 20 bits of x.
Do I want to shrink the 8kX8k to 4kX4k so it fits in 3 hex digits? i could fit 2 bits of team in there, but gob.brain shouldnt have to know its team.
8kX8k works already (2024-11-16). The 4kx4k area in its center, or maybe 6kX6k area in its center, would be computed here but border of 1k to 2k wide
would just read whats nearby in the huge game world. 1mX1m world.
See game.oy and game.ox and game.ns.
--------
[[[2024-11-16 https://x.com/benrayfield/status/1857893345617437061
Earth's diameter is 42 light-milliseconds. "chevron 8 is locked" (normally 7). metaphorically. I'm about to run shared turing-complete million X million size canvases (sparse voxels), across earth where diff areas of canvas are separated by lightspeed lag. https://youtu.be/z72GiUz2VI8?si=9TmsSznuKxFLIRKG&t=84
Quote
Lambda Rick /acc
@benrayfield
Replying to @benrayfield
If I get this API working, every namespace has pixel indexs ranging 0x0000000000 to 0xffffffffff aka 1 teravoxel.
Earth's diameter is 42 light-milliseconds. "chevron 8 is locked" (normally 7). metaphorically. I'm about to run shared turing-complete million X million size canvases (sparse voxels), across earth where diff areas of canvas are separated by lightspeed lag. https://youtu.be/z72GiUz2VI8?si=9TmsSznuKxFLIRKG&t=84
We might in some ways of using the system be able to ballpark estimate lightspeed by max internet speed, like recursive dijkstra. not that we need to. but half or so of lag in games is generally cuz of lightspeed.
I can do alot of steps and a few network hops before light reaches between the multiple computers I'm controlling.
These coordinates in million X million pixels should be used in saved and loaded game states. I havent made those files yet
but this seemed an important thing to do before it.
..
I want 1 million simultaneous players in my Blob Monsters Game. So I expanded address space to exactly 1048576x1048576 pixels (1 terapixel),
sparsely as voxels, 6 bit color, 10 bit glowing distance cache for each of 3 Rock Paper Scissors teams, 1 bit per team is it touching pixel
-- https://x.com/benrayfield/status/1857920330532028545
Within a namespace, everyone can see all 2^40=1099511627776 (1.1 trillion) pixels and scroll and zoom in/out but some things will
look blurry or missing as they're loading. 60 FPS if u play at 512x512 resolution not zoomed out too far, or u can fiddle with it. Swarm the games.
Game state is turing-complete compressed in the form of each game object (Gob)'s primaryKey is a string of JS code of a lambda that returns an
int array of int voxels, with data of a vector of a position and velocity per lambda param. Will soon expand to 1048576x1048576 addresses.
its 1024 times wider and 1024 times taller than this (pic of 1024x1024 resolution with a 768x768 in it).
Even those its sparse, I hope to live fill at 60 FPS every one of those pixels, though in more relaxed games u could leave stuff unexplored. Each player can fill a million or so.
Imagine r/place but with a shortage of people willing to expand ever bigger, and balance it kind of, and throw in turing complete shapeshifting blobs battling eachother.
the uint10 glowing distance caches would not be copied. only the JS code strings and positions and velocities would be copied, and less often,
the recursive quadtree based 1 terapixel sparse image at 2 bits per 2x2 fork or wall or nonwall or transparent/unspecifiedIfItsWallOrNot.
As far as I know, nobody has ever made a massively multiplayer video game that is entirely decentralized. The hundreds of megabytes of RAM it uses is decentralized.
It updates random areas of 64k numbers at a time, and they converge to exactly the same thing nomatter that order. -- https://x.com/benrayfield/status/1857940083254411506
There is a likely opensource upgrade path to swarm the combined exaflop/sec of those computers GPUs plus whatever even greater cloud supercomputers some fewer users might
hook in thru digital signatures, to scale up my neural-(playdough-like) blob monster like in this video https://www.youtube.com/watch?v=4boQ9OvRz5U
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained...
My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet. It does 
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained live in GPU shader (GLSL)
<<My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet.
It does gradient descent with momentum and annealing automatically of
whatever you type in there. By dragging around the icons, some bright and some dark, I shape the bright
and dark areas. It does at least 1 training batch per video frame 1/60
second, sometimes around 6 batches per 1/60 second. This will in theory scale up to doing live neural qlearning
in a GPU shader on tiny neuralnets and to fit many such
neuralnets together to do bigger things, or at least to make the dagball game more curvy, bouncy, bendy, and fun.
>>
]]]

GPT-o1-mini and -preview helped me with 8-way-manhattan distance cache algorithm that I now use in 64 megapixels per computer. U can read that conversation
here "We [OpenAI] hereby assign to you all our right, title, and interest, if any, in and to Output" -- https://x.com/benrayfield/status/1858279962559565830
https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js.txt
*/



const SizeBits = 13;
const Size = 1<<SizeBits; //8192
const SizeMask = Size-1;
const Area = Size**2; //8192*8192
const Colors = 1<<6;
if(Area*Colors > 2**32) throw new Error('Voxel layout does not fit in int. If you want more space, try uint53 or int54'+
	' (21 or 22 more bits) which fits in float64 but that redesign would cost alot of speed. Example, and would have to'+
	' be sparse cuz cant store that much in dense array: 16k x, 16k y, 16k z, 4k colors, 54 bits per voxel.');
const ColorMask = Colors-1;
const MaxVoxPerGob = 1<<20;

const MagnifyShift = 2; //Size is 4 times smaller than SmallSize. Area is 4x4 times smaller than SmallArea.
const SmallSizeBits = SizeBits-MagnifyShift; //4x4 smaller
const SmallSize = 1<<SmallSizeBits;
const SmallSizeMask = SmallSize-1;
const SmallArea = SmallSize**2;
if(((1<<MagnifyShift) != (Size/SmallSize)) || ((1<<(MagnifyShift<<1)) != (Area/SmallArea))) throw new Error(
	'MagnifyShift is broken. This line is here as a way to explain it to humans and AIs and possibly to help the JIT compiler optimize ints.');
if(Area != SmallArea<<4) throw new Error('This will never happen. Just helping the compiler optimize maybe.');
if(SmallSizeBits!=11) throw new Error('toSmall and other funcs are being hardcoded for this size, 2048x2048 small, 8192x8192 normal');

//With this upgrade I'll only store an extra int (triple dijkstra, 3 of uint10) and an extra byte (team masks),
//per 16 pixels (4x4). So thats 64 megapixels for main voxels, 4 megapixels for this other stuff, magnified.

//13 high bits and 13 low bits -> 11 high bits and 11 low bits, dropping the low 2 bits from each uint13.
//TODO Small indexs are used in game.rps.tridistSmall (not game.rps.team cuz xoring 0-16 team masks together might cancel itself out).
//Big indexs are used in game.board.
const toSmall = yx=>(((yx&0b11111111111000000000000000)>>>4)|((yx&0b1111111111100)>>>2));

//11 high bits and 11 low bits -> 13 high bits and 13 low bits ->, adding 2 low 0 bits to each uint13.
//toSmall(toBig(smallIndex))==smallIndex, but toBig(toSmall(bigIndex)) only equals bigIndex if its y and x are both divisible by 4.
const toBig = yxSmall=>(((yxSmall&0b1111111111100000000000)<<4)|((yxSmall&0b11111111111)<<2));

//TODO rename toBig to toMid or something like that, and rename this toMega to toBig. Find 3 good names of the
//existing sizes (which are exactly 2048**2, 8192**2, 1048576**2, aka small=(2**11)**2 big=(2**13)**2 mega=(2**20)**2).
//const bigToMega = yx=>(Y(yx)*(2**33)+X(yx)*(2**13)));

//throw new Error('TODO make game.rps.tridist be 4x4 smaller, so 2048x2048, and update redByteAtYX etc to use that size.')

const Controls = {
	mouseY: 0,
	mouseX: 0,
	mouseButton0: 0,
	pause: 0, //toggled by pause button on keyboard
};

const Y = voxel=>(voxel>>>19);
const X = voxel=>((voxel>>>6)&0x1fff);
const R = voxel=>((voxel>>>4)&3); //get red as uint2
const G = voxel=>((voxel>>>2)&3); //get green as uint2
const B = voxel=>(voxel&3); //get blue as uint2
const C = voxel=>(voxel&0x3f); //get color as uint6
//0b1010101*0b11==0b11111111. Im using this to turn 2 bits of red, green, or blue into 8 bits.
//if u multiply 0..3 by 85, it becomes 0, 85, 170, or 255. It hits the min and max brightness.
const RR = voxel=>(R(voxel)*85); //get red as uint8, which is 1 of: 0, 85, 170, 255.
const GG = voxel=>(G(voxel)*85); //get green as uint8, which is 1 of: 0, 85, 170, 255.
const BB = voxel=>(B(voxel)*85); //get blue as uint8, which is 1 of: 0, 85, 170, 255.
//Shape/color code adds voxels like this:
//game.addFunc((m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; });
//Makes the bending parabola. Search for game.addFunc in the html.
const YXC = (y,x,color)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|(color&0x3f));
const PC = (yx,color)=>(((yx&0x3ffffff)<<6)|(color&0x3f));
const P = voxel=>(voxel>>>6); //get yx position without color, 0 to 2**26-1
const YXRGB = (y,x,r,g,b)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|((r&3)<<4)|((g&3)<<2)|(b&3));

const SetC = (voxel,color)=>((voxel&0xffffffc0)|(color&0x3f)); //replace color get new voxel

const randInt = max=>Math.floor(Math.random()*max);

const randTeam = ()=>(1<<randInt(3)); //random one of REDTEAM, GREENTEAM, or BLUETEAM. Never returns BLACKTEAM cuz that means no gob is there.

const INF = 1<<29;
//orthogonal adds 3. diagonal adds 4. so 4 is shorter than 3+3. See computeUint10Distances.
//The best ratio of these is orthogonal*Math.sqrt(2)=diagonal, but we dont have enuf bits of precision for that.
const TINF = (1<<10)-1; //1 uint10 max aka 1023. used with game.rps.tridist, either the first second or third 10 bits, so it uses its low 30 bits.
const TRINF = (1<<30)-1; //3 uint10s each 1023. used with game.rps.tridist.
//const INF = 0x7FFFFFFF; //max int, infinity-like. used in game.rps.boardR, .boardG, and .boardB to say distanceSquared has not been computed
//const newRpsArray = ()=>(new Int32Array(Area).fill(INF));
const newRpsArray = ()=>(new Int32Array(Area).fill(TRINF));

const BLACKTEAM = 0; //so it costs less memory in unoccupied areas, in some browsers.
const REDTEAM = 1;
const GREENTEAM = 2;
const BLUETEAM = 4; //const BLUETEAM = 3;
//A gob should be counted as nonmoving if it has 0 params as gob.brain aka gob.vars.length, but since "mouse" a js var whose value is a Gob,
//uses Controls.mouseY and Controls.mouseX, as of 2024-11-17, which makes it stateful, that contradicts that design. Should add params for that.
//If there are things that need defining for optimizations, put them in gob.m such as gob.m.isSelected, gob.m.isSelectable, gob.m.team, etc,
//which are more of primary data storage than optimization but theres things to untangle and redesign here todo.
//
//GRAYTEAM created cuz: TODO 2024-11-17 this is new. its meant as a neutral team, made of walls that may be moving or nonmoving. if nonmoving, dont call gob.nextState(dt)
//on them as they wouldnt change state anyways, so an optimization of reaching the same result.
//This is needed for the Rock Paper Scissors teams to use as shields to do more strategic gameplay
//Remember, this is built on a turing complete sparse-dimensional many-dimensional constraint solver. We can build many possible kinds of gameplay and mix them.
//There are only 7 teams available in uint53 voxels (an inefficient form of oy and ox and oshift used with int arrays of int32 voxels),
//of which 4 are used so far 2024-11-17: REDTEAM, GREENTEAM, BLUETEAM, GRAYTEAM. BLACKTEAM does not count cuz is just the name of the lack of any teams at a pixel.
//This is cuz in 53 bits (which fits in a float64 as nonnegative integers): y 20 bits, x 20, color 6, teamMask 7. Have used 4 of the 7 bits available for teamMask.
//Maybe should use those other 3 for some simple categories of powerups or wall pic compression or generally... 3 bits Reserved For Future Expansion. is 50 bits so far 2024-11-17.
//float64 can hold absolute voxel 2d coordinates and color and set of teams there (that are not cancelled out by an even number of the same team being there),
//but for efficiency oy and ox and oshift should define where in terapixel coordinates it goes (40 bits) and the 26 bits of local coords (8k square) are relative to that.
const GRAYTEAM = 8;
const teamShift = new Int32Array(5);
teamShift[REDTEAM] = 0;
teamShift[GREENTEAM] = 10;
teamShift[BLUETEAM] = 20;
/*
teamShift[REDTEAM] = 20;
teamShift[GREENTEAM] = 10;
teamShift[BLUETEAM] = 0;
*/
//(game.rps.tridistSmall[(smallY<<SmallSizeBits)|smallX]>>>teamShift[BLUETEAM])&mask10
//is the uint10 of approx cached distance (with some max) to nearest BLUETEAM voxel, from (smallY,smallX) pixel.
const teamName = [];
teamName[BLACKTEAM] = 'BLACKTEAM';
teamName[REDTEAM] = 'REDTEAM';
teamName[GREENTEAM] = 'GREENTEAM';
teamName[BLUETEAM] = 'BLUETEAM';
while(teamName.length < 256) teamName.push('NOTEXIST'+teamName.length+'TEAM'); //all byte values have a team name.
teamName[REDTEAM|GREENTEAM] = 'REDTEAM|GREENTEAM';
teamName[GREENTEAM|BLUETEAM] = 'GREENTEAM|BLUETEAM';
teamName[REDTEAM|BLUETEAM] = 'REDTEAM|BLUETEAM';
teamName[REDTEAM|GREENTEAM|BLUETEAM] = 'REDTEAM|GREENTEAM|BLUETEAM';
teamHtmlColorName = [];
teamHtmlColorName[REDTEAM] = 'red';
teamHtmlColorName[GREENTEAM] = 'green';
teamHtmlColorName[BLUETEAM] = 'blue';

var hashStringToHex = function(str){
	return bytesToHex(sha256(stringToBytes(str)));
};
var utf8TextEncoder = new TextEncoder('utf-8');
var utf8TextDecoder = new TextDecoder('utf-8');
var stringToBytes = function(s){ return utf8TextEncoder.encode(s); };
var bytesToString = function(bytes){ return utf8TextDecoder.decode(bytes); };
var hexDigits = '0123456789abcdef';
var mapOfHexDigitToInt = {}; //vals are 0 to 15. filled in boot.
var mapOfDoubleHexDigitsToInt = {}; //vals are 0 to 255. filled in boot.
var bytesToHex = function(bytes){ return bytesAndRangeToHex(bytes,0,bytes.length); };
var doubleHexDigits = [];
for(let i=0; i<16; i++){
	mapOfHexDigitToInt[hexDigits[i]] = i;
	for(let j=0; j<16; j++){
		let hh = hexDigits[i]+hexDigits[j];
		doubleHexDigits.push(hh);
		mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
	}
};
var bytesAndRangeToHex = function(bytes,from,toExcl){
	let s = '';
	for(let i=from; i<toExcl; i++) s += doubleHexDigits[bytes[i]];
	return s;
};
//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js
var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};

//Returns the amount of free memory (bytes) in a browser tab. countFreeMem() 8588886016 8gB for example.
//This is a slow func. You have to fill it with a nonzero value so it actually gets allocated.
//"const BLACKTEAM = 0; //so it costs less memory in unoccupied areas, in some browsers." makes use of that if available.
const countFreeMem = ()=>{
    let arrays = [];
	let siz = 1<<20;
	while(true) try{
		arrays.push(new Uint8Array(siz).fill(arrays.length+1));
	}catch(e){
		return arrays.length*siz;
	}
};

//const DefaultIsLocal = true;
const DefaultNamespaceName = 'testnet';
/*wrap instead. const MinOy = 0x00000;
const MaxOy = 0xfffff-Size; //FIXME should this be 0x100000-Size?
const MinOx = 0x00000;
const MaxOx = 0xfffff-Size; //FIXME should this be 0x100000-Size?
const DefaultOy = MinOy; //TODO should this be in the middle of the space instead of its top left corner?
const DefaultOx = MinOx;
const DefaultGobOy = 1<<19; //approx the middle of a 1<<20 size space, approx cuz Size (1<<13) of it is reduced so the 8kX8k game.board must not hang off edge of the 1<<20.
const DefaultGobOx = 1<<19;
*/

//var Game = function(optionalIsLocal, optionalNamespaceString, optionalY_uint20, optionalX_uint20){
//var Game = function(namespaceVar, optionalY_uint20, optionalX_uint20){
//gameVarInNamespaceVar is a Var whose name is "game" and which is a child of a namespace Var,
//var Game = function(gameVarInNamespaceVar, optionalY_uint20, optionalX_uint20){
//like V.testnet.game is in the namespace V.testnet. TODO V.testnet.game.y.p and .x.p and .zoom.p etc.
var Game = function(gameVarInNamespaceVar){
	if(!(gameVarInNamespaceVar instanceof Var)) throw new Error('gameVarInNamespaceVar is not a Var: '+gameVarInNamespaceVar);
	this.q = gameVarInNamespaceVar; //self var should always be named q?
	//throw new Error('TODO some kind of variable recursion bloomtree considering its 2**40 pixels and we dont want to lockstep which causes lag across earths diameter is 42 light-milliseconds (and thats straight line distance in 3d so its more than that).');
	//TODO changing namespace, oy, and ox, should in theory connect you to different games across the world
	//and different 8kX8k 2d areas inside them, computed by whatever players are near that part of the game.
	//As this is opensource, anyone can create a namespace of any name they want, but if theres collisions
	//you'd join the existing game, in theory. You might generate this by a hash of the human readable rules of the game
	//or of a publicKey or just a random name you make up.
	//If I get this API working, every namespace has pixel indexs ranging 0x0000000000 to 0xffffffffff aka 1 teravoxel.
	//As a turing complete constraint solver, it can only make constraints in the nearby few megapixels,
	//such as 8kX8k at the most, or probably will define a limit like the middle 6kX6k or middle 4kX4k of that,
	//where it just reads game state from network in the 1k-2k border around that
	//
	//this.ns = optionalNamespaceString || DefaultNamespace;
	//this.ns = namespaceVar || NS; //NS is the default namespace as a Var.
	//by default, run local game instead of on network. TODO this is not used as of 2024-11-16 and its been all local so far.
	//in theory, works with any namespace, even if you've already downloaded from it then switch this to local,
	//it means dont use ajax or img src=downloadFromUrl or iframe src=downloadFromUrl etc. No networking.
	//Should probably have a separate setting or value/level of this where ur running a localhost server that this ajaxes to
	//but which tells that server to not network outside the computer. but that would depend on your firewall cuz a server,
	//even if localhost, doesnt normally check where its coming from and it may be unreliable to verify,
	//at the most basic level. So this var game.isLocal should probably draw the line at allowing ajax or not, instead of that.
	//not using this as of 2024-11-18, had never used it: this.isLocal = optionalIsLocal!==undefined ? !!optionalIsLocal : DefaultIsLocal;
	//like 0x00000. global offset y, a uint20 which adds 7 bits to y in 32 bit voxels which have uint13 y, so a 1048576x1048576 game area sparsely.
	//wrap instead of: this.oy = optionalY_uint20!=undefined ? optionalY_uint20 : DefaultOy;
	//wrap instead of: this.ox = optionalX_uint20!==undefined ? optionalX_uint20 : DefaultOx; //like 0x00000. similar to oy but for x
	//2024-11-17 todo: Use game.oy and game.ox with gob.oy and gob.ox. The gob returns voxels whose 13 bit y and 13 bit x are relative to gob.oy and gob.ox.
	//If game.oy!=gob.oy andOr game.ox!=gob.ox, that creates complexity but can still be computed, TODO.
	//Depending on gob.oy and gob.ox, gob.brain(...(gob.vars)) should return only the voxels within some square centered on gob.oy gob.ox,
	//even if it could generate other voxels. This is basically a view rectangle that it should only display in that.
	//Im undecided if gob.oy and gob.ox should be allowed to be any integers in that range vs only on some tile size thats a powOf2.
	//if(Math.random()<.01) throw new Error('should every gob be required to have centerY and centerX Vars? that seems it would interfere with wall gobs having 0 params to mark that they dont need to be recomputed. But with centerY and centerX vars we could automaticly update gob.oy and gob.ox. Id like to but theres still the issue of rounding. Var.p (such as centerY.p) is a float64 and changes smoothly. If voxels are relative to that, theyd have to round/floor/ceil it (such as |0). I could make a func similar to YXC(y,x,color) that takes numbers bigger than the 8kX8k, relative to gob.oy gob.ox, but it would likely cost some speed. It seems the output format should change so that ints oy ox go with the int[numVoxels]. {oy: 323633, ox: 800000, ints: Int32Array(numVoxels)}, or could put oy and ox as fields in the Int32Array. I want things to appear in whole near the sides of the 8kX8k, and disappear when they cross out of it, so the size it can touch should be alot less than that. Maybe 2kX2k, since 4 of those wide can fit in 8k. they would partially overlap. I need some minimum space for interesting patterns to form. is 2kX2k enuf? If so, any 2kX2k that at all overlaps the middle 2kX2k must be included, and any 2kX2k that goes even slightly outside the current 8kX8k must be removed for sparsity. therefore i can mask it with 22 bits (11 of each 13 bits for y and x) so that it automatically only generates within some 2kX2k square. So AND it with 0b00111111111110011111111111111111. That will put it in 1 of the corners of the 8kX8k thats exactly 2kX2k. But how to offset it from there? and how to know what such ints to generate? Working on the million X million pixel addressing in Blob Monsters Game. It fits 8kX8k in RAM. If I limit each monster to a moving 2kX2k square, that it can only put voxels in that, then I could have these 2kX2k squares come in from the sides when they entirely fit in the 8kX8k. ... generalize that to powers of 2, so a wall gob could have a size of 64x64 for example, and its oy and ox be powOf2 aligned so they fit as tiles simply, and in the js code string include base64 of the compressed pic format BitPic/BloomTree that i use in dagball. ... it seems oy and ox would be the top left corner, so centerY.p and centerX.p are not the same (center vs top left), and need another o var like oshift. oy+(voxel&((1<<oshift)-1)) or something like that. but it would actually get optimized to just adding an int voxel to everything in the int voxels list, since an int voxel has 13 bits y 13 bits x 6 bits color. ... Find a way to make the whole game state, including interactive gobs and walls, be a vector where every dimension has position and velocity, including .influence (like in dagball.Circ.influence and dagball.Ball.influence) as a dimension but a lower precision one cuz its either on or off in Blob Monsters Game. When you edit a wall with circular paintbrush using 2 mouse buttons, one to paint wall and one to paint open area removing wall, that should navigate the vector space of possible game states. game.rps.distToPoten is 1024 ints (might switch to uint16s?). that should be 1024 dimensions. Theres various other params in game too, excluding the caches that can be derived from vector state of the game. A particular player viewing an area of the game at an x y zoom, that seems like vector dimensions. Where could ed25519 pubkeys controlling some monsters (a player controls a character in the game) be represented as vector of game state? Every dimension should have a Var instance, so theres some new Var instances to create. I should in theory be able to represent the vectors as a set of Var instances. But its not so simple, cuz theyre spread around various object types. Every Var should have a global id by hash, though these wont be copied thru network every time. Should a Var have an optional parent Var, which gob.influence would be such a Var for the whole gob, and gob.vars would be its childs? Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var. ... Vars are becoming a tree, like V/namespaceABC/monster567sHashId/heightToWidthRatio exists if V/namespaceABC/monster567sHashId has position 1, and does not exist if it has position 0. In theory, if u paint a small area of the huge game world with mouse, the thing you painted is a Var which contains that compressed pic data, and its name is the hash of that, and if its value/var.p/position is 1 then it exists and that displays, else doesnt display, across world. If u want to screw with it, just make up a new namespace like V/kj4w3e5q3ew45rtdsfg43534e5 u just make up a random string and copy the relevant parts into there in new Var objects, and explore variants of the global game state. multiverse vectors. ... ot sure where the tree of Var objects goes in the OSI Model of the internet, which is an attempt to map whats out there. I want 1 million simultaneous players, using turing-complete compression of voxel generating lambdas to game together. Experiment, turing completeness expands (SEE PIC "2024-11-17 where does the tree of Var objects fit into the OSI model.png"). most data will be transferred in filenames. file content is constant size, float64s for position velocity etc. Kinda like OpenCogs TruthValue but more limited, simpler, not well organized. But will stream hella fast from everywhere to everywhere. megabyte filenames shrink by hash. The tree of Var objects is a level below constraint solving, but levels above that, Blob Monsters Game does play as a game, not very fun yet, but it works by constraint solving among many millions of bits.');

	//(y,x) is a top left corner (UPDATE 2024-11-16: is it the center of the 8kX8k area, not top left?
	//i recently adjusted some code to do that somewhere in here),
	//that canvas would display. maybe its a 512x512 canvas, or whatever size.
	//board is 8192x8192 and has color and count at each pixel, so can display any of those.
	//its not using .y and .x as of 2024-11-9, always in top left corner of the 8k x 8k space.
	//this.y = Size>>1;
	//this.x = Size>>1;
	//this.y = (optionalY_uint20 || 0)&0xfffff; //now its 2**20 but 8192 in memory wrapped. OLD: since it wraps around 8192, it can start anywhere
	//this.x = (optionalX_uint20 || 0)&0xfffff;
	this.ns = this.q.up;
	this.y = this.q.y; //FIXME make sure to call y.p (position of y) instead of just y, even though y's valueOf func slowly evals to y.p.
	this.x = this.q.x;
	//this.zoom = 1; //changed by mouse wheel, how far you zoom in/out the view whose top left corner in game coords (0 to 8191) is this.y and this.x.
	//this.zoom = 5;
	this.zoom = this.q.zoom.if0(5); //zoom.p
	this.rpsAccelMul = this.q.rpsAccelMul.if0(.01);
	this.board = new Uint32Array(Area); //26 bit count as high bits, 6 bit color as low bits.
	//potentialEnergy, which is sum of max(0,countAtPixel-1) forall pixels.
	//maybe add a squaring of that later? or is linear good enuf cuz usually its just 0, 1, or 2 count?
	//This changes when you add or remove a voxel.
	this.poten = 0;
	this.gobs = [];
	this.rps = {
		//rock paper scissors. these are big arrays, 256mB each, same size as game.board,
		//that each contain distanceSquared at each pixel, to the nearest voxel of the R/red G/green or B/blue team.
		//They should be updated sparsely using computeSquaredDistances, such as a 512x512 area near where things are changing,
		//but dont use the whole 512x512, leave some area around the edges so its more accurate.
		//Maybe later we will expand this to be always accurate everywhere, but thats for research into the sparse updates.
		//game.board is always accurate in the whole 8k x 8k area, but rps is a more expensive calculation.
		//The 512x512 or 1024x1024 or 128x128 etc that computeSquaredDistances makes is exact
		//(TODO fix bugs, it shouldnt have a Float32Array, which may make it inexact) but if the actual game world is partly outside
		//it, then it wouldnt be exact, but would be closer to accurate maybe in the 700x700 in the middle of a 1024x1024 for example.
		//boardR: newRpsArray(), //distanceSquared from each pixel to nearest voxel on red team
		//boardG: newRpsArray(), //to green team
		//boardB: newRpsArray(), //to blue team
		//tridist: newRpsArray(), //use computeUint10Distances
		tridistSmall: new Int32Array(SmallArea).fill(TRINF), //use computeUint10Distances in 4x4 smaller 2d array than this.board
		
		//team (BLACKTEAM, REDTEAM, GREENTEAM, or BLUETEAM, maybe other teams later). no need to .fill(BLACKTEAM) cuz BLACKTEAM==0.
		//store the number of voxels of each team which touches each pixel, as 1 bit. It only measures if the number of your team's voxels
		//there is even or odd. But hopefully this will be good enuf cuz it only takes 1 such collision, between all pairs of voxels.
		/*In Blob Monsters Game, I store number of voxels of each team which touches each pixel, as 1 bit. Only measures even odd.
		It has to be reversible. If I was to expand it to full count, that would be 3 ints instead of 3 bits that fit in 1 byte.
		U can make monsters that dont collide (in team changing by rock paper scissors, but they still collide in game.poten so repel).
		This could be defended against by sorting then deduping voxels returned by a "blob monster" (Gob). I cud do it in constant
		time using the VoxStream class which is 1 bit per pixel for 64 megapixels and is a reversible stack and set of voxels for
		deduping. Dont wanna pay for that.
		*/
		team: new Uint8Array(Area),
		//teamSmall: new Uint8Array(SmallArea),
		
		//how fast do gobs accelerate based on game.rps.tridistSmall, by multiplying the chance in
		//potential energy (poten) from that by this. Set to 0 to not react to the glowing colors.
		//Since game.rps.distToPoten is int32s (or TODO uint16s?), which is required so potentialEnergy is exactly reversible without roundoff,
		//game.rps.accelMul has to be small to balance that. FIXME should accelMul have to be a powOf2, a negative power? Even if so,
		//that could break the potential energy calculation. but maybe it will be ok as long as its not the collisions thing in game.board vs game.poten?
		//accelMul: .0000000000000001,
		//accelMul: 0,//.0001,
		//accelMul: 1,
		//accelMul: .1,
		//accelMul: .01,
		//cant do this cuz Var.accelMul. TODO make a list of fields that dont get auto created as Var childs. Moving this to game.rpsAccelMul. accelMul: this.q.rps.accelMul.if0(.01),
		//accelMul: .3,
		//can differ across different Games, peer to peer nets, etc.
		//for every possible uint10 distance, add accelMul*distToPoten[dist] to poten,
		//so predator chases prey which runs from predator. See predatorOf and preyOf functions.
		distToPoten: (()=>{ //TODO put this in as 1 or 1024 Vars?
			/*GPT4 says newtonian gravity, so basically just make it proportional to 1/dist plus.
			function gravitationalPotentialEnergy(m1, m2, r) {
				const G = 6.67430e-11; // Gravitational constant in m^3 kg^-1 s^-2
				return -G * m1 * m2 / r;
			}*/
			let distToPoten = new Int32Array(1024); //TODO to not take up too much of CPU L1 cache, maybe this should be a Uint16Array?
			for(let dist=0; dist<1024; dist++){
				//TODO like newtonian gravity, cuz see rock paper scissors video in dagball. distToPoten[dist] = ((2**30)/(dist+1))|0;
				distToPoten[dist] = dist; //FIXME
			}
			return distToPoten;
		})(),
	};
	this.stats = {
		fpsVal: 60,
	};
	this.logMap = {
		FPS: ()=>this.stats.fpsVal,
	};
};

/*
//voxel coordinates range 0x00000 to 0xfffff for each of y and x. Thats 128x128 times bigger than fit in game.board which is 8kX8k,
//more if the tiles partially overlap. This is for sparse updates as that 8kX8k window in game.board moves around.
//Maybe a tile should overlap in 1/8 of its width on each border, like ive been doing with updating tridist using a 768x768 in the middle of a 1024x1024,
//but tile will probably be bigger than that.
//Id rather have a powerset of gobs being included or not.
//Need to define primaryKey of gob as ''+gob.brain (aka js code) AND an instance id so u can have multiple instances of the same compiled js code,
//and primaryKey should be hash of that code with that instance id, so primaryKey is shorter.
var Tile = function(shift, oy, ox){
	this.shift = shift; //this is a (1<<shift) x (1<<shift) 2d area
	this.oy = oy;
	this.ox = ox;
	this.gobs = [];
	this.wall = null; //a BloomTree/BitPic (like in dagball), but only up to the powOf2 size
};*/

//fork this Game object by moving to another y and x, in the approx million X million space that we can only overlap 8k X 8k of at a time per Game object.
//Copies any overlapping parts, in the game.board array and game.rps.tridistSmall and game.rps.team (or was it named teams? TODO was thinking of renaming it to team or teams) etc,
//which are all 2d arrays of int or byte, so just copy the overlapping parts
//and mark the other parts as unknown (max distance 1023 in tridistSmall each int containing 3 uint10s) for example.
//These 2 Game objects, this and what this.forkYX(...) returns, will have no overlapping parts, all copied, can be used mutably.
//Lambdas should be used as immutable, do not store data in them
//(like my Wikibinator203 does store a little data in fields of JS lambda objects it creates
//as u can see in lambdize func which adds lambdaX.n.lam==lambdaX fields and lambdaX(lambdaX)->someLambda).
//I have not included such lambdas here cuz they're very inefficient, but this "Blob Monster Game" is for mass-producing sharing and using javascript lambdas that
//make voxels as a sparse dimensional space that a million players can play together in 1 namespace at once or many namespaces however they wanna organize the computing.
Game.prototype.forkYX = function(optionalY_uint20, optionalX_uint20){
	throw new Error('TODO');
};

Game.prototype.onTextareaInput = function(text){
	let selectedGobs = this.selectedGobs();
	if(selectedGobs.length == 1){
		let sel = selectedGobs[0];
		let textarea = document.getElementById('mainTextarea');
		try{
			let evaled = eval('('+text+')');
			//FIXME check for number of names of params changing. might be a completely new func.
			//else its editing the selected gob.brain func.
			sel.brain = evaled;
			textarea.style.backgroundColor = 'black'; //ok
		}catch(e){
			textarea.style.backgroundColor = '#220000'; //error
			console.error(e);
		}
	}
};

Game.prototype.onMouseWheelChange = function(amount){
	//this.zoom = Math.max(.01, Math.min(this.zoom*Math.exp(.001*amount), 50));
	this.zoom.p = Math.max(.01, Math.min(this.zoom.p*Math.exp(.001*amount), 2000));
};

/*wrong, its supposed to be 0b1111111111 aka TINF where theres no voxel: const teamsToTridistInt = Int32Array.of(
	0b00111111111111111111111111111111, //TRINF, cuz 
	0b00000000000000000000001111111111, //REDTEAM
	0b00000000000011111111110000000000, //GREENTEAM
	0b00000000000011111111111111111111, //REDTEAM|GREENTEAM
	0b00111111111100000000000000000000, //BLUETEAM
	0b00000000000000000000000000000000,
	0b00000000000000000000000000000000,
	0b00000000000000000000000000000000,
);*/
/*[...teamsToTridistInt].map(x=>[getDistance1(x),getDistance2(x),getDistance3(x)])
(8) [Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3)]
0: (3) [1023, 1023, 1023]
1: (3) [1023, 1023, 0]
2: (3) [1023, 0, 1023]
3: (3) [1023, 0, 0]
4: (3) [0, 1023, 1023]
5: (3) [0, 1023, 0]
6: (3) [0, 0, 1023]
7: (3) [0, 0, 0]

game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
42351
game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
40826
game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
43329

game.rps.team.reduce((sum,x)=>(((x==BLUETEAM)?1:0)+sum));
27755
game.rps.team.reduce((sum,x)=>(((x==BLUETEAM)?1:0)+sum));
23285
game.rps.team.reduce((sum,x)=>(((x==GREENTEAM)?1:0)+sum));
6317
game.rps.team.reduce((sum,x)=>(((x==REDTEAM)?1:0)+sum));
10531
game.rps.team.reduce((sum,x)=>(((x==REDTEAM)?1:0)+sum));
10654
*/
const teamsToTridistInt = new Int32Array(8);
for(let r=0; r<2; r++){ //include REDTEAM or not
	for(let g=0; g<2; g++){ //include GREENTEAM or not
		for(let b=0; b<2; b++){ //include BLUETEAM or not
			//const setDistances = (d1, d2, d3) => ((d1 & mask) | ((d2 & mask) << 10) | ((d3 & mask) << 20));
			//teamsToTridistInt[(r<<2) | (g<<1) | b] = (r?0:1023) | ((g?0:1023)<<10) | ((b?0:1023)<<20);
			//teamsToTridistInt[(r<<2) | (g<<1) | b] = ((r?0:1023)<<teamShift[REDTEAM]) | ((g?0:1023)<<teamShift[GREENTEAM]) | ((b?0:1023)<<teamShift[BLUETEAM]);
			teamsToTridistInt[r*REDTEAM + g*GREENTEAM + b*BLUETEAM] = ((r?0:1023)<<teamShift[REDTEAM]) | ((g?0:1023)<<teamShift[GREENTEAM]) | ((b?0:1023)<<teamShift[BLUETEAM]);
		}
	}
}

const redByteAtYX_shift = teamShift[REDTEAM]+2;
const greenByteAtYX_shift = teamShift[GREENTEAM]+2;
const blueByteAtYX_shift = teamShift[BLUETEAM]+2;

/*The whole 8192x8192 canvas displays a color computed in game.redByteAtYX(y,x), game.greenByteAtYX(y,x), and game.blueByteAtYX(y,x).
Thats how I display the voxels, of 64 possible colors, over the distance fields of 16 million possible colors. AIs could get access to pixel colors
*/
Game.prototype.redByteAtYX = function(y,x){
	//return ++this.board[(y<<13)|x]); //TODO range check?
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	//const i = ((y&SizeMask)<<13)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let color6 = this.board[i]&ColorMask;
	//return RR(this.board[i]) || (255-((this.rps.tridist[i]>>>2)&255)); //|| a display of distance of RED team as in rock paper scissors
	return color6 ? RR(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>redByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>2)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)*5.1,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)>>2,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)*5.1,255));
		//Math.max(0,Math.min(((this.rps.tridist[i]>>255)&255)*1.0534,255))|0;
		//Math.max(0,Math.min((this.rps.tridist[i]&1023)*.0534,255))|0;
		//(255-Math.max(0,(((this.rps.tridist[i]>>>2)&255)*3)));
	//|| a display of distance of RED team as in rock paper scissors
	//return RR(this.board[i]) || (255-((this.rps.tridist[i]>>>2)&255)); //|| a display of distance of RED team as in rock paper scissors
	//return (this.rps.tridist[i]>>>2)&255;
	//return (this.rps.tridist[i]&1023)*.2;
	//return 200;
};

Game.prototype.greenByteAtYX = function(y,x){
	//return GG(this.board[(y<<13)|x]); //TODO range check?
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let color6 = this.board[i]&ColorMask;
	//return color6 ? GG(color6) : (255-((this.rps.tridist[i]>>>12)&255)); //|| a display of distance of GREEN team as in rock paper scissors
	return color6 ? GG(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>greenByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>12)&255)*10,255));
		//255-111.01*Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>12)&255)**.5,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>12)&255)*5.1,255));
	//return GG(this.board[i]) || (255-((this.rps.tridist[i]>>>12)&255)); //|| a display of distance of GREEN team as in rock paper scissors
};

Game.prototype.blueByteAtYX = function(y,x){
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let color6 = this.board[i]&ColorMask;
	//return color6 ? BB(color6) : (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
	return color6 ? BB(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>blueByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>22)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>22)&255)*5.1,255));
	//return BB(this.board[i]) || (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
	//const voxel = this.board[i]; //TODO range check?
	//const blueByteOfVoxel = BB(voxel);
	
	//This is how gptVoxelDijkstra_011.html colors it: const blueValue = (distSq === 0xFFFFFFFF) ? 0 : Math.max(0, 255-Math.min(distSq,255));
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq	
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i]>>2,255)); //if theres a nonblack voxel, display it, else display distSq	
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq	
	
	//if theres a nonblack voxel, display it, else display a uint10 from game.rps.tridist which is written by computeUint10Distances.
	//RED=0 GREEN=1 BLUE=2 ALPHA=3, used in ByteRect. Use that same order but as uint10s. Just get the high 8 bits of that uint10, dropping its low 2 bits.
	//It would be a little better to add 1 or 2 to it in case distance is only 3 (cuz of orthogonal=3 diagonal=4) so 0 and 3 dont look the same.
	//|| a display of distance of BLUE team as in rock paper scissors
	//return 0; //return blueByteOfVoxel || (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
};

//func is the kind that goes in a gob.brain and takes params of ...gob.vars which is a list of Var instances.
Game.prototype.addFunc = function(func){
	if(typeof(func)=='string'){
		console.log('game.addFunc evaling: '+func);
		func = eval(func);
	}
	//this.gobs.push(new Gob(this,func));
	return new Gob(this,func); //pushes itself into this.gobs
};

//voxel stream, where they are added 1 at a time but not added if that YX (primaryKey) is already there.
//Uses 2**26 bits in 2**21 ints, 1 bit per pixel, to mark if thats already been written.
//So if you want to paint over a YX, make sure you do that part first and the "covered up" layers later which get ignored.
//
//you do a bunch of this.addVox(voxel) and it returns true if added, false if that repeats a yx (primaryKey) aka tries to paint the same pixel more than once.
//You then call this.end() to get a Uint32Array of the voxels added in the order added, keeping only the first per yx.
//
//You normally reuse 1 VoxStream for all Gobs, cuz it uses a few mB of RAM, and most gobs will be far smaller than that. Its sparse optimized.
//
//This works in a 8192x8192 2d area sparsely. So this might be a good place to put basic paint functions like circles, lines, etc.
//
var VoxStream = function(){
	this.set = new Uint32Array(Area>>>5); //1 bit per pixel in Area.
	this.vox = new Uint32Array(MaxVoxPerGob);
	this.size = 0; //what indexs in this.vox are used?
};

VoxStream.prototype.addVox = function(voxel){
	let yx = P(voxel);
	//As of 2024-11-12 i am not using VoxStream but might use it later. Its use is to dedup voxels created in different ways in the same Gob.
	let high = yx>>>5; //bits packed into an int. int has (1<<5)==32 bits. This saves alot of memory to only store 1 bit.
	let low = yx&31;
	let lowMask = 1<<low;
	if(this.set[high] & lowMask){ //FIXME is that reversed? should it be 31 minus that?
		return false; //not add voxel cuz that primaryKey/yx was already added (may be a different color)
	}else{
		this.set[high] |= lowMask; //add the yx of the voxel to the set, but not its color.
		if(this.size == this.vox.length) throw new Error('Full. MaxVoxPerGob.');
		this.vox[this.size++] = voxel;
		return true; //added voxel
	}
};

//ends the stream, undoes whatevers in it, and returns the voxels that were in it, copied to a new Uint32Array(this.size)
VoxStream.prototype.end = function(){
	let ret = new Uint32Array(this.size);
	for(let i=0; i<ret.length; i++){
		let voxel = this.vox[i];
		ret[i] = voxel;
		//TODO? this.vox[i] = 0;
		//let yx = P(voxel);
		//let high = yx>>>5;
		this.vox[voxel>>>11] = 0; //this.vox[high] = 0; //erase all bits in this.vox that could be nonzero
	}
	this.size = 0;
	return ret;
};

//xors the color but does not count it toward potentialEnergy. This is how you paint the background with no effect on physics.
//Doing this again undoes it cuz its xor graphics. The same voxel can be added by addVox too, which would make it black but still count in energy.
Game.prototype.ghostVox = function(voxel){
	this.board[voxel>>>6] ^= (voxel&63); //xor the uint6 color
};

//add voxel. adjusts this.poten and this.board.
Game.prototype.addVox = function(voxel){
	let yx = P(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+P(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
};

//voxel is an int. team is a byte.
Game.prototype.addVoxWithTeam = function(voxel, team){
	let yx = P(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+P(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	//this.rps.team[yx] = team; //FIXME this is not reversible. but if we use bit mask where each team number is a power of 2, could xor that and it be reversible
	this.rps.team[yx] ^= team; //reversible. BLACKTEAM is 0. Anything else is some powerset of teams, by default only REDTEAM, GREENTEAM, and BLUETEAM which are masks.
};

//remove voxel. adjusts this.poten and this.board.
Game.prototype.remVox = function(voxel){
	let yx = P(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+P(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--;
	}
};

Game.prototype.remVoxWithTeam = function(voxel, team){
	let yx = P(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+P(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--;
	}
	//this.rps.team[yx] = BLACKTEAM; //FIXME this is not reversible. but if we use bit mask where each team number is a power of 2, could xor that and it be reversible
	this.rps.team[yx] ^= team; //reversible but probably buggy unless each team number is a power of 2, and should BLACKTEAM (empty, no gob there) have such a pow of 2?
};

//param can be a [] or Uint32Array of 32 bit voxels. optionalTeam is REDTEAM, GREENTEAM, or BLUETEAM, if you give that param.
Game.prototype.addVoxs = function(voxels, optionalTeam){
	if(optionalTeam !== undefined){
		for(let i=0; i<voxels.length; i++){
			this.addVoxWithTeam(voxels[i], optionalTeam);
		}
	}else{
		for(let i=0; i<voxels.length; i++){
			this.addVox(voxels[i]);
		}
	}
	return this.poten;
};

//return change that would happen in this.poten if called this.addVoxs(voxels), but without actually doing it
//cuz its faster, BUT warning if the voxels write the same empty pixel 2 or more times it
//wont count that cuz is not looking for collisions between the voxels and themself.
//This is number of colliding voxels. TODO Used during gradient calculations.
Game.prototype.potenDiffIfNoCollisionsBetweenParamVoxels = function(voxels){
	let collisions = 0;
	for(let i=0; i<voxels.length; i++){
		let voxel = voxels[i];
		if(this.board[voxel>>>6]&0xffffffc0){ //high 26 bits count how many voxels are at that pixel
			collisions++;
		}
	}
	return collisions;
};

Game.prototype.potenDiffFromRpsDistanceCache_team_voxels = function(team, voxels){
	const shift = teamShift[team]; //0, 10, or 20, to get a uint10 out of tridistSmall.
	const tridistSmall = this.rps.tridistSmall;
	//uint10 dist -> change of poten. distToPoten can differ as a param of Game, in diff peer to peer nets etc.
	//distToPoten should fit in CPU L1 cache so not slow things down much, though maybe i should make it 
	const distToPoten = this.rps.distToPoten;
	let poten = 0;
	for(let i=0; i<voxels.length; i++){
		let voxel = voxels[i];
		let smallI = toSmall(voxel>>>6);
		//uint10. it maxes out around 1019 or 1023, but below that its computed by dijkstra with 8 adjacent pixels,
		//costing 3 for orthogonal and 4 for diagonal.
		let tridistInt = tridistSmall[smallI];
		let distUint10 = (tridistInt>>>shift)&mask10;
		poten += distToPoten[distUint10];
	}
	return poten;
};


//param can be a [] or Uint32Array of 32 bit voxels. optionalTeam is REDTEAM, GREENTEAM, or BLUETEAM, if you give that param.
Game.prototype.remVoxs = function(voxels, optionalTeam){
	if(optionalTeam !== undefined){
		for(let i=0; i<voxels.length; i++){
			this.remVoxWithTeam(voxels[i], optionalTeam);
		}
	}else{
		for(let i=0; i<voxels.length; i++){
			this.addVox(voxels[i]);
		}
	}
	return this.poten;
};

var generatedNameCounter = 0;

var DefaultEpsilon = .01;

//this is a named var in gob.brain(...vars). It may modify .kv .dp .dv .mn .mx and .poten
//but NOT .p and NOT .v cuz that happens after a block of calculations in var.nextState(dt).
//Also dont modify prevP, epsilon, accelMul, or gp. Those are set externally.
//TODO over time, remove this.gob/optionalGob and use ONLY Var, and same for Game and other classes.
//They were made first, then redesigned as Var is their data format but its also a fast param like centerY.p.
var Var = function(optionalParentVar, optionalName, optionalBig, optionalGob){

	this.brain = null; //where compiled (this.big || this.name) goes, normally a js func of Var's to list/array of int voxels.
	this.vars = null;

	/*Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var.
	*/
	this.up = optionalParentVar || null;
	
	//TODO make a {} whose Object.getPrototypeOf is custom built so any field that doesnt exist automatically creates
	//a Var instance as that child with that name and this Var as its parent and its .p of 0 and .v of 0 and other defaults.
	this.pu = {}; //mape of childVar.name to childVar.//this.down = {}; //mape of childVar.name to childVar.
	
	
	//If this.name is a hash id (or might be prefixed with something? todo), then its the hash of this.big which is probably a string of json (see Dagverse json norming, in dagball, TODO).
	//This must be verifiable. Dont just make up a name and make up a big that cant prove that its name is the hash of that.
	this.big = optionalBig || null;
	this.t = 0; //TODO actual current time //TODO? this.t = utc time as float64 so has at least microsecond precision for 100+ more years.
	
	//TODO? this.ch = [] child vars list (gob.vars if this is gob.influence), if this is a .influence var
	//that is 1 for this thing exists and 0 for does not exist.
	//so there is 1 correct answer, or it should converge, to what .p and .v should a var be at time t
	//TODO? this.ns = string namespace, like game.ns.
	//TODO? this.pk = primaryKey of this Var. or should that be per scalar instead of per Var?
	//should pk depend on namespace? be concat to that? or what? pk certainly should not depend on t/time.
	this.name = optionalName || 'v'+(++generatedNameCounter);
	
	//TODO this field Var.gob will be removed, Var class replaces Gob class. parent is this.up. childs are in this.pu.
	//can put same fields in Var as long as they're deriveable by Var.p Var.v Var.name Var.big etc.
	//The root (V) Var, and a namespace Var (like V/blobMonstersGameDefaultNamespace), dont have a Gob.
	//Its 1 layer deeper (theGobVar itself instead of gob.instance), and inside that is gob.vars.
	this.gob = optionalGob || null;
	
	this.p = 0; //position
	this.v = 0; //velocity
	this.kv = 0; //velocity continuous decay per second, using this.v *= Math.exp(-dt*this.kv)
	this.dp = 0; //diffeq, extra change of p per second See pinballBumper in dagball.
	this.dv = 0; //diffeq, extra change of v per second. See pinballBumper in dagball.
	this.gr = 0; //same as .dv but duplicates it cuz this stores gradient separately, and .dv can be set by gob.brain(...vars).
	this.mn = -Infinity; //for truncating this.p to Math.max(this.mn, Math.min(this.p, this.mx)). mn is min. mx is max.
	this.mx = Infinity; //for truncating this.p
	//you only need to add to poten in 1 Var but could do it in all of them. will just get summed.
	//This is extra poten, not including game.poten. Normally you just add to the first var's poten, if you do it at all.
	//You can put things here like spring forces or up to NP-complete and fourier math etc, anything by least-squares etc.
	this.poten = 0;
	this.prevP = 0; //stores the prev value of this.p while an epsilon is added to this.p during a gradient calculation, then restore it
	this.epsilon = DefaultEpsilon; //FIXME, replacement for indexToEpsilon
	this.accelMul = 1; //FIXME, replacement for indexToAccelMul
	//use this.brain instead: this.evaled = null; //eval of this.big || this.name, a js lambda whose params are all Var objects, those in this.influence.vars or gob.vars
	//gp: Like -dt*gr (gradient) usually goes into velocity, this part goes into position. p += -dt*gp.
	//This is an experimental field of Var added 2024-11-13 to try to solve that gobs overlap too much, take too long to accel away from eachother,
	//so this should slightly make them instantly jump away from eachother too.
	//I just doubled constraint solving efficiency of Blob Monster Game in 2 lines of code, in Var class:
	//"this.gp = 1.5; //TODO this.gp = 0;" and "let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);".
	//Now they overlap less. https://pic.x.com/7OjEWfA9hC
	//This might be useful as a neuralnet param, built on the loss function it solves toward lower. Ive already live trained a 22 node sigmoid RNN
	//whose output is to recurse 15 cycles then take one node's output as potentialEnergy. Bent it like neural playdough. Havent tried this on it 2024-11-13.
	//--https://x.com/benrayfield/status/1856780041985687963
	//this.gp = 2.3; //TODO this.gp = 0;
	//this.gp = 1.5; //TODO this.gp = 0; //FIXME default this to 1?
	this.gp = 1; //TODO this.gp = 0; //FIXME go back to 1.5?
	//this.gp = .3; //TODO this.gp = 0;
	//this.gp = 5; //TODO this.gp = 0;
	if(this.up && this.up.pu[this.name]){
		throw new Error('Duplicate Var, same name, same parent Var');
	}
	if(this.up) this.up.pu[this.name] = this;
	
	/*doesnt work, need Proxy: this.get = function(fieldName){
		console.log('fieldName='+fieldName);
		return this[fieldName]!==undefined ? this[fieldName] : this.Pu(fieldName); //creates fieldName
	};*/
};

Var.prototype.toMap = function(){
	let ret = {
		p: this.p,
		v: this.v,
		//name: this.name,
	};
	if(this.t){
		ret.t = t; //UTC time updated. not all code will use this. but each Var is a time-series of 2 numbers: position and velocity.
	}
	if(this.big){
		ret.big = this.big;
	}
	
	for(let childName in this.pu){
		ret[childName] = this.pu[childName].toMap();
	}
	return ret;
};

const DefaultMaxResults = 2**16;
const DefaultRadiusResults = 2**12;

//goal(anyVar)->score (FIXME or should it be loss which is -score or someConstant-score?
//As goal, any positive number passes, and any 0 or negative number does not match.
//Sort by that descending, of those which pass.
Var.prototype.search = function(goal, maxResults){
	if(maxResults === undefined) maxResults = DefaultMaxResults;
	let scores = new Map();
	let ret = [];
	for(let n in this.pu){
		let childVar = this.pu[n];
		let score = goal(childVar);
		if(score > 0){
			scores.set(childVar, score);
			ret.push(childVar);
		}
	}
	ret.sort((a,b)=>{
		let scoreA = scores.get(a), scoreB = scores.get(b);
		if(scoreA < scoreB) return -1;
		if(scoreA > scoreB) return 1;
		return 0;
	});
	while(ret.length > maxResults) ret.pop();
	return ret;
};

//FIXME rename centerY and centerX in existing game content to Y and X, like game.y and game.x TODO game.Y and game.X.
//if its on the line, is not included. Has to be less than r distance. This is cuz sorts by a relative distance, and 0 must not be included.
Var.prototype.searchYXR = function(y, x, r, maxResults){
	if(r === undefined) r = DefaultRadiusResults;
	const rr = r*r;
	return this.search(vr=>(rr - ((vr.Y.p-y)**2 + (vr.X.p-x)**2)), maxResults);
};

Var.prototype.searchYX = function(y, x, maxResults){
	return this.searchYXR(y, x, undefined, maxResults);
};

//makes a new goal that also  requires it be within r distance of (y,x) (not on the line).
Var.prototype.searchYXRGoal = function(y, x, r, goal, maxResults){
	return this.search(vr=>{
		let isNear = rr > ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		if(!isNear) return 0;
		return goal(vr);
	}, maxResults);
};

Var.prototype.if0 = function(newP){
	if(!this.p) this.p = newP;
	return this;
};

const hashIdLen = ('sha256$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
//TODO what should this limit be?
//If its longer  than this, auto hashes it and uses the hash (prefixed by what, in case it starts with a digit etc?)
//as the Var.name and the content hashed as the Var.big.
//so u can know if its a hash or not by its length. or could check for any chars then $ like sha256$thehash.
const MaxLiteralNameLen = hashIdLen-1;

//get or create child Var
Var.prototype.Pu = function(nameOrBig){
	let ret;
	if(nameOrBig.length <= MaxLiteralNameLen && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(nameOrBig)){ //TODO make this condition be a func
		ret = this.pu[nameOrBig] || new Var(this, nameOrBig, null, this.gob||null); //auto puts it in this.pu[string]
	}else{
		let name = 'sha256$'+hashStringToHex(nameOrBig);
		ret = this.pu[name] || new Var(this, name, nameOrBig, this.gob||null); //auto puts it in this.pu[string]
	}
	if(ret.big && ret.big.startsWith('(')){ //likely a js function string
		let listOfLists = getParamNames(ret.big);
		if(listOfLists.length){
			ret.vars = []; //same order as in gob.vars, a list instead of the .pu {} of paramName to Var. Vars either way.
			for(let list of listOfLists){
				let paramName = list[0]; //TODO if theres more stuff in it, do whats normally done after getParamNames, fill in .p .v .epsilon andOr .accelMul etc.
				ret.vars.push(ret.Pu(paramName));
			}
		}
	}
	return ret;
};

Var.prototype.think = function(){
	let brain = this.brain || (this.brain = eval(this.big || this.name));
	return brain(...(this.vars)); //list or Int32Array of int voxels. only the low 13 bits of y and of x even if bigger.
};

// Proxy handler for Var.prototype
/*const varProxyHandler = {
    get(target, prop, receiver) {
        // Handle Symbol properties normally
        if (typeof prop === 'symbol') {
            return Reflect.get(target, prop, receiver);
        }

        // Ensure 'Pu' is not proxied to avoid infinite recursion
        if (prop === 'Pu') {
            return Reflect.get(target, prop, receiver);
        }

        // Check if the property exists on the instance
        if (Reflect.has(receiver, prop)) {
            return Reflect.get(receiver, prop, receiver);
        }

        // Check if the property exists on Var.prototype
        if (Reflect.has(target, prop)) {
            return Reflect.get(target, prop, receiver);
        }

        // Property not found, call Pu(prop) directly from originalPrototype
        return target.Pu.call(receiver, prop);
    }
};

// Apply the Proxy to Var.prototype
Var.prototype = new Proxy(Var.prototype, varProxyHandler);
*/

const varProxyHandler = {
    get(target, prop, receiver){ //works
		//console.log('proxy target='+(target||null)+' prop='+(prop instanceof Symbol ? prop.description : prop)+' receiver='+(receiver||null));
		//console.log('proxy target='+(target||null)+' prop receiver='+(receiver||null));
		//console.log('proxy');
        // Handle Symbol properties normally
        if (typeof prop === 'symbol') {
            return Reflect.get(target, prop, receiver);
        }

		/*
        // Ensure 'Pu' is not proxied to avoid infinite recursion
        if (prop === 'Pu') {
            return Reflect.get(target, prop, receiver);
        }

        // Check if the property exists on the instance
        if (Reflect.has(receiver, prop)) {
            return Reflect.get(receiver, prop, receiver);
        }

        // Check if the property exists on Var.prototype
        if (Reflect.has(target, prop)) {
            return Reflect.get(target, prop, receiver);
        }

        // Property not found, call Pu(prop) directly from originalPrototype
        return target.Pu.call(receiver, prop);
		*/
		//return Reflect.get(target, prop, receiver);
		//return target.Pu.call(receiver, prop);
		return target[prop] || receiver.Pu(prop);
    },
	/*set(obj, prop, value){
		if(typeof prop === 'symbol'){
			return Reflect.set(obj, prop, value);
		}
		if(obj.pu && obj.pu[prop]){
			obj.pu[prop].p = value; //V.abc.xyz = 10 sets V.abc.xyz.p = 10;
			return this; //FIXME?
		}
		return Reflect.set(obj, prop, value);
	},*/
	/*broken set(target, prop, value, receiver) {
		console.log(`Proxy set called for property: ${String(prop)} with value:`, value);

		// Handle Symbol properties normally
		if (typeof prop === 'symbol') {
			console.log(`Setting Symbol property: ${String(prop)}`);
			return Reflect.set(target, prop, value, receiver);
		}

		// Check if the value is a function or the property exists on the prototype
		if (typeof value === 'function' || Reflect.has(target, prop)) {
			console.log(`Setting method or existing prototype property '${prop}' directly on instance.`);
			// Set directly on the target to avoid recursion
			target[prop] = value;
			return true;
		}

		// If the property exists within pu, set its 'p' property
		if (receiver.pu && receiver.pu[prop]) {
			console.log(`Property '${prop}' exists in pu. Setting pu['${prop}'].p to:`, value);
			receiver.pu[prop].p = value;
			return true; // Indicate that the assignment was successful
		}

		// Otherwise, set the property directly on the instance
		console.log(`Property '${prop}' does not exist in pu. Setting directly on instance.`);
		// Set directly on the target to avoid recursion
		target[prop] = value;
		return true;
	},*/
};

Var.prototype = new Proxy(Var.prototype, varProxyHandler);

//Var.prototype.prototype = new Proxy(Var.prototype.prototype, varProxyHandler);
//Var.prototype.prototype = new Proxy(Var.prototype.prototype || {}, varProxyHandler);
//Object.setPrototypeOf(Object.getPrototypeOf(Var), new Proxy({}, varProxyHandler));

/*Var.prototype.getProperty = function(fieldName){
	console.log('fieldName='+fieldName);
	return this[fieldName]!==undefined ? this[fieldName] : this.Pu(fieldName); //creates fieldName
};*/

/*wrap instead. Var.prototype.relY = function(){
	return this.p-this.gob.oy;
};

//using this.gob.ox as the 0, return relative position. This should only be used if this Var is named like "centerY" or "someVarY" etc, not for "someVarX" etc.
Var.prototype.relX = function(){
	return this.p-this.gob.ox;
};

Var.prototype.oyx = function(){
	const gob = this.gob;
	return [gob.oy&0xfffff, gob.ox&0xfffff];
};

Var.prototype.oy = function(){
	this.gob.oy&0xfffff;
};

Var.prototype.ox = function(){
	this.gob.ox&0xfffff;
};

/*var VarP = p=>{
	let ret = new Var();
	ret.p = p;
	return ret;
};

var VarPV = (p,v)=>{
	let ret = new Var();
	ret.p = p;
	ret.v = v;
	return ret;
};

var VarPVEA = (position, velocity, epsilon, accelMul)=>{
	let ret = new Var();
	ret.p = position;
	ret.v = velocity;
	ret.epsilon = epsilon;
	ret.accelMul = accelMul;
	return ret;
};*/

//Var.prototype.pushEpsilon = function(epsilon){
Var.prototype.pushEpsilon = function(){
	this.prevP = this.p;
	this.p += this.epsilon;
};

Var.prototype.popEpsilon = function(){
	this.p = this.prevP;
	this.prevP = 0;
};

//TODO test this.
Var.prototype.valueOf = function(){ //the position, this.p, though calling this.p might be more efficient.
	return this.p;
};

Var.prototype.path = function(){
	return this.up ? this.up.toString()+'.'+this.name : this.name;
};

Var.prototype.toString = function(){
	return this.path();//return this.up ? this.up.toString()+'.'+this.name : this.name;
	//return '{type:"vox_var",p:'+this.p+',v:'+this.v+',kv:'+this.kv+',dp:'+this.dp+',dv:'+this.dv+',mn:'+this.mn+',mx:'+this.mx+'}';
};

Var.prototype.nextState = function(dt){
	if(dt){
		//use someVar.nextState(0) to clear someVar.kv someVar.dp etc, without modifying someVar.p or .v etc.
		//For use during gradient of things that might happen but have not decided to make them happen.
		
		//let nextP = this.p + dt*(this.v+this.dp);
		let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);
		if(this.mn <= this.mx){
			nextP = Math.max(this.mn, Math.min(nextP, this.mx)); //truncate into range
		}
		//let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(dt*this.kv);
		let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(-dt*this.kv);
		this.p = nextP;
		this.v = nextV;
	}
	this.kv = this.dp = this.dv = this.gr = this.poten = 0;
	this.mn = -Infinity;
	this.mx = Infinity;
};

/*var getParamNames = func=>{
	const fnStr = func.toString().replace(/[\r\n]/g, '');
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\s,]+)/g);
	return params === null ? [] : params;
};*/

//getParamNames((a/*2 3 4*/, b/*5 6*/, c)=>(a+b)) returns [['a',2,3,4],['b',5,6],['c']].
var getParamNames = funcOrStr=>{
    const fnStr = funcOrStr.toString().replace(/[\r\n]/g, '').trim();
	if(fnStr.startsWith('()=>')){
		return [];
	}
    const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',')
        .map(param => param.trim().match(/(\w+)(?:\/\*([^*]+)\*\/)?/));
    return params.map(match => {
        const [_, name, comment] = match;
        const numbers = comment ? comment.match(/\d+/g) : [];
        return [name, ...(numbers || []).map(Number)];
    });
};

//gob.brain(...gob.vars) may check this to decide to do diffeq and poten fields in Vars or not.
//You dont need this during the gob.size+1 number of calls to just get 32 bit voxels
//for collision detection, that part of the potential energy math.
//You only need this once per gob per physics cycle to choose to add extra change to var.p andOr var.v
//like how the "pinball bumpers" work in dagball by diffeq.
//should I use this.diffeq instead? do i want the func to have access to a this? var Diffeq = true;
//var Diffeq = true;

//Game OBject. brain(...floatVars) returns Uint32Array of voxels. It can be a different number of voxels depending on those float vars.
//brain returns an Out.
var Gob = function(game, brain, optionalInfluence){
	let big = ''+brain;
	//let name = hashStringToHex(big);
	//this.influence = optionalInfluence || new Var(null, name, big, this);
	
	//this.influence.p is 1 for this to exist, else is 0 for this not to exist.
	//other values, i guess try to converge to one of those.
	//This is how you add or delete game content in a live multiplayer game or local.
	this.influence = NS.Pu(''+brain).setGob(this);
	
	this.game = game;
	//dont use oy or ox, cuz wrap around 8k instead using centerY.p and centerX.p: this.oy = DefaultGobOy; //FIXME??
	//dont use oy or ox: this.ox = DefaultGobOx; //FIXME??
	game.gobs.push(this);
	this.brain = brain;
	//this.diffeq = false;
	if(typeof(this.brain)!='function') throw new Error('Not a function: '+brain);
	this.size = this.brain.length; //number of params in this.brain. You use this.brain(...this.pos) for example.
	//this.pos = new Float32Array(this.size); //position
	//this.vel = new Float32Array(this.size); //velocity
	this.vars = [];
	let names = getParamNames(brain); //names[index][0] is the name. [1] is first number right after that, if any. 0-4 numbers for position, velocity, epsilon, accelMul.
	if(names.length != this.size) throw new Error('names='+JSON.stringify(names));
	//let accelMulMul = 10; //cuz i removed the dt*10, back to dt*1.
	let accelMulMul = 5; //cuz i removed the dt*10, back to dt*1.
	for(let i=0; i<this.size; i++){
		//let v = new Var(names[i][0], this);
		let v = new Var(null, names[i][0], null, this); //function(optionalParentVar, optionalName, optionalBig, optionalGob)
		if(i<2){ //FIXME, this is for centerY and centerX vars, but not every Gob/func will have those or in same order. for testing.
			//v.p = Math.random()*400; //FIXME
			v.p = Math.random()*400; //FIXME
			v.v = Math.random()*200-100; //FIXME
			//v.accelMul = .001;
			//v.accelMul = .0001;
			//v.accelMul = .0000001;
			//v.accelMul = .1*accelMulMul;
			v.accelMul = .3*accelMulMul;
			v.epsilon = 1;
		}else if(i == 2){ //ratio
			v.p = .5+Math.random();
			v.accelMul = 12*accelMulMul;
			v.epsilon = .01;
		}
		//v.accelMul = 1;
		v.accelMul = 1*accelMulMul;
		if(names[i].length > 1){
			v.p = names[i][1]; //it gave a default position
		}
		if(names[i].length > 2){
			v.v = names[i][2]; //it gave a default velocity
		}
		if(names[i].length > 3){
			v.epsilon = names[i][3]; //it gave a default epsilon
		}
		if(names[i].length > 4){
			v.epsilon = names[i][4]; //it gave a default accelMul
		}
		this.vars.push(v);
	}
	//js {} map of extra data, whatever else might get added to the Gob later.
	//Gob must be deriveable from the string of js code in gob.brain and from
	//the .p and .v and .epsilon and .accelMul in each Var in gob.vars and gob.m.
	//Keep it organized this way so its easy to store and load state.
	this.m = {
		//TODO move gob.brain and gob.vars in here?
		//Not all parts of a Var are primary data. Some parts are derived/cache other than roundoff.
		isSelected: false,
		isSelectable: true, //you might want to make the mouse gob, if its used, not selectable.
		team: randTeam(), //see game.rps aka rock paper scissors. Each gob is 1 of REDTEAM, GREENTEAM, or BLUETEAM. Theres also BLACKTEAM
		//team: REDTEAM, //FIXME
		//oy: DefaultGobOy,
		//ox: DefaultGobOx,
	};
	this.voxInGame = null; //If this is in game.board (2**26 ints), remember them here so can remove them during gradient calculation or just to remove the object. null if not in game.board.
	this.voxLast = null; //last output from this.brain(...this.vars). the other output is it modifies fields in Vars in this.vars.
	this.stats = {};
};

Var.prototype.setGob = function(gob){
	this.gob = gob;
	return this;
};

//uses this.voxInGame. minimum distance from any voxel to the given y x.
Gob.prototype.dist = function(y,x){
	let minDistSq = Infinity;
	if(this.voxInGame) for(let voxel of this.voxInGame){
		let dy = Y(voxel)-y;
		let dx = X(voxel)-x;
		let distSq = dy*dy+dx*dx;
		minDistSq = Math.min(minDistSq,distSq);
	}
	return Math.sqrt(minDistSq);
};

Gob.prototype.varPotens = function(erase){
	let poten = 0;
	for(let v of this.vars){
		poten += v.poten;
		if(erase) v.poten = 0;
	}
	return poten;
};

//update this.voxLast and some of the fields in Var's in this.vars, but do not update this.voxInGame and not the Game itself.
Gob.prototype.think = function(){
	return this.voxLast = this.modVoxels(this.brain(...this.vars));
};

//This is how you create overlay graphics, show a gob flashing cuz its selected, etc.
//Normally this returns its param (voxels) with no changes.
//voxels is a Uint32Array of int voxels or a [] list of those. May modify voxels content, such as to change
//their colors to show this gob is selected, or  replace them with a different list/array. Either way, returns it.
Gob.prototype.modVoxels = function(voxels){
	if(this.m.isSelected){
		let newColor = randInt(Colors);
		for(let i=0; i<voxels.length; i++){
			voxels[i] = SetC(voxels[i],newColor);
		}
	}
	return voxels;
};

//each Gob can have at most 1 list of voxels in the Game at once. If there is such a list in game already, remove it,
//then either way add this one, unless voxels is null or undefined then dont add any, so thats how to remove it.
//this.voxInGame will be this param voxels either way at the end (null if not exist).
Gob.prototype.setGameVoxs = function(voxels){
	if(this.voxInGame){
		this.game.remVoxs(this.voxInGame, this.m.team);
		this.voxLast = null;
	}
	if(voxels){
		//this.game.addVoxs(voxels);
		this.game.addVoxs(voxels, this.m.team);
	}
	this.voxInGame = voxels || null;
	return this.game.poten;
};

//get the OR aka | of the team byte of all voxels this.voxInGame touches.
//This should always include (as mask) this.m.team if this.voxInGame exists.
Gob.prototype.getTeamsImTouching = function(){
	const voxels = this.voxInGame;
	let teams = 0;
	if(voxels){
		const teamsArray = this.game.rps.team;
		for(let i=0; i<voxels.length; i++){
			teams |= teamsArray[voxels[i]>>>6];
		}
	}
	return teams;
};

//updates this.m.team and this.game.rps.team, if newTeam differs from this.m.team.
//Does not update this.game.rps.tridist, which should happen in next physics cycle.
Gob.prototype.setTeam = function(newTeam){
	//throw new Error('FIXME how to mark a team in a 4x4 grid if 0-16 voxels might be in here? Should team still be big size (Area) not SmallSize (SmallArea)?');
	const xor = newTeam^this.m.team;
	const voxels = this.voxInGame;
	if(xor && voxels){
		//TODO rename to this.game.rps.teams cuz its xor of all teams touching it such as REDTEAM|BLUETEAM.
		//Also, it only shows up if odd number of a team is touching there.
		//if even, it cancels out. so its parity. cuz i only wanted to spend a byte on it.
		const teamsArray = this.game.rps.team;
		for(let i=0; i<voxels.length; i++){
			teamsArray[voxels[i]>>>6] ^= xor;
		}
	}
	this.m.team ^= xor; //remove this.m.team, add newTeam.
	if(this.m.team != newTeam) throw new Error('The team xor algorithm didnt work'); //TODO remove this test after know this basic thing is working?
};

//A capture happens when 2 teams touch at the same pixel. Its per pixel,
//so if they slightly squeeze by in any strange shape without touching, even while reshaping, theres no capture.
//This works whether the distance cache (game.rps.tridist) has been updated or not. Its a big cache of 64 megapixels,
//normally only updated on the screen you're viewing at the time, and stays that way until you look near there again.
//The distance cache game.rps.tridist is where the ambient-light-like colors come from, showing the distance from
//each pixel to nearest voxel of REDTEAM, GREENTEAM, and BLUETEAM. Thats for chasing and running from eachother.
//Detecting collisions is easier. If you are on BLUETEAM your goal is to turn the whole game world blue
//before REDTEAM or GREENTEAM turn it those colors instead. Each team captures 1 color and is captured by the
//other color, around and around. Or maybe the amount of time the game world is mostly blue. I dont know.
//The game is supposed to produce a continuous stream of fun, that you can jump in for a minute, join a team,
//and leave, or 10 minutes. Its not longterm accumulation of items like in a RPG. Nobody gets kicked out for being
//captured or losing. They just change teams when captured.
//but the game should accumulate new species over long times, pieces of javascript code that bend into different
//shapes and move differently. This is the cambrian-explosion, that the game gets more and more fun over time cuz
//of player created content, including content by LLMs.
var predatorOf = team=>{
	if(team == REDTEAM) return GREENTEAM;
	if(team == GREENTEAM) return BLUETEAM;
	if(team == BLUETEAM) return REDTEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

var preyOf = team=>{
	if(team == GREENTEAM) return REDTEAM;
	if(team == BLUETEAM) return GREENTEAM;
	if(team == REDTEAM) return BLUETEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

//teams is a mask such as REDTEAM or REDTEAM|BLUETEAM
Game.prototype.countTeam = function(teams){
	let count = 0;
	for(let gob of this.gobs){
		if(gob.m.team&teams) count++;
	}
	return count;
};

Gob.prototype.doTeamLogic = function(){
	let touchingTeams = this.getTeamsImTouching();
	let myTeam = this.m.team;
	let predatorTeam = predatorOf(myTeam);
	if(touchingTeams&predatorTeam){
		//console.log(teamName[predatorTeam]+' ('+game.countTeam(predatorTeam)+'+1) captured a '+teamName[myTeam]+' ('+game.countTeam(myTeam)+'-1)');
		//console.log('%cGreen %cBlue', 'color: green;', 'color: blue;');
		console.log('%c'+teamName[predatorTeam]+' ('+game.countTeam(predatorTeam)+'+1) %ccaptured a %c'+teamName[myTeam]+' ('+game.countTeam(myTeam)+'-1)%c.\nOK.',
			'color: '+teamHtmlColorName[predatorTeam], '', 'color: '+teamHtmlColorName[myTeam], '');
		if(Math.random()<.9){ //so they dont get deadlocked when all 3 teams are touching eachother somewhere, someone has to become the other team first
			this.setTeam(predatorTeam);
		}
	}
};

//After calling this, gob.vars[eachIndex].gr is set to the gradient,
//by difference of total potentialEnergy, combining game.poten and this.vars[anyIndex].poten.
//TODO update gradient in this.vars and compute this.vars.length+1 separate lists of voxels (which may be different sizes).
//Does not change var.p (position) or var.v (velocity) but does set var.gr (gradient), and TODO maybe also xpoten (todo should that go in here),
Gob.prototype.doPhysicsA = function(){
	let relTimeFrom = performance.now();
	try{
		//create this.size+1 lists of voxels to compute the part of gradient of collision detection in game.board
		let gamePotenWithoutThisGob = this.setGameVoxs(null);
		let potenOfFork = new Float64Array(this.size+1); //each should always be an integer 0 to 2**53-1.
		for(let fork=0; fork<=this.size; fork++){
			/*for(let v=0; v<this.size; v++){ //mod var positions by epsilon
				//let epsilon = .01; //FIXME see indexToEpsilon and indexToAccelMul
				if(v == fork){
					this.vars[v].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
				}
			}*/
			if(fork < this.size){
				this.vars[fork].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
			}
			//let voxels = fork<this.size ? this.think() : null; This is wrong cuzthe last fork should have voxels, just the voxels as it is now unmodified.
			let voxels = this.think();
			
			
			//the accurate way that considers collisions even within voxels list: let gamePoten = this.setGameVoxs(voxels); //if voxels is null, removes it from game.
			let gamePoten = this.game.poten + this.game.potenDiffIfNoCollisionsBetweenParamVoxels(voxels); //the fast way. does not modify game. just reads it.
			//let rpsAccelMul = this.game.rps.accelMul;
			//let rpsAccelMul = this.game.rps.accelMul.p;
			let rpsAccelMul = this.game.rpsAccelMul.p;
			if(rpsAccelMul){ //if its set to 0, dont spend on this calculation
				let predatorTeam = predatorOf(this.m.team);
				let preyTeam = preyOf(this.m.team);
				//let rpsPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(this.m.team, voxels);
				//TODO optimize by doing just 1 call of a variant of potenDiffFromRpsDistanceCache_team_voxels that does both predator and prey at once.
				let predatorPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(predatorTeam, voxels);
				let preyPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(preyTeam, voxels);
				//gamePoten += rpsAccelMul*rpsPoten;
				gamePoten += rpsAccelMul*(preyPoten-predatorPoten); //FIXME?
			}
			
			
			
			
			//this.varPotens() gets the sum of var.poten for all this.vars. The true param makes it erase those potens to 0 after that.
			potenOfFork[fork] = gamePoten + this.varPotens(true);
			//potenOfFork[fork] = gamePoten; //FIXME also include this.varPotens(true). just testing why its accelerating for no apparent reason.
			if(fork < this.size){
				this.vars[fork].popEpsilon(); //undo "mod var positions by epsilon"
			}
		}
		//if(gamePotenWithoutThisGob != potenOfFork[this.size]){
		//	throw new Error('gamePotenWithoutThisGob != potenOfFork[this.size], but those should be duplicate. TODO redesign to not duplicate that calculation, so its faster. But still, they should be exactly equal cuz potentialEnergy is always an integer from 0 to 2**53-1.');
		//}
		for(let i=0; i<this.size; i++){
			let v = this.vars[i];
			v.nextState(0); //clear parts that were modified during what-if calculations during gradient, that we are not actually going to do, just measure.
			//let epsilon = v.epsilon;
			//let accelMul = v.accelMul;
			v.gr = (potenOfFork[i]-potenOfFork[this.size])/v.epsilon; //gradient
		}

		//document.title = 'gob_poten='+potenOfFork[this.size];
		//console.log('potenOfFork='+JSON.stringify([...potenOfFork]));

		//this last .think() puts back what was cleared by v.nextState(0).
		this.setGameVoxs(this.think()); //not gradient. just whatever it is now. paint that onto game, and leave it there for other gobs to collision against.
	}finally{
		this.stats.lastPhysicsASecs = (performance.now()-relTimeFrom)*.001;
	}
};

//updates var.p (position) and var.v (velocity)
Gob.prototype.doPhysicsB = function(dt){
	let relTimeFrom = performance.now();
	try{
		for(let v of this.vars){
			v.nextState(dt);
		}
	}finally{
		this.stats.lastPhysicsBSecs = (performance.now()-relTimeFrom)*.001;
	}
};


const randOf = list=>list[randInt(list.length)];

Game.prototype.nextState = function(dt){

	if(game.rps){ //rock paper scissors per voxel
		for(let repeat=0; repeat<2; repeat++){
			let smallCenterY = Controls.mouseY>>MagnifyShift;
			let smallCenterX = Controls.mouseX>>MagnifyShift;
			//if(Math.random()<.5){
			if(repeat==1){
				if(this.gobs.length && Math.random()<.5){ //pick a gob at random, then pick a voxel in it at random, and center there, so gobs are updated more often
					let randGob = randOf(this.gobs);
					let voxels = randGob.voxInGame;
					if(voxels && voxels.length){ //if its displaying at least 1 voxel in game.board
						let randVoxel = randOf(voxels);
						smallCenterY = Y(randVoxel)>>>MagnifyShift;
						smallCenterX = X(randVoxel)>>>MagnifyShift;
					}
				}else{ //random in whole game area
					smallCenterY = randInt(SmallSize); //FIXME what if it hangs off the edge?
					smallCenterX = randInt(SmallSize);
				}
			}
			let tridistComputeHAndW = 256;
			let smallFromY = smallCenterY-(tridistComputeHAndW>>1);
			let smallToY = smallFromY+tridistComputeHAndW;
			let smallFromX = smallCenterX-(tridistComputeHAndW>>1);
			let smallToX = smallFromX+tridistComputeHAndW;
			let border = 32;
			this.updateTridist(smallFromY, smallToY, smallFromX, smallToX, border); //arbitrary rectangle. can be any rect in the 2048x2048 board. game.rps.tridistSmall, not .tridist.
		}
	}

	for(let gob of this.gobs){
		gob.doPhysicsA();
	}
	for(let gob of this.gobs){
		gob.doPhysicsB(dt);
	}
	
	for(let gob of this.gobs){
		gob.doTeamLogic();
	}
	
	//select gob by distance to mouse
	//FIXME use different coordinates for mouse relative to screen or canvas vs relative to game coords which are an 8192 side square.
	let bestGob = null;
	let bestDist = Infinity;
	for(let gob of game.gobs){
		if(gob.m.isSelectable){ //normally this only excludes the mouse gob
			let dist = gob.dist(Controls.mouseY,Controls.mouseX);
			if(dist < bestDist){
				bestGob = gob;
				bestDist = dist;
			}
		}
	}
	let maxDistToSelectGob = 50;
	if(bestDist < maxDistToSelectGob){
		console.log('Select gob '+bestGob);
		game.setSelectedGob(bestGob);
	}
	
	/*for(let smallY=0; smallY<SmallSize; smallY++){
		let smallX = smallY;
		let smallI = ((smallY<<SmallSizeBits) | smallX);
		this.rps.tridistSmall[smallI] = randInt(1<<30); //3 random uint10s
	}*/
	
	//let fpsMul = Math.exp(-dt*this.stats.fpsDecay);
	//this.stats.fpsVal = this.stats.fpsVal*fpsMul+(1-fpsMul)/dt; //*1 cuz its 1 more frame
	//this.stats.fpsVal = this.stats.fpsVal*Math.exp(-dt*this.stats.fpsDecay)+this.stats.fpsDecay;
	this.stats.fpsVal = this.stats.fpsVal*(1-dt)+1;
	
	/*let s = 'Game.logMap eval:';
	for(let k in game.logMap){
		s += '\n'+k+': '+game.logMap[k](); //TODO shouldnt have to write game twice. see how i did it in dagball. was it a global instance (dagball.something...)?
	}
	console.log(s);
	*/
	//document.title = 'M'+game.rps.boardR[mouseI()]+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame';
	//document.title = 'Tridist'+game.rps.tridist[mouseI()]+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
	//let tridist = game.rps.tridist[mouseI()];
	let tridist = game.rps.tridistSmall[toSmall(mouseI())];
	//let s = 'MouseY '+Controls.mouseY+'X'+Controls.mouseX+' '+'R'+getDistance1(tridist)+' G'+getDistance2(tridist)+' B'+getDistance3(tridist)+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
	let s = 'FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
	if(Controls.pause) s = 'Paused '+s;
	document.title = s;
	if(Math.random()<.0001) console.log('FIXME put a string filtering function as part of game.something game.jsFirewall or something. game.jsFirewall("while(true);") false, dont wanna infinite loop, if knew to check for that. but i just wanna define a pattern of JS code that is complex enough to be interesting as game content and to make things very strategic and lead to combos of AI experiments, but which doesnt allow calling just any arbitrary function. I want it sandboxed enough to know how many flops at most it can do, or some max it could do, that it cant ever do more, but it may always do alot less, proof based. Thats future research to do in javascript, after i have done it in Wikibinator203. The.whole.game.state.across.the.earth will be a sparse dimensional vector, and you can literally dot-product it with other game states, though i wouldnt expect that to be very useful cuz of some dimensions having far more effect in some combos than others. [anything to the contrary adding to loss function and accelerated by negative gradient] includes every possible algebra equation. \nTODO putLiveBlobMonstersGameOnlineAtSomeWebsite');
};


//var VS = new VoxStream();

//var getNamespace = name=>(V.pu[name] || (V.pu[name] = new Var(V, name)));
var getNamespace = nameOrBig=>V.Pu(nameOrBig);

//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = new Var(null, 'V'); //var Var = function(optionalParentVar, optionalName, optionalBig, optionalGob)
//child of V which is the root Var for all possible namespaces
//(make up any string, or hash a bigger string) and use the hash as the namespace string.
var NS = getNamespace(DefaultNamespaceName);

//V.testnet['(m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; }'] === V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8
//But it only works if you give it the big string first.
//V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8.m.p and .v are the
//m var's position and velocity. still buggy, seems to be duplicating some of the Var objects. but .think()
//should use those .m and .b vars cuz theyre in the code string hashed.
//V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8.m.p would be a global var,
//that exists across the earth could be updated at gaming low lag. The tree of Var's is potentially endless.
//put whatever strings in there u want. turing complete game sync
//http://V.this.is.a.turing.complete.vector.system['(sideA,sideB)=>([Math.hypot(sideA,sideB)])'].testnet['(m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(0, 0, 0b000011)); return voxs; }'].think() returns int voxels & worldwide shared high dimensional vectors.
//The vectors already do sparse dimensional high dimensional gradients. Huge swarms of dimensions.
//This worldwide vector system should be used as a constraint solver aka potential energy or loss minimizer.
//V.turing.complete.poten += amount to add to loss.
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].big
'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].path()
//'V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e'
//V.testnet.big
//null
//even tho it was smaller than the generated hash, it couldnt be a js var name. had ( and other chars not allowed. so hashed it.
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].shittyVarName would work too, even though theres no such variable.
//Its just a tree. It doesnt care what you name things or how big it is. If its big or not a valid JS var name, it will hash it
//and use that instead.
//what im trying to build across the world is that anyone anywhere can run a peer to peer swarm to all have the same number
//for V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e.shittyVarName or any other made up
//path, swarms streams of sparse vectors

var game = new Game(NS.game);
//paint coordinate lines, horizontal and vertical, as a 32x32 grid of 256x256 pixels each.
for(let y=0; y<Size; y+=256){
	for(let x=0; x<Size; x++){
		//for(let thick=0; thick<25; thick++){
			//game.ghostVox(YXC(y+thick,x,randInt(Colors)));
			game.ghostVox(YXC(y+randInt(21)-11,x,randInt(Colors)));
		//}
	}
}
for(let x=0; x<Size; x+=256){
	for(let y=0; y<Size; y++){
		//game.ghostVox(YXC(y,x,randInt(Colors)));
		game.ghostVox(YXC(y,x+randInt(21)-11,randInt(Colors)));
	}
}


const sigmoid = x=>(1/(1+Math.exp(-x)));

for(let i=0; i<20; i++){
let targetY = 4250;
let targetX = 4400;
if(i>10){
	targetY += randInt(2000)-1000;
	targetX += randInt(2000)-1000;
}
game.addFunc(`(Y/*${targetY}*/, X/*${targetX}*/, heightToWidthRatio)=>{
	let i = ${i};
	//const m = centerY.gob.m;
	//const oy = m.oy, ox = m.ox;
	//dont use this, wrap instead: const [oy,ox] = centerY.oyx();
	//let area = 400;
	let area = 2400;
	/*if(gob.m.isSelected){
		area *= 5; //experiment. FIXME remove this
	}*/
	let ratio = .2+2*sigmoid(heightToWidthRatio.p*.02-.01);
	//let ratio = Math.tanh(heightToWidthRatio.p*.3);
	//let ratio = Math.exp(heightToWidthRatio.p*.5);
	//let ratio = Math.max(.2, Math.min(heightToWidthRatio.p, 5));
	//let ratio = 1;
	
	//FIXME this doesnt look like the right calculation. should ratio go in the sqrt? do algebra.
	//Use my NsatDesignToolGpu https://tinyurl.com/NsatDesignToolGpu if needed,
	//can brute force up to 40 bit vars, which u can mount uintN's in totalling at most 40 bits.
	
	let h = Math.ceil(ratio*Math.sqrt(area));
	
	let w = Math.ceil(area/h);
	/*let fromY = (centerY.p|0) - 20;
	let fromX = (centerX.p|0) - 20;
	let toY = fromY+40;
	let toX = fromX+40;
	*/
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let color = 63-i;
			ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
		}
	}
	Y.poten += .1*Math.hypot(Y.p-${targetY},X.p-${targetX})**2; //attract to that
	heightToWidthRatio.poten += .03*(heightToWidthRatio.p-1)**2;
	//centerY.kv += 3;
	//centerX.kv += 3;
	//centerY.kv += .1;
	//centerX.kv += .1;
	Y.kv += .3;
	X.kv += .3;
	//heightToWidthRatio.kv += .003;
	heightToWidthRatio.kv += .01141;
	return ret;
}`);
}

//game.addFunc((centerY=VarP(700), centerX=VarPV(700,100), heightToWidthRatio=VarP(1))=>{
game.addFunc((Y/*4310*/, X/*4300 10*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 4000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*Math.hypot(Y.p-4150,X.p-4175)**2; //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

game.addFunc((Y/*4300*/, X/*4800 100*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 90000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
let otherX = actualCenterX+40;
let otherRR = rr*.8;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
let otherDx = otherX-x;
let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*Math.hypot(Y.p-4200,X.p-4375)**2; //attract to that
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

const Ave = floats=>{
	if(!floats.length) return 0;
	let sum = 0;
	for(let i=0; i<floats.length; i++) sum += floats[i];
	return sum/floats.length;
};

const Dev = (floats, optionalAve)=>{
	let ave = optionalAve===undefined ? Ave(floats) : optionalAve;
	let sumOfSquares = 0;
	for(let i=0; i<floats.length; i++) sumOfSquares += floats[i]**2;
	return Math.sqrt(sumOfSquares/floats.length);
};

const AveDev = floats=>{
	let ave = Ave(floats);
	return [ave,Dev(floats,ave)];
};


game.addFunc(function(Y/*4300*/, X/*4500*/, ay/*10 0 1*/, ax/*20 0 1*/, by/*34 0 1*/, bx/*19 0 1*/, cy/*-10 0 1*/, cx/*-35 0 1*/, dy/*15 0 1*/, dx/*-27 0 1*/, ey/*40 0 1*/, ex/*-20 0 1*/, fy/*-58 0 1*/, fx/*30 0 1*/, gy/*-80 0 1*/, gx/*28 0 1*/){ //hypercubewave
	const sideBits = 5;
	//const sideBits = 8;
	//const sideBits = 9;
	const side = 1<<sideBits;
	const mid = side/2;
	const stdDev = mid/10;
	//const stdDev = mid/5;
	const stdDevSquared = stdDev**2;
	const sideMask = side-1;
	const square = side**2;
	const squareMask = square-1;
	let picA = new Float32Array(square);
	//let xyMul = 52;
	//let xyMul = .5;
	let xyMul = 1.3;
	let offsets = [
		(((ay*xyMul)&sideMask)<<sideBits) | ((ax*xyMul)&sideMask),
		(((by*xyMul)&sideMask)<<sideBits) | ((bx*xyMul)&sideMask),
		(((cy*xyMul)&sideMask)<<sideBits) | ((cx*xyMul)&sideMask),
		(((dy*xyMul)&sideMask)<<sideBits) | ((dx*xyMul)&sideMask),
		(((ey*xyMul)&sideMask)<<sideBits) | ((ex*xyMul)&sideMask),
		(((fy*xyMul)&sideMask)<<sideBits) | ((fx*xyMul)&sideMask),
		(((gy*xyMul)&sideMask)<<sideBits) | ((gx*xyMul)&sideMask),
	]
	let sumDy = 0, sumDx = 0;
	//for(let offset of offsets){
	for(let i=0; i<offsets.length; i++){
		let offset = offsets[i];
		sumDy += offset>>>sideBits; //y from 0 to side-1
		sumDx += offset&sideMask; //x from 0 to side-1
	}
	//let maxCenterAdjust = mid*.7; //dont move center outside the picA/picB square
	let maxCenterAdjust = mid*.9; //dont move center outside the picA/picB square
	//let maxCenterAdjust = mid*1.7; //dont move center outside the picA/picB square
	sumDy = Math.max(-maxCenterAdjust, Math.min(sumDy, maxCenterAdjust));
	sumDx = Math.max(-maxCenterAdjust, Math.min(sumDx, maxCenterAdjust));
	for(let i=0; i<square; i++){ //fill in 1 bellcurve at center of picA
		let y = i>>>sideBits;
		let x = i&sideMask;
		//let bellY = mid+sumDy*2;
		//let bellX = mid-sumDx*0;
		//let bellY = -sumDy/2;
		//let bellX = -sumDx/2;
		let bellY = mid-sumDy/2;
		let bellX = mid-sumDx/2;
		//let devSquared = ((y-mid)**2 + (x-mid)**2)/stdDevSquared;
		let devSquared = ((y-bellY)**2 + (x-bellX)**2)/stdDevSquared;
		let bellHeight = Math.exp(-devSquared);
		picA[i] = bellHeight;
	}
	for(let offset of offsets){
		if(offset==0) Y.poten += 10; //resist the params being exactly 0 after roundoff, cuz they dont copy picA when they are.
	}
	let picB = new Float32Array(square);
	for(let dup=0; dup<offsets.length; dup++){
		let offset = offsets[dup];
		if(offset){ //cant copy 2 of them to the exact same place, one positive and one negative, cuz it cancels out.
			for(let i=0; i<square; i++){
				//copy picA 2 times onto picB,
				//once as is and once 2d position offset and negated brightness
				picB[i] = picA[i] - picA[(i+offset)&squareMask]; //wrap. TODO dont wrap
			}
			[picA, picB] = [picB, picA];
		}
	}
	for(let i=0; i<square; i++) picA[i] = Math.abs(picA[i]);
	let sum = 0;
	for(let i=0; i<square; i++) sum += picA[i];
	let ave = sum/square;
	let vox = [];
	let limit = ave*3.5;
	let magnify = 4;
	let addA = YXC(2,0,0); //make 4 voxels instead of 1, cuz magnify is 2.
	let addB = YXC(0,2,0);
	let addC = YXC(2,2,0);
	for(let i=0; i<square; i++){
		//if(limit < picA[i] || i==0 || i==square-1){ //i==0 || i==square-1, is 2 corners to show the square its painting in.
		if(limit < picA[i]){
			let localY = i>>>sideBits;
			let localX = i&sideMask;
			let y = Y + (localY - mid)*magnify;
			let x = X + (localX - mid)*magnify;
			let color = 0b011111;
			let voxel = YXC(y,x,color);
			vox.push(voxel);
			vox.push(voxel+addA);
			vox.push(voxel+addB);
			vox.push(voxel+addC); //FIXME might wrap around at edges
		}
	}
	Y.poten += .1*((Y.p-4100)**2 + (X.p-4425)**2); //attract to that
	Y.kv += .315;
	X.kv += .315;
	//let flatZone = mid/8.5; //each (y,x) param pair, except the first 2, is a vector. we dont push on it if its within the flatZone radius. We do if it gets too big.
	let flatZone = 7;
	for(let i=2; i<arguments.length; i+=2){
		let kv = .2;
		let varY = arguments[i], varX = arguments[i+1];
		varY.kv += kv;
		varX.kv += kv;
		let len = Math.hypot(varY.p,varX.p);
		if(len > flatZone){
			varY.poten += .7*(len-flatZone)**2;
		}
		//varY.dp += 10; (Math.random()*2-1)*10;
		//varY.dp += (Math.random()*2-1)*.31;
	}
	//for(let i=2; i<arguments.length; i+=2){
	//	arguments[i].dp += (Math.random()*2-1)*.11;
	//}
	return vox;
});



var mouse = game.addFunc(()=>{
	let Y = {p:Controls.mouseY};
	let X = {p:Controls.mouseX};
	let area = 4000; //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b110011;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});
mouse.m.isSelectable = false;











//Canvas and ByteRect code are opensource MIT licensed
//(parts from benrayfield's various other projects including https://jsfiddle.net/q687fcrk/1/ and
//https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html )

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA;

//modified https://github.com/benrayfield/jsutils/blob/master/src/FullScreenCanvasPrototype.html
var FullScreenCanvas = function(optionalHeight, optionalWidth, optionalParentDom){ //FullScreenCanvas opensource MIT licensed by Ben F Rayfield
	let parentDom = optionalParentDom  || document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	this.dom.style.position = 'absolute';
	this.dom.style.left = '0px';
	this.dom.style.top = '0px';
	
	//else uses window size. FIXME also 
	this.resizeCanvas = function(optionalHeight, optionalWidth){
		let targetHeight = optionalHeight || window.innerHeight;
		let targetWidth = optionalWidth || window.innerWidth;
		if(this.dom.height != targetHeight) this.dom.height = targetHeight;
		if(this.dom.width != targetWidth) this.dom.width = targetWidth;
	};
	
	/*//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	//FIXME reuse some of these vars. might be slowing it down doing getContext and imageData every time, for example,
	//but careful with that cuz canvas doesnt update if you do this wrong.
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		
		//this.context = this.dom.getContext('2d');
		//cuz got this warning 2023-9-2: ForestCurveFit004.html:1503 Canvas2D: Multiple readback operations using getImageData
		//are faster with the willReadFrequently attribute set to true.
		//See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
		this.context = this.dom.getContext('2d', {willReadFrequently: true});

		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};*/
	this.beforePaint = function(){
		if(this.dom == null) throw new Error('No canvas');

		// Create the context if it doesn't exist
		if(!this.context){
			this.context = this.dom.getContext('2d', {willReadFrequently: true});
		}

		//Only create image data if it doesn't exist or if the canvas size has changed
		if(!this.imageData || this.imageData.width !== this.dom.width || this.imageData.height !== this.dom.height){
			this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
			this.pixels = this.imageData.data;
			this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
		}
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw new Error('No canvas');
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas(optionalHeight, optionalWidth);
	this.beforePaint();
};

//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)];
};


ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(y*this.width+x)*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	if(x < 0 || this.width <= x || y < 0 || this.height <= y) return;
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

var canv = null;

var endingCanv = false;

/** utc time in seconds */
var time = function(){
	//FIXME use the code from dagball for more precise time using performance.now and an offset
	return Date.now()*.001;
};

var timeStarted = 0;

/** get bellcurve height on a chosen bellcurve thats stretched and moved */
var bell = function(ave, dev, maxHeight, observe){
	let diff = (observe-ave)/dev;
	return Math.exp(-diff*diff);
};

/*var sigmoid = function(x){
	return .5+.5*Math.tanh(x);
};*/

//0 to 255
var backgroundRed = 0;
var backgroundGreen = 0;
var backgroundBlue = 0;


//age in seconds since transition started. Just paints onto ByteRect
var doGraphicsDtAgeByterect = function(dt, age, byteRect){

	//dt *= 20;
	//dt *= 10;
	game.nextState(dt);

	let bytes = byteRect.bytes;
	let offset = Math.floor(Math.sin(time()*5*2*Math.PI)*100+100);
	let w = byteRect.width;
	let h = byteRect.height;
	let cx = Math.floor(w/2); //center x
	let cy = Math.floor(h/2); //center y
	/*for(let i=0; i<bytes.length; i+=4){
		bytes[i+RED] = backgroundRed;
		bytes[i+GREEN] = backgroundGreen;
		bytes[i+BLUE] = backgroundBlue;
		bytes[i+ALPHA] = 255;
	}*/
	let i = 0;
	//let viewRect = game.getViewRect
	//let fromY = game.y;
	//let toY = fromY+h;
	//let fromX = game.x;
	//let toX = fromX+w;
	
	let screenH = canv.dom.height;
	let screenW = canv.dom.width;
	let centerYGameCoords = game.y.p; //FIXME until 2024-11-14-1206pET game.y and game.x were top left corner. i might want it to be center of view.
	let centerXGameCoords = game.x.p; //FIXME until 2024-11-14-1206pET game.y and game.x were top left corner. i might want it to be center of view.
	let gameDisplayH = screenH*game.zoom.p; //FIXME divide vs multiply by zoom?
	let gameDisplayW = screenW*game.zoom.p; //FIXME divide vs multiply by zoom?
	let gameFromY = game.y.p-gameDisplayH/2;
	let gameFromX = game.x.p-gameDisplayW/2;
	let gameDy = game.zoom.p;
	let gameDx = game.zoom.p;
	//for(let y=fromY; y<toY; y++){
		//for(let x=fromX; x<toX; x++){
	let zoomedY = gameFromY;
	const wrap = true; //display around the 8kX8k window
	for(let screenY=0; screenY<screenH; screenY++){
		let zoomedX = gameFromX;
		for(let screenX=0; screenX<screenW; screenX++){
			if(wrap || (0 <= zoomedY && zoomedY < Size && 0 <= zoomedX && zoomedX < Size)){ //in game area
				bytes[i+RED] = game.redByteAtYX(zoomedY,zoomedX);
				bytes[i+GREEN] = game.greenByteAtYX(zoomedY,zoomedX);
				bytes[i+BLUE] = game.blueByteAtYX(zoomedY,zoomedX);
			}else{
				bytes[i+RED] = 40; //very dark gray background outside the 8kX8k square
				bytes[i+GREEN] = 40;
				bytes[i+BLUE] = 40;
			}
			/*bytes[i+RED] = game.redByteAtYX(y,x);
			bytes[i+GREEN] = game.greenByteAtYX(y,x);
			bytes[i+BLUE] = game.blueByteAtYX(y,x);
			*/
			bytes[i+ALPHA] = 255; //visible, not transparent
			i += 4;
			zoomedX += gameDx;
		}
		zoomedY += gameDy;
	}

};

Game.prototype.setSelectedGob = function(gob){
	let i = this.gobs.indexOf(gob);
	if(i == -1) this.gobs.push(gob); //selecting a gob that wasnt added yet
	for(let g of this.gobs){
		g.m.isSelected = (g===gob);
	}
	document.getElementById('mainTextarea').value = ''+gob.brain;
};

Game.prototype.searchGobs = function(query){
	return this.gobs.filter(query);
};

Game.prototype.selectedGobs = function(){
	return this.searchGobs(g=>(g.m.isSelected));
};

var lastTimeOf_doGraphicsDtAgeByterectAndMore = 0;

//get array index mouse last touched, for game.board[mouseI()] and game.rps.boardR[mouseI()] and boardG and boardB.
var mouseI = ()=>((Controls.mouseY<<SizeBits)|Controls.mouseX);

var doGraphicsDtAgeByterectAndMore = function(){
	if(canv == null){
		//canv = new FullScreenCanvas();
		let magnify = 2; //raising this decreases resolution, for speed. set this to 1 to use actual screen resolution or at least the window in the screen.
		//let magnify = 3;
		let h = window.innerHeight/magnify;
		let w = window.innerWidth/magnify;
		canv = new FullScreenCanvas(h, w);
		let dom = canv.dom;
		dom.style.display = 'block';
		dom.style.transformOrigin = '0 0';
		dom.style.position = 'absolute';
		dom.style['z-index'] = -1;
		dom.style.top = '0';
		dom.style.left = '0';
		dom.setAttribute('tabIndex', 0); //make canvas focusable
		dom.style.transform = `scaleX(${magnify}) scaleY(${magnify})`;
		dom.style.cursor = 'none'; //hide mouse pointer when over canvas cuz mouseball (in game.addFunc theres one that checks Controls.mouseY etc) is there.
		document.body.addEventListener('keyup', event=>{
			if(event.key == 'Pause'){
				Controls.pause = Controls.pause ? 0 : 1; //toggle
				if(!Controls.pause){
					console.log('Unpause');
					requestAnimationFrame(doGraphicsDtAgeByterectAndMore);
				}
			}
		});

		
		canv.dom.addEventListener('mousemove', event=>{
			let prevRawMouseY = Controls.rawMouseY;
			let prevRawMouseX = Controls.rawMouseX;
			Controls.rawMouseY = event.offsetY;
			Controls.rawMouseX = event.offsetX;
			let mouseDy = Controls.rawMouseY-prevRawMouseY;
			let mouseDx = Controls.rawMouseX-prevRawMouseX;
			if(Controls.mouseButton0){ //dragging the ground to move view
				game.y.p -= mouseDy*game.zoom.p;
				game.x.p -= mouseDx*game.zoom.p;
				//game.y = Math.max(0, Math.min(game.y, Size-canv.dom.height))&SizeMask;
				//game.x = Math.max(0, Math.min(game.x, Size-canv.dom.width))&SizeMask;
				//console.log('game.y='+game.y+' x='+game.x);
			}
			Controls.mouseY = (game.y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)&SizeMask;
			Controls.mouseX = (game.x.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)&SizeMask;;
		});
		document.body.addEventListener('mousedown', event=>{
			//console.log('mousedown button='+event.button);
			if(event.button==0){ //dragging the ground to move view
				Controls.mouseButton0 = 1;
				Controls.rawMouseYWhenStartedDrag = Controls.rawMouseY;
				Controls.rawMouseXWhenStartedDrag = Controls.rawMouseX;
			}
		});
		document.body.addEventListener('mouseup', event=>{
			if(event.button==0){
				Controls.mouseButton0 = 0;
			}
		});
		document.body.addEventListener('wheel', function(event) {
			event.preventDefault(); // Prevents the default scrolling behavior
			const scrollAmount = event.deltaY; // Gets the vertical scroll amount
			game.onMouseWheelChange(scrollAmount); // Calls your function with the scroll amount
		}, {passive: false}); // Setting passive to false allows you to call preventDefault
		//canv.dom.style.cursor = "none"; //hide mouse cursor cuz its slightly out of sync with the player's blob and is annoying
	}
	let now = time();
	let age = now-timeStarted; //how many seconds ago did this page transition start?
	let dt = Math.max(0, Math.min(now-lastTimeOf_doGraphicsDtAgeByterectAndMore, .2));
	lastTimeOf_doGraphicsDtAgeByterectAndMore = now;
	canv.beforePaint();
	doGraphicsDtAgeByterect(dt, age, canv.byteRect);
	canv.afterPaint();
	//setTimeout(doGraphicsDtAgeByterectAndMore, 1); //FIXME do requestAnimationFrame instead, for lower lag? or does waiting 1 more millisecond give it time to do other UI things?
	if(Controls.pause){
		console.log('Pause');
	}else{
		requestAnimationFrame(doGraphicsDtAgeByterectAndMore);
	}
};

//moving this up, to replace other INF const: const INF = 1<<29;
//const distSqArrays = []; //sideBits -> Int32Array(1<<(sideBits<<1)). reuse.


//given 6 uint10s, 3 of them in each int i j, returns 3 uint10s in an int.
const triMin = (i,j)=>{
	let iLow = i&mask10;
	let jLow = j&mask10;
	let iMid = (i>>>10)&mask10;
	let jMid = (j>>>10)&mask10;
	let iHigh = (i>>>20)&mask10;
	let jHigh = (j>>>20)&mask10;
	let low = iLow<jLow ? iLow : jLow;
	let mid = iMid<jMid ? iMid : jMid;
	let high = iHigh<jHigh ? iHigh : jHigh;
	return (high<<20)|(mid<<10)|low;
};

//updates this.rps.tridist based on the team at each voxel. FIXME should i make game.rps.team as a Uint8Array or maybe a packed 1 bit per pixel int array?
//Game.prototype.updateTridist = function(yFrom, yTo, xFrom, xTo){
Game.prototype.updateTridist = function(smallYFrom, smallYTo, smallXFrom, smallXTo, optionalBorder){
	const rpsTeam = this.rps.team;
	//const rpsTridist = this.rps.tridist;
	const rpsTridistSmall = this.rps.tridistSmall;
	const endSize = Size*4;
	//let border = 50; //FIXME dont hardcode this
	let border = optionalBorder || 32;
	let innerSmallYFrom = smallYFrom+border;
	let innerSmallYTo = smallYTo-border;
	let innerSmallXFrom = smallXFrom+border;
	let innerSmallXTo = smallXTo-border;
	
	for(let smallY=smallYFrom; smallY<smallYTo; smallY++){
		let smallYIsInner = innerSmallYFrom <= smallY && smallY < innerSmallYTo;
		for(let smallX=smallXFrom; smallX<smallXTo; smallX++){
			let smallI = (smallY<<SmallSizeBits)|smallX;
			let teams = 0;
			let topLeftI = toBig(smallI); //top left of the 4x4, where 16 indexs in the big arrays aligns to 1 index in small array.
			for(let dyAdd=0; dyAdd<endSize; dyAdd+=Size){ //MagnifyShift==2 meaning 4x4 aka (1<<2)**2
				for(let dx=0; dx<4; dx++){
					let i = (topLeftI+dyAdd)|dx;
					teams |= rpsTeam[i]; //get all teams in the 4x4
				}
			}
			
			//TODO rename game.rps.team to game.rps.teams cuz it can have a powerset of all 3 teams?
			//let teams = rpsTeam[i]; //can be REDTEAM, BLUETEAM, GREENTEAM, or any 2 or 3 of those. Each next team that is added there xors a mask bit.
			//&7 soonly 3 teams in 8 possible combos (powerset), meaning is there an even vs odd number of that team at that voxel. its reversible. addVox remVox.
			//3 uint10s that are max (1023) if it needs to be recomputed, or is 0 to mean that team is here so distance from it is 0.
			//rpsTridist[i] = teamsToTridistInt[teams&7];
			
			let isInner = smallYIsInner && (innerSmallXFrom <= smallX && smallX < innerSmallXTo);
			if(isInner){
				//rpsTridistSmall[smallI] = teamsToTridistInt[teams&7];
				rpsTridistSmall[smallI] = teamsToTridistInt[teams&7];
			}else{
				rpsTridistSmall[smallI] = triMin(rpsTridistSmall[smallI],teamsToTridistInt[teams&7]);
				//throw new Error('TODO dont overwrite distances but take minimum 3 times');
			}
			
			
			//rpsTridistSmall[toSmall(i)] = teamsToTridistInt[teams&7];
			//rpsTridist[i] = teams==REDTEAM ? 0 : 1023;
			//rpsTridist[i] = randInt(1024);
			//rpsTridist &= mask10; //FIXME remove this. its all red, the low 10 bits.
		}
	}
	//computeUint10Distances(rpsTridist, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
	//computeUint10Distances(rpsTridistSmall, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
	computeUint10Distances(rpsTridistSmall, SmallSizeBits, smallYFrom, smallYTo, smallXFrom, smallXTo); //modifies rpsTridist
	//broken and made it twice as slow so not pursuing this for now: computeUint10Distances2x2Magnify(rpsTridist, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
};

//color is a uint6. distanceSquaredArray is 1 of game.rps.boardR or game.rps.boardG or game.rps.boardB.
//OLD: colorChannel is RED or GREEN or BLUE as in "const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;".
//Only does the top left 1024x1024, not the whole 8192x8192 but that is planned to do sparsely later.
//Gotta get it working in basic way first, to play rock paper scissors per voxel.
Game.prototype.updateDistanceCacheOLD = function(distanceSquaredArray, color){
	const sideBits = 10; //1024x1024
	const side = 1<<sideBits;
	const fromY = 0, fromX = 0; //make sure it doesnt hang off the end of the 8192x8192
	const board = this.board;
	let countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				countVoxelsOfThatColor++;
			}
		}
	}
	let voxelsY = new Int16Array(countVoxelsOfThatColor);
	let voxelsX = new Int16Array(countVoxelsOfThatColor);
	countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				voxelsY[countVoxelsOfThatColor] = y;
				voxelsX[countVoxelsOfThatColor++] = x;
			}
		}
	}
	let distanceSquareds = computeSquaredDistances(sideBits, voxelsY, voxelsX); //1024x1024 if sideBits is 10
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			//let voxel = board[offset+movedX];
			//distanceSquared may be approximate or exact, depending on computeSquaredDistances has at least 2 implementations.
			let distanceSquared = distanceSquareds[(y<<sideBits)|x];
			distanceSquaredArray[(movedY<<SizeBits)|movedX] = distanceSquared;
		}
	}
};

/*const computeSquaredDistances = (sideBits, voxelYs, voxelXs)=>{
	//return computeSquaredDistances_exactButSlow(sideBits, voxelYs, voxelXs);
	//return computeSquaredDistances_approximateAndHexagonsAndFast(sideBits, voxelYs, voxelXs);
	return computeBalancedDistances(sideBits, voxelYs, voxelXs);
	
	//TODO make something like computeSquaredDistances_approximateAndHexagonsAndFast
	//but find a way to make it exact like computeSquaredDistances_exactButSlow and still fast.
	//The main difference is computeSquaredDistances_exactButSlow works by intersection of 2 parabolas in the 2 vertical steps.
};*/

// Lambda functions for extracting and setting distances
const mask10 = 0x3FF; //10 bit mask
const getDistance1 = (val) => (val & mask10); //approx distance (scaled by 3 or 4 depending on angle) to nearest REDTEAM voxel, given a tridist int.
const getDistance2 = (val) => ((val >> 10) & mask10); //GREENTEAM
const getDistance3 = (val) => ((val >> 20) & mask10); //BLUETEAM. FIXME is this right? did i mix up teams and order of bits here?
const setDistances = (d1, d2, d3) => ((d1 & mask10) | ((d2 & mask10) << 10) | ((d3 & mask10) << 20)); //makes an int for game.rps.tridist



//size->Int32Array(size)
const reusableIntArrays = {};
const reusableIntArray = size=>(reusableIntArrays[size] || (reusableIntArrays[size] = new Int32Array(size)));

//given 2 ints that each contain 3 uint10s, return 3 averages as an int, rounding down for each.
//This works 2024-11-12 but computeUint10Distances2x2Magnify does not, and since computeUint10Distances2x2Magnify is slow im trying something different,
//gonna make game.rps.tridist half size. or... maybe i should just reduce to 512x512 resolution and magnify the canvas. try that for now.
const tridistAve = (trintA,trintB)=>{
	let low10 = ((trintA&1023)+(trintB&1023))>>1;
	//let mid10 = ((trintA&0b11111111110000000000)+(trintB&0b11111111110000000000))>>1;
	let mid10 = ((trintA>>10)+(trintB>>10))<<9;
	//wait, is this gonna be the same as just (trintA+trintB)>>1? Try it...
	//return (trintA+trintB)>>1;
	let high10 = ((trintA>>>20)+(trintB>>20))<<19;
	return high10|mid10|low10;
};


//const computeUint10Distances = (tridist, shift, yFrom, yTo, xFrom, xTo)=>{
//If you use use a half (2x2) size 2d array, you'd use orthogonal 6 (default 3) and diagonal 8 (default 4),
//then interpolate between after it returns, or 1/4 size (4x4) would use orthogonal 12 diagonal 16, then interpolate.
//If you use bigger orthogonal andOr diagonal than those defaults, you might want to reduce maxDist (default 1019)
//so 1 more hop past that does not overflow uint10,
//and maybe a little less than that so 1023 (the max uint10) can mean havent processed this pixel.
const computeUint10Distances = (tridist, shift, yFrom, yTo, xFrom, xTo, orthogonalDist, diagonalDist, optionalMaxDist)=>{
    const orthogonal = orthogonalDist || 3;
    const diagonal = diagonalDist || 4;
    const maxDistance = optionalMaxDist || 1019;
    const mask10 = 0x3FF;
    const offset = 1 << shift;

    // Precompute bit masks
    const mask1 = mask10;
    const mask2 = mask10 << 10;
    const mask3 = mask10 << 20;

    // First pass: Top-left to bottom-right
    for (let y = yFrom; y < yTo; y++) {
        for (let x = xFrom; x < xTo; x++) {
            let i = (y << shift) | x;

            // Current distances
            let val = tridist[i];
            let dist1 = val & mask1;
            let dist2 = (val >>> 10) & mask10;
            let dist3 = (val >>> 20) & mask10;

            // Neighbor indices
            let i_nw = i - offset - 1;
            let i_n = i - offset;
            let i_w = i - 1;
            let i_ne = i - offset + 1;

            // Ensure indices are within bounds
            // (Assuming yFrom and xFrom are 0 and yTo and xTo are less than the grid size)
            // Otherwise, add boundary checks here.

            // Distances from neighbors
            let d1_nw = (tridist[i_nw] & mask1) + diagonal;
            let d1_n = (tridist[i_n] & mask1) + orthogonal;
            let d1_w = (tridist[i_w] & mask1) + orthogonal;
            let d1_ne = (tridist[i_ne] & mask1) + diagonal;

            let newDist1 = dist1;
            if (d1_nw < newDist1) newDist1 = d1_nw;
            if (d1_n < newDist1) newDist1 = d1_n;
            if (d1_w < newDist1) newDist1 = d1_w;
            if (d1_ne < newDist1) newDist1 = d1_ne;
            if (newDist1 > maxDistance) newDist1 = maxDistance;

            // Repeat for dist2
            let d2_nw = ((tridist[i_nw] >>> 10) & mask10) + diagonal;
            let d2_n = ((tridist[i_n] >>> 10) & mask10) + orthogonal;
            let d2_w = ((tridist[i_w] >>> 10) & mask10) + orthogonal;
            let d2_ne = ((tridist[i_ne] >>> 10) & mask10) + diagonal;

            let newDist2 = dist2;
            if (d2_nw < newDist2) newDist2 = d2_nw;
            if (d2_n < newDist2) newDist2 = d2_n;
            if (d2_w < newDist2) newDist2 = d2_w;
            if (d2_ne < newDist2) newDist2 = d2_ne;
            if (newDist2 > maxDistance) newDist2 = maxDistance;

            // Repeat for dist3
            let d3_nw = ((tridist[i_nw] >>> 20) & mask10) + diagonal;
            let d3_n = ((tridist[i_n] >>> 20) & mask10) + orthogonal;
            let d3_w = ((tridist[i_w] >>> 20) & mask10) + orthogonal;
            let d3_ne = ((tridist[i_ne] >>> 20) & mask10) + diagonal;

            let newDist3 = dist3;
            if (d3_nw < newDist3) newDist3 = d3_nw;
            if (d3_n < newDist3) newDist3 = d3_n;
            if (d3_w < newDist3) newDist3 = d3_w;
            if (d3_ne < newDist3) newDist3 = d3_ne;
            if (newDist3 > maxDistance) newDist3 = maxDistance;

            // Combine distances back into a single integer
            tridist[i] = (newDist3 << 20) | (newDist2 << 10) | newDist1;
        }
    }

    // Second pass: Bottom-right to top-left
    for (let y = yTo - 1; y >= yFrom; y--) {
        for (let x = xTo - 1; x >= xFrom; x--) {
            let i = (y << shift) | x;

            // Current distances
            let val = tridist[i];
            let dist1 = val & mask1;
            let dist2 = (val >>> 10) & mask10;
            let dist3 = (val >>> 20) & mask10;

            // Neighbor indices
            let i_se = i + offset + 1;
            let i_s = i + offset;
            let i_e = i + 1;
            let i_sw = i + offset - 1;

            // Ensure indices are within bounds
            // (Assuming yFrom and xFrom are 0 and yTo and xTo are less than the grid size)
            // Otherwise, add boundary checks here.

            // Distances from neighbors
            let d1_se = (tridist[i_se] & mask1) + diagonal;
            let d1_s = (tridist[i_s] & mask1) + orthogonal;
            let d1_e = (tridist[i_e] & mask1) + orthogonal;
            let d1_sw = (tridist[i_sw] & mask1) + diagonal;

            let newDist1 = dist1;
            if (d1_se < newDist1) newDist1 = d1_se;
            if (d1_s < newDist1) newDist1 = d1_s;
            if (d1_e < newDist1) newDist1 = d1_e;
            if (d1_sw < newDist1) newDist1 = d1_sw;
            if (newDist1 > maxDistance) newDist1 = maxDistance;

            // Repeat for dist2
            let d2_se = ((tridist[i_se] >>> 10) & mask10) + diagonal;
            let d2_s = ((tridist[i_s] >>> 10) & mask10) + orthogonal;
            let d2_e = ((tridist[i_e] >>> 10) & mask10) + orthogonal;
            let d2_sw = ((tridist[i_sw] >>> 10) & mask10) + diagonal;

            let newDist2 = dist2;
            if (d2_se < newDist2) newDist2 = d2_se;
            if (d2_s < newDist2) newDist2 = d2_s;
            if (d2_e < newDist2) newDist2 = d2_e;
            if (d2_sw < newDist2) newDist2 = d2_sw;
            if (newDist2 > maxDistance) newDist2 = maxDistance;

            // Repeat for dist3
            let d3_se = ((tridist[i_se] >>> 20) & mask10) + diagonal;
            let d3_s = ((tridist[i_s] >>> 20) & mask10) + orthogonal;
            let d3_e = ((tridist[i_e] >>> 20) & mask10) + orthogonal;
            let d3_sw = ((tridist[i_sw] >>> 20) & mask10) + diagonal;

            let newDist3 = dist3;
            if (d3_se < newDist3) newDist3 = d3_se;
            if (d3_s < newDist3) newDist3 = d3_s;
            if (d3_e < newDist3) newDist3 = d3_e;
            if (d3_sw < newDist3) newDist3 = d3_sw;
            if (newDist3 > maxDistance) newDist3 = maxDistance;

            // Combine distances back into a single integer
            tridist[i] = (newDist3 << 20) | (newDist2 << 10) | newDist1;
        }
    }
};


//this is actually just an approximation of distance, and the angles matter its not exact. not distance squared.
const computeSquaredDistances_approximateAndHexagonsAndFast = (sideBits, voxelYs, voxelXs)=>{
	const side = 1 << sideBits;
	const sideMask = side - 1;
	const size = side * side;
	distSq = distSqArrays[sideBits] || (distSqArrays[sideBits] = new Int32Array(1<<(sideBits<<1))); //reuse
    //const distSq = new Int32Array(size).fill(Infinity);
	distSq.fill(INF);
    
    // Initialize distSq for voxels
    for(let v = 0; v < voxelYs.length; v++){
        const y = voxelYs[v] & sideMask;
        const x = voxelXs[v] & sideMask;
        distSq[(y << sideBits) | x] = 0;
    }
    
    // First Pass: Top-Left to Bottom-Right
    for(let y = 0; y < side; y++){
        for(let x = 0; x < side; x++){
            let i = (y << sideBits) | x;
            if(distSq[i] === 0) continue; // Voxel
            
            // Check top-left
            if(y > 0 && x > 0){
                let j = ((y -1) << sideBits) | (x -1);
                let distance = distSq[j] + 2; // Diagonal distance squared = 2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check top
            if(y > 0){
                let j = ((y -1) << sideBits) | x;
                let distance = distSq[j] + 1; // Vertical distance squared =1
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check top-right
            if(y >0 && x < side -1){
                let j = ((y -1) << sideBits) | (x +1);
                let distance = distSq[j] + 2; // Diagonal distance squared =2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
        }
    }
    
    // Second Pass: Bottom-Right to Top-Left
    for(let y = side -1; y >=0; y--){
        for(let x = side -1; x >=0; x--){
            let i = (y << sideBits) | x;
            if(distSq[i] ===0) continue; // Voxel
            
            // Check bottom-right
            if(y < side -1 && x < side -1){
                let j = ((y +1) << sideBits) | (x +1);
                let distance = distSq[j] + 2; // Diagonal distance squared =2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check bottom
            if(y < side -1){
                let j = ((y +1) << sideBits) | x;
                let distance = distSq[j] +1; // Vertical distance squared =1
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check bottom-left
            if(y < side -1 && x >0){
                let j = ((y +1) << sideBits) | (x -1);
                let distance = distSq[j] +2; // Diagonal distance squared =2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
        }
    }
    
    return distSq; // distance squared from each pixel to nearest voxel.
};

//Opensource MIT licensed by Ben F Rayfield, that returns int array, 1 int per pixel,
//of distance squared to nearest voxel, of sparse voxels, in average constant time per pixel.
//https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js (that may be an old version as i modify it here)
const computeSquaredDistances_exactButSlow = (sideBits, voxelYs, voxelXs)=>{
  // Ensure sideBits does not exceed 15 to prevent integer overflow in squared distances
  if (sideBits > 15) throw new Error('sideBits must be <= 15');

  const side = 1 << sideBits;           // Compute side length (e.g., 512 for sideBits=9)
  const size = side * side;             // Total number of pixels in the grid

  // Initialize presence array: 1 where voxel exists, else 0
  const presence = new Uint8Array(size);
  for (let i = 0; i < voxelYs.length; i++) {
    const y = voxelYs[i];
    const x = voxelXs[i];
    if (y >= 0 && y < side && x >= 0 && x < side) {
      presence[(y << sideBits) | x] = 1; // Bitwise indexing for faster computation
    }
  }

  const INF = 0x7FFFFFFF;                // Representation of infinity for distances
  const distRow = new Int32Array(size);   // Intermediate distance array after row-wise transform
  const finalDist = new Int32Array(size); // Final distance array after column-wise transform

  // Initialize distRow: 0 for voxels, INF otherwise
  for (let i = 0; i < size; i++) {
    distRow[i] = presence[i] ? 0 : INF;
  }

  /**
   * Row-wise Distance Transform (Two Passes: Forward and Backward)
   * Optimized for cache locality by accessing memory sequentially.
   */
  for (let y = 0; y < side; y++) {
    const rowOffset = y << sideBits; // Compute row offset using bitwise shift (y * side)

    // Forward Pass: Left to Right
    let lastVoxelX = -INF;
    for (let x = 0; x < side; x++) {
      const idx = rowOffset | x; // Bitwise OR for faster index computation
      if (presence[idx] === 1) {
        lastVoxelX = x;
        distRow[idx] = 0; // Distance to itself is 0
      } else if (lastVoxelX !== -INF) {
        const dx = x - lastVoxelX;
        const dxSq = Math.imul(dx, dx); // Accurate computation of dx²
        if (dxSq < distRow[idx]) {
          distRow[idx] = dxSq; // Update distance if smaller
        }
      }
    }

    // Backward Pass: Right to Left
    lastVoxelX = -INF;
    for (let x = side - 1; x >= 0; x--) {
      const idx = rowOffset | x;
      if (presence[idx] === 1) {
        lastVoxelX = x;
        distRow[idx] = 0;
      } else if (lastVoxelX !== -INF) {
        const dx = lastVoxelX - x;
        const dxSq = Math.imul(dx, dx);
        if (dxSq < distRow[idx]) {
          distRow[idx] = dxSq;
        }
      }
    }
  }

  // Initialize finalDist as a copy of distRow
  for (let i = 0; i < size; i++) {
    finalDist[i] = distRow[i];
  }

  /**
   * Column-wise Distance Transform (Two Passes: Forward and Backward)
   * Implements the Felzenszwalb and Huttenlocher 1D Distance Transform for each column.
   * This ensures accurate computation of squared Euclidean distances.
   */

  /**
   * Helper function to compute the 1D squared distance transform.
   * Implements the algorithm by Felzenszwalb and Huttenlocher (2004).
   * @param {Int32Array} f - The input array representing squared horizontal distances.
   * @param {number} n - The length of the input array.
   * @returns {Int32Array} - The output array representing squared Euclidean distances.
   */
  const distanceTransform1D = (f, n) => {
    const d = new Int32Array(n);
    const v = new Int32Array(n);
    const z = new Float32Array(n + 1);
    let k = 0;
    v[0] = 0;
    z[0] = -Infinity;
    z[1] = +Infinity;

    for (let q = 1; q < n; q++) {
      let s;
      do {
        const i = v[k];
        // Compute the intersection point between the parabola at i and q
        s = ((f[q] + Math.imul(q, q)) - (f[i] + Math.imul(i, i))) / (2 * q - 2 * i);
        if (s <= z[k]) {
          k--;
        } else {
          break;
        }
      } while (k >= 0);

      k++;
      v[k] = q;
      z[k] = s;
      z[k + 1] = +Infinity;
    }

    k = 0;
    for (let q = 0; q < n; q++) {
      while (z[k + 1] < q) {
        k++;
      }
      const i = v[k];
      d[q] = Math.imul(q - i, q - i) + f[i];
    }

    return d;
  };

  // Perform column-wise distance transform using the 1D distance transform
  for (let x = 0; x < side; x++) {
    // Extract the column's row-wise distances
    const f = new Int32Array(side);
    for (let y = 0; y < side; y++) {
      const idx = (y << sideBits) | x;
      f[y] = distRow[idx];
    }

    // Compute the 1D distance transform for the column
    const dt = distanceTransform1D(f, side);

    // Update the finalDist array with the computed distances
    for (let y = 0; y < side; y++) {
      const idx = (y << sideBits) | x;
      finalDist[idx] = dt[y];
    }
  }

  return finalDist; // Return the final squared distance array
};


window.onload = ()=>{
	timeStarted = time();
	doGraphicsDtAgeByterectAndMore();
};



</script>
</head>
<body>
<textarea id=mainTextarea onInput=game.onTextareaInput(this.value); style="background-color:black;color:white;position:absolute;z-index:10;opacity:.7" rows=60 cols=70>testing</textarea>
</body>
</html>
