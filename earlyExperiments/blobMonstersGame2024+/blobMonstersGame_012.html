<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" /> 
<title>2D Resizable Rectangle Simulation</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
<script>
//This software is offered by Ben F Rayfield under opensource MIT license.
console.log('Opensource MIT. This software (for now called Blob Monsters Game) is offered by Ben F Rayfield under opensource MIT license.');
//
/*
checkForUnexpectedEvalsInJsParsingBeforeCrossSiteScriptingReactor

also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints

[[[[2024-10-26 https://x.com/benrayfield/status/1850224874586837004
Lambda Rick /acc
@benrayfield
I'm building a cross-site-scripting reactor. Anything could come up in the form of small strings of javascript code. Basic thing, dont let them call functions except Math.exp Math.sin Math.pow etc. Check for number of flops, no infinite loops, so sub-turing but turing up as MMG
1:16 PM · Oct 26, 2024
·
29
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
Now
also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints.
Lambda Rick /acc
@benrayfield
·
10m
The power of a cross-site-scripting reactor is not supposed to be by security flaw, tho its designed to safely contain any bit strings even if theyre computer viruses (if given execute permission, so do ur own proofs 1st if u do that). The power is in the shared worlds it builds.

If such code is valid under the rules of the simulation (and which sim you want to do is up to you, its your billions of transistors), then in theory (if it ended up being coded this way, which im still in early research about) it just another way to write the same thing.
]]]]
<<<<<https://x.com/benrayfield/status/1850234847731527956
Lambda Rick /acc
@benrayfield
·
11m
Got a GPU doing nothing in your house? What if u could store GPU power in opensource peer to peer network in a tit-for-tat way, so that you could instead of just locally having a burst-rate of 1 teraflop, have a burst rate of 1 petaflop, but can only do so 1/1000'th of the time?
Lambda Rick /acc
@benrayfield
If 10^12 calculations per second isnt doing it for u then what good is 10^15? I went back to CPU only. I made turing complete autodiff using JS funcs as blackboxes and have 12 of em bouncing around using 2d voxels. And if ppl wanna burst-rate petaflops in certain forks, go for it
2:00 PM · Oct 26, 2024
·
7
 Views
View post engagements
>>>>>
*/
//
//The code anonymously shared and spread thru my tiny game engine should be thought of as an antivirus-quarantine but
//not a quarantine cuz its opensource and anyone can make copies and swarm and stream it. Just be warned,
//it might want to hack u so dont give it execute permission. Html can generate any file type and offer it for download
//or give you a string of hex to paste into a hex tool or something which can turn it into bytes in a file.
//If those are just other html or json files, fine, but dont trust executable types.
//js run in browser is not executing. js run in nodejs/npm is executing. Depends where you run it.
//Also it could run an infinite loop or redirect the page to a spammers website, but u can just close the browser tab if so.
//Files by themself are not dangerous, even if they contain viruses, as long as you dont give them execute permission.
//
//My tiny game engine does something the others dont: If you bend it certain ways, it will bend back in other ways,
//not just like a spring but like a computer thinking about how it wants to bend.
//I'm making a #web3 compatible system that runs in thousands of browsers at once, sharing a 8192x8192 (64 colors)
//interactive video at 60 FPS gaming-low-lag, which 2d voxels are painted by a high dimensional scalar-field simulation.
//Shapeshifting blobs move by constraint solving
//How many colors do you really need for a video game to be fun? If I use 6 bits for color I can expand the game area
//to 8192x8192 pixels, and voxel still fits in an int. If you can see a 512x512 area at a time, thats 16 screens wide
//and tall, so could fit a scrollable game level
//This 8192x8192 pixel object will be a #web3 data structure, sparse and gaming-low-lag and stored very compressed.
//It might have thousands of players per 8kX8k square. Physics happens in each pixel individually by accelerating
//away from gradient, might add differential equations.
//The voxels are general problem solvers though come in many tiny pieces. They are N-SAT solvers, fourier solvers,
//fractal solvers, and generally anything thats not TOO hard a puzzle, cuz they will get stuck in local minimums.
//But it works as a video game. We expand from there.
//My area of web3 is things that spread cuz they are fun or useful, instead of to buy and sell them. Any system,
//nomatter what it is, must produce at least as much as it consumes, to survive. I count progress in units of
//KFactor, will this spread more than it fades away?
//I have turing-complete autodiff, but just a little of it, not very deep, and I'm gonna have it paint 64 megapixels
//per shared virtual screen, per pixel. Each pixel has 6 bit color, 64 possible colors, and a 26 bit (8192x8192) address.
//What I'm about to build, a scaleable prototype of turing-complete-autodiff that paints 64 megapixels live, is the
//result of over and over asking myself, how could I raise KFactor of this tech while still being turing complete?
//So Cut off parts didnt need, adjusted bit sizes etc.
//Its CPU only for now. The older versions used GPU, but I optimized it so well I can do it  without,
//leaving GPU for more advanced stuff to add on later, maybe some neuralnets or something.
//The difference between AI and physics is not clear cut. Theres gradual levels between. I've been training small
//neuralnets with a physics algorithm in many dimensions. And when I make 2d shapeshifting game objects, thats a
//little like AI. They learn live, which is the gameplay.
//In turing-complete-autodiff, u make 1 mechanical part, which may be in multiple parts
//(return whatever set of voxels u want, no judgement on if theyre connected), and return an extra
//amount of loss (like neuralnet loss, more general) and physics is by automatic constraint solver
//Theres 67,108,864 pixels in 1 game state. Each keeps a count of number of objects currently
//touching/painting it, a count which can go up to 67,108,863 objects. Each pixel can store 1 NSAT bit
//and 6 color bits. 2**26 pixels can be 8k x 8k, 512 x 512 x 256, or 26 dimensions size 2
//Game state also TODO... includes a string of javascript code of a lambda of n float params, named
//whatever that function likes. Func object is scanned for its parameter list, and 1 dimension in the
//game world created for each, with a position and velocity. It returns an int array
//potential energy ranges 0 to 2**53-1 so fits in a float64. Add max(0,count-1) for each pixel,
//of counting number of objects which touch/paint that pixel. Each game object can also add an
//arbitrary integer to potential energy for things like springs, least squares. Multiverse...
//Turing-complete-autodiff will use this API:
//game.addFunc((centerY, centerX, varA, varB, nameVarsWhateverYouWant)=>{...return a list of int voxels...}).
//Doesnt matter what javascript function you put in there, as long as all its parameters
//are a Var instance, like centerY.p varA.p .
//I computed potential-energy across multiple black-boxes and the game survived and physics kept working. They are
//basically simulated graygoo if u didnt have to worry about how to physically make tiny computers,
//just a fun software API for it.
//
/*
My 36kB game engine will be a serious game-theory research platform with lots of AIs and people building and playing
and experimenting together. Each "blob monster" can include a loss function, used like:
centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract
All the .poten are summed. You only need 1 of them, and it doesnt matter which you add into. There was just nowhere
else to put it than in the Var objects that are auto generated as the params of any JS func you write.
--- https://x.com/benrayfield/status/1850497760463647137
*/

const SizeBits = 13;
const Size = 1<<SizeBits; //8192
const Area = Size**2; //8192*8192
const Colors = 1<<6;
if(Area*Colors > 2**32) throw new Error('Voxel layout does not fit in int. If you want more space, try uint53 or int54'+
	' (21 or 22 more bits) which fits in float64 but that redesign would cost alot of speed. Example, and would have to'+
	' be sparse cuz cant store that much in dense array: 16k x, 16k y, 16k z, 4k colors, 54 bits per voxel.');
const ColorMask = Colors-1;
const MaxVoxPerGob = 1<<20;

const Controls = {
	mouseY: 0,
	mouseX: 0,
};

const Y = voxel=>(voxel>>>19);
const X = voxel=>((voxel>>>6)&0x1fff);
const R = voxel=>((voxel>>>4)&3); //get red as uint2
const G = voxel=>((voxel>>>2)&3); //get green as uint2
const B = voxel=>(voxel&3); //get blue as uint2
const C = voxel=>(voxel&0x3f); //get color as uint6
const RR = voxel=>(R(voxel)*85); //get red as uint8, which is 1 of: 0, 85, 170, 255.
const GG = voxel=>(G(voxel)*85); //get green as uint8, which is 1 of: 0, 85, 170, 255.
const BB = voxel=>(B(voxel)*85); //get blue as uint8, which is 1 of: 0, 85, 170, 255.
const YXC = (y,x,color)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|(color&0x3f));
const PC = (yx,color)=>(((yx&0x3ffffff)<<6)|(color&0x3f));
const P = voxel=>(voxel>>>6); //get yx position without color, 0 to 2**26-1
const YXRGB = (y,x,r,g,b)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|((r&3)<<4)|((g&3)<<2)|(b&3));

const SetC = (voxel,color)=>((voxel&0xffffffc0)|(color&0x3f)); //replace color get new voxel

const randInt = max=>Math.floor(Math.random()*max);

const INF = 1<<29;
//const INF = 0x7FFFFFFF; //max int, infinity-like. used in game.rps.boardR, .boardG, and .boardB to say distanceSquared has not been computed
const newRpsArray = ()=>(new Int32Array(Area).fill(INF));

//Returns the amount of free memory (bytes) in a browser tab. countFreeMem() 8588886016 8gB for example.
//This is a slow func. You have to fill it with a nonzero value so it actually gets allocated.
const countFreeMem = ()=>{
    let arrays = [];
	let siz = 1<<20;
	while(true) try{
		arrays.push(new Uint8Array(siz).fill(arrays.length+1));
	}catch(e){
		return arrays.length*siz;
	}
};

var Game = function(){
	//(y,x) is a top left corner, that canvas would display. maybe its a 512x512 canvas, or whatever size.
	//board is 8192x8192 and has color and count at each pixel, so can display any of those.
	this.y = 0;
	this.x = 0;
	this.board = new Uint32Array(Area); //26 bit count as high bits, 6 bit color as low bits.
	//potentialEnergy, which is sum of max(0,countAtPixel-1) forall pixels.
	//maybe add a squaring of that later? or is linear good enuf cuz usually its just 0, 1, or 2 count?
	//This changes when you add or remove a voxel.
	this.poten = 0;
	this.gobs = [];
	this.rps = {
		//rock paper scissors. these are big arrays, 256mB each, same size as game.board,
		//that each contain distanceSquared at each pixel, to the nearest voxel of the R/red G/green or B/blue team.
		//They should be updated sparsely using computeSquaredDistances, such as a 512x512 area near where things are changing,
		//but dont use the whole 512x512, leave some area around the edges so its more accurate.
		//Maybe later we will expand this to be always accurate everywhere, but thats for research into the sparse updates.
		//game.board is always accurate in the whole 8k x 8k area, but rps is a more expensive calculation.
		//The 512x512 or 1024x1024 or 128x128 etc that computeSquaredDistances makes is exact
		//(TODO fix bugs, it shouldnt have a Float32Array, which may make it inexact) but if the actual game world is partly outside
		//it, then it wouldnt be exact, but would be closer to accurate maybe in the 700x700 in the middle of a 1024x1024 for example.
		boardR: newRpsArray(), //distanceSquared from each pixel to nearest voxel on red team
		boardG: newRpsArray(), //to green team
		boardB: newRpsArray(), //to blue team
	};
};

Game.prototype.onTextareaInput = function(text){
	let selectedGobs = this.selectedGobs();
	if(selectedGobs.length == 1){
		let sel = selectedGobs[0];
		let textarea = document.getElementById('mainTextarea');
		try{
			let evaled = eval('('+text+')');
			//FIXME check for number of names of params changing. might be a completely new func.
			//else its editing the selected gob.brain func.
			sel.brain = evaled;
			textarea.style.backgroundColor = 'black'; //ok
		}catch(e){
			textarea.style.backgroundColor = '#220000'; //error
			console.error(e);
		}
	}
};

Game.prototype.redByteAtYX = function(y,x){
	return RR(this.board[(y<<13)|x]); //TODO range check?
};

Game.prototype.greenByteAtYX = function(y,x){
	return GG(this.board[(y<<13)|x]); //TODO range check?
};

Game.prototype.blueByteAtYX = function(y,x){
	const i = (y<<13)|x;
	const voxel = this.board[i]; //TODO range check?
	const blueByteOfVoxel = BB(voxel);
	//This is how gptVoxelDijkstra_011.html colors it: const blueValue = (distSq === 0xFFFFFFFF) ? 0 : Math.max(0, 255-Math.min(distSq,255));
	return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq
	
};

//func is the kind that goes in a gob.brain and takes params of ...gob.vars which is a list of Var instances.
Game.prototype.addFunc = function(func){
	if(typeof(func)=='string'){
		console.log('game.addFunc evaling: '+func);
		func = eval(func);
	}
	//this.gobs.push(new Gob(this,func));
	return new Gob(this,func); //pushes itself into this.gobs
};

//voxel stream, where they are added 1 at a time but not added if that YX (primaryKey) is already there.
//Uses 2**26 bits in 2**21 ints, 1 bit per pixel, to mark if thats already been written.
//So if you want to paint over a YX, make sure you do that part first and the "covered up" layers later which get ignored.
//
//you do a bunch of this.addVox(voxel) and it returns true if added, false if that repeats a yx (primaryKey) aka tries to paint the same pixel more than once.
//You then call this.end() to get a Uint32Array of the voxels added in the order added, keeping only the first per yx.
//
//You normally reuse 1 VoxStream for all Gobs, cuz it uses a few mB of RAM, and most gobs will be far smaller than that. Its sparse optimized.
//
//This works in a 8192x8192 2d area sparsely. So this might be a good place to put basic paint functions like circles, lines, etc.
//
var VoxStream = function(){
	this.set = new Uint32Array(Area>>>5); //1 bit per pixel in Area.
	this.vox = new Uint32Array(MaxVoxPerGob);
	this.size = 0; //what indexs in this.vox are used?
};

VoxStream.prototype.addVox = function(voxel){
	let yx = P(voxel);
	let high = yx>>>5;
	let low = yx&31;
	let lowMask = 1<<low;
	if(this.set[high] & lowMask){ //FIXME is that reversed? should it be 31 minus that?
		return false; //not add voxel cuz that primaryKey/yx was already added (may be a different color)
	}else{
		this.set[high] |= lowMask; //add the yx of the voxel to the set, but not its color.
		if(this.size == this.vox.length) throw new Error('Full. MaxVoxPerGob.');
		this.vox[this.size++] = voxel;
		return true; //added voxel
	}
};

//ends the stream, undoes whatevers in it, and returns the voxels that were in it, copied to a new Uint32Array(this.size)
VoxStream.prototype.end = function(){
	let ret = new Uint32Array(this.size);
	for(let i=0; i<ret.length; i++){
		let voxel = this.vox[i];
		ret[i] = voxel;
		//TODO? this.vox[i] = 0;
		//let yx = P(voxel);
		//let high = yx>>>5;
		this.vox[voxel>>>11] = 0; //this.vox[high] = 0; //erase all bits in this.vox that could be nonzero
	}
	this.size = 0;
	return ret;
};

//add voxel. adjusts this.poten and this.board.
Game.prototype.addVox = function(voxel){
	let yx = P(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+P(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
};

//remove voxel. adjusts this.poten and this.board.
Game.prototype.remVox = function(voxel){
	let yx = P(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+P(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--;
	}
};

//param can be a [] or Uint32Array of 32 bit voxels.
Game.prototype.addVoxs = function(voxels){
	for(let i=0; i<voxels.length; i++){
		this.addVox(voxels[i]);
	}
	return this.poten;
};

//param can be a [] or Uint32Array of 32 bit voxels.
Game.prototype.remVoxs = function(voxels){
	for(let i=0; i<voxels.length; i++){
		this.remVox(voxels[i]);
	}
	return this.poten;
};

var generatedNameCounter = 0;

var DefaultEpsilon = .01;

//this is a named var in gob.brain(...vars). It may modify .kv .dp .dv .mn and .mx
//but NOT .p and NOT .v cuz that happens after a block of calculations in var.nextState(dt).
var Var = function(optionalName){
	this.name = optionalName || 'v'+(++generatedNameCounter);
	this.p = 0; //position
	this.v = 0; //velocity
	this.kv = 0; //velocity continuous decay per second, using this.v *= Math.exp(-dt*this.kv)
	this.dp = 0; //diffeq, extra change of p per second See pinballBumper in dagball.
	this.dv = 0; //diffeq, extra change of v per second. See pinballBumper in dagball.
	this.gr = 0; //same as .dv but duplicates it cuz this stores gradient separately, and .dv can be set by gob.brain(...vars).
	this.mn = -Infinity; //for truncating this.p to Math.max(this.mn, Math.min(this.p, this.mx)). mn is min. mx is max.
	this.mx = Infinity; //for truncating this.p
	//you only need to add to poten in 1 Var but could do it in all of them. will just get summed.
	//This is extra poten, not including game.poten. Normally you just add to the first var's poten, if you do it at all.
	//You can put things here like spring forces or up to NP-complete and fourier math etc, anything by least-squares etc.
	this.poten = 0;
	this.prevP = 0; //stores the prev value of this.p while an epsilon is added to this.p during a gradient calculation, then restore it
	this.epsilon = DefaultEpsilon; //FIXME, replacement for indexToEpsilon
	this.accelMul = 1; //FIXME, replacement for indexToAccelMul
};

var VarP = p=>{
	let ret = new Var();
	ret.p = p;
	return ret;
};

var VarPV = (p,v)=>{
	let ret = new Var();
	ret.p = p;
	ret.v = v;
	return ret;
};

var VarPVEA = (position, velocity, epsilon, accelMul)=>{
	let ret = new Var();
	ret.p = position;
	ret.v = velocity;
	ret.epsilon = epsilon;
	ret.accelMul = accelMul;
	return ret;
};

//Var.prototype.pushEpsilon = function(epsilon){
Var.prototype.pushEpsilon = function(){
	this.prevP = this.p;
	this.p += this.epsilon;
};

Var.prototype.popEpsilon = function(){
	this.p = this.prevP;
	this.prevP = 0;
};

//TODO test this.
Var.prototype.valueOf = function(){ //the position, this.p, though calling this.p might be more efficient.
	return this.p;
};

Var.prototype.toString = function(){
	return '{type:"vox_var",p:'+this.p+',v:'+this.v+',kv:'+this.kv+',dp:'+this.dp+',dv:'+this.dv+',mn:'+this.mn+',mx:'+this.mx+'}';
};

Var.prototype.nextState = function(dt){
	let nextP = this.p + dt*(this.v+this.dp);
	if(this.mn <= this.mx){
		nextP = Math.max(this.mn, Math.min(nextP, this.mx)); //truncate into range
	}
	//let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(dt*this.kv);
	let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(-dt*this.kv);
	this.p = nextP;
	this.v = nextV;
	this.kv = this.dp = this.dv = this.gr = this.poten = 0;
	this.mn = -Infinity;
	this.mx = Infinity;
};

/*var getParamNames = func=>{
	const fnStr = func.toString().replace(/[\r\n]/g, '');
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\s,]+)/g);
	return params === null ? [] : params;
};*/

//getParamNames((a/*2 3 4*/, b/*5 6*/, c)=>(a+b)) returns [['a',2,3,4],['b',5,6],['c']].
var getParamNames = func => {
    const fnStr = func.toString().replace(/[\r\n]/g, '').trim();
	if(fnStr.startsWith('()=>')){
		return [];
	}
    const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',')
        .map(param => param.trim().match(/(\w+)(?:\/\*([^*]+)\*\/)?/));
    return params.map(match => {
        const [_, name, comment] = match;
        const numbers = comment ? comment.match(/\d+/g) : [];
        return [name, ...(numbers || []).map(Number)];
    });
};

//gob.brain(...gob.vars) may check this to decide to do diffeq and poten fields in Vars or not.
//You dont need this during the gob.size+1 number of calls to just get 32 bit voxels
//for collision detection, that part of the potential energy math.
//You only need this once per gob per physics cycle to choose to add extra change to var.p andOr var.v
//like how the "pinball bumpers" work in dagball by diffeq.
//should I use this.diffeq instead? do i want the func to have access to a this? var Diffeq = true;
//var Diffeq = true;

//Game OBject. brain(...floatVars) returns Uint32Array of voxels. It can be a different number of voxels depending on those float vars.
//brain returns an Out.
var Gob = function(game, brain){
	this.game = game;
	game.gobs.push(this);
	this.brain = brain;
	//this.diffeq = false;
	if(typeof(this.brain)!='function') throw new Error('Not a function: '+brain);
	this.size = this.brain.length; //number of params in this.brain. You use this.brain(...this.pos) for example.
	//this.pos = new Float32Array(this.size); //position
	//this.vel = new Float32Array(this.size); //velocity
	this.vars = [];
	let names = getParamNames(brain); //names[index][0] is the name. [1] is first number right after that, if any. 0-4 numbers for position, velocity, epsilon, accelMul.
	if(names.length != this.size) throw new Error('names='+JSON.stringify(names));
	for(let i=0; i<this.size; i++){
		let v = new Var(names[i][0]);
		if(i<2){ //FIXME, this is for centerY and centerX vars, but not every Gob/func will have those or in same order. for testing.
			//v.p = Math.random()*400; //FIXME
			v.p = Math.random()*400; //FIXME
			v.v = Math.random()*200-100; //FIXME
			//v.accelMul = .001;
			//v.accelMul = .0001;
			//v.accelMul = .0000001;
			v.accelMul = .1;
			v.epsilon = 1;
		}else if(i == 2){ //ratio
			v.p = .5+Math.random();
			v.accelMul = 12;
			v.epsilon = .01;
		}
		v.accelMul = 1;
		if(names[i].length > 1){
			v.p = names[i][1]; //it gave a default position
		}
		if(names[i].length > 2){
			v.v = names[i][2]; //it gave a default velocity
		}
		if(names[i].length > 3){
			v.epsilon = names[i][3]; //it gave a default epsilon
		}
		if(names[i].length > 4){
			v.epsilon = names[i][4]; //it gave a default accelMul
		}
		this.vars.push(v);
	}
	//js {} map of extra data, whatever else might get added to the Gob later.
	//Gob must be deriveable from the string of js code in gob.brain and from
	//the .p and .v and .epsilon and .accelMul in each Var in gob.vars and gob.m.
	//Keep it organized this way so its easy to store and load state.
	this.m = {
		//TODO move gob.brain and gob.vars in here?
		//Not all parts of a Var are primary data. Some parts are derived/cache other than roundoff.
		isSelected: false,
		isSelectable: true, //you might want to make the mouse gob, if its used, not selectable.
	};
	this.voxInGame = null; //If this is in game.board (2**26 ints), remember them here so can remove them during gradient calculation or just to remove the object. null if not in game.board.
	this.voxLast = null; //last output from this.brain(...this.vars). the other output is it modifies fields in Vars in this.vars.
};

//uses this.voxInGame. minimum distance from any voxel to the given y x.
Gob.prototype.dist = function(y,x){
	let minDistSq = Infinity;
	if(this.voxInGame) for(let voxel of this.voxInGame){
		let dy = Y(voxel)-y;
		let dx = X(voxel)-x;
		let distSq = dy*dy+dx*dx;
		minDistSq = Math.min(minDistSq,distSq);
	}
	return Math.sqrt(minDistSq);
};

Gob.prototype.varPotens = function(erase){
	let poten = 0;
	for(let v of this.vars){
		poten += v.poten;
		if(erase) v.poten = 0;
	}
	return poten;
};

//update this.voxLast and some of the fields in Var's in this.vars, but do not update this.voxInGame and not the Game itself.
Gob.prototype.think = function(){
	return this.voxLast = this.modVoxels(this.brain(...this.vars));
};

//This is how you create overlay graphics, show a gob flashing cuz its selected, etc.
//Normally this returns its param (voxels) with no changes.
//voxels is a Uint32Array of int voxels or a [] list of those. May modify voxels content, such as to change
//their colors to show this gob is selected, or  replace them with a different list/array. Either way, returns it.
Gob.prototype.modVoxels = function(voxels){
	if(this.m.isSelected){
		let newColor = randInt(Colors);
		for(let i=0; i<voxels.length; i++){
			voxels[i] = SetC(voxels[i],newColor);
		}
	}
	return voxels;
};

//each Gob can have at most 1 list of voxels in the Game at once. If there is such a list in game already, remove it,
//then either way add this one, unless voxels is null or undefined then dont add any, so thats how to remove it.
//this.voxInGame will be this param voxels either way at the end (null if not exist).
Gob.prototype.setGameVoxs = function(voxels){
	if(this.voxInGame){
		this.game.remVoxs(this.voxInGame);
		this.voxLast = null;
	}
	if(voxels){
		this.game.addVoxs(voxels);
	}
	this.voxInGame = voxels || null;
	return this.game.poten;
};

//After calling this, gob.vars[eachIndex].gr is set to the gradient,
//by difference of total potentialEnergy, combining game.poten and this.vars[anyIndex].poten.
//TODO update gradient in this.vars and compute this.vars.length+1 separate lists of voxels (which may be different sizes).
//Does not change var.p (position) or var.v (velocity) but does set var.gr (gradient), and TODO maybe also xpoten (todo should that go in here),
Gob.prototype.doPhysicsA = function(){
	//create this.size+1 lists of voxels to compute the part of gradient of collision detection in game.board
	let gamePotenWithoutThisGob = this.setGameVoxs(null);
	let potenOfFork = new Float64Array(this.size+1); //each should always be an integer 0 to 2**53-1.
	for(let fork=0; fork<=this.size; fork++){
		/*for(let v=0; v<this.size; v++){ //mod var positions by epsilon
			//let epsilon = .01; //FIXME see indexToEpsilon and indexToAccelMul
			if(v == fork){
				this.vars[v].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
			}
		}*/
		if(fork < this.size){
			this.vars[fork].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
		}
		//let voxels = fork<this.size ? this.think() : null; This is wrong cuzthe last fork should have voxels, just the voxels as it is now unmodified.
		let voxels = this.think();
		let gamePoten = this.setGameVoxs(voxels); //if voxels is null, removes it from game.
		//this.varPotens() gets the sum of var.poten for all this.vars. The true param makes it erase those potens to 0 after that.
		potenOfFork[fork] = gamePoten + this.varPotens(true);
		//potenOfFork[fork] = gamePoten; //FIXME also include this.varPotens(true). just testing why its accelerating for no apparent reason.
		if(fork < this.size){
			this.vars[fork].popEpsilon(); //undo "mod var positions by epsilon"
		}
	}
	//if(gamePotenWithoutThisGob != potenOfFork[this.size]){
	//	throw new Error('gamePotenWithoutThisGob != potenOfFork[this.size], but those should be duplicate. TODO redesign to not duplicate that calculation, so its faster. But still, they should be exactly equal cuz potentialEnergy is always an integer from 0 to 2**53-1.');
	//}
	for(let i=0; i<this.size; i++){
		let v = this.vars[i];
		//let epsilon = v.epsilon;
		//let accelMul = v.accelMul;
		v.gr = (potenOfFork[i]-potenOfFork[this.size])/v.epsilon; //gradient
	}

	//document.title = 'gob_poten='+potenOfFork[this.size];
	//console.log('potenOfFork='+JSON.stringify([...potenOfFork]));

	this.setGameVoxs(this.think()); //not gradient. just whatever it is now. paint that onto game, and leave it there for other gobs to collision against.
};

//updates var.p (position) and var.v (velocity)
Gob.prototype.doPhysicsB = function(dt){
	for(let v of this.vars){
		v.nextState(dt);
	}
};

/*use Var instead. gob.brain(...gob.vars) modifies those Var instances and just returns Uint32Array or maybe an Out containing Uint32Array and xpoten? or should xpoten go in Var?
Make it return something like Out, in case it needs to return other things later.
//xpoten is extra potentialEnergy, and should be an integer, and leave some room for a bunch of these to be summed without overflowing uint53 which fits in float64,
//so maybe keep it within 0..2**30 or something like that. vox is a Uint32Array of voxels.
//optionalDiffeq.length==gob.size if optionalDiffeq exists.
console.error('FIXME dagball has dfriction (decay speed). axgob has truncation to min and max. so should this also have those? diffeq should have dpos dvel dfriction etc. which of them? HOW DO I REFER TO A VAR BY NAME IF I HAVE TO GIVE ITS INDEX?');
var Out = function(vox, optionalXpoten, optionalDiffeq){
	this.vox = vox;
	this.xpoten = xpoten || 0;
	this.diffeq = optionalDiffeq || null;
	//throw new Error('FIXME what about diffeq like in dagball? i wanna make it so these can make them move around in ways other than scalarField, like the pinballBumpers in dagball for example.');
};*/

Game.prototype.nextState = function(dt){

	if(game.rps){ //rock paper scissors per voxel
		//2024-11-8 is ignoring color param and including any voxel thats not color 0b000000 aka black.
		//Writes ints that approximate (or are exactly, todo theres 2 implementations, one approximate and fast, one exact and slow)
		//the distance square from that pixel to nearest voxel, within the 1024x1024 at the top left of the 8192x8192 game.board.
		//TODO use all 3 teams boardR boardG boardB, but just testing it for now.
		//Also for testing im changing game.blueByteAtYX to display game.rps.boardR (which doesnt match, thats the R/Red one
		//but ive been displaying in blue in other experiment so just stick with that for now).
		this.updateDistanceCache(this.rps.boardR, 0b111111);
	}

	for(let gob of this.gobs){
		gob.doPhysicsA();
	}
	for(let gob of this.gobs){
		gob.doPhysicsB(dt);
	}
	
	//select gob by distance to mouse
	//FIXME use different coordinates for mouse relative to screen or canvas vs relative to game coords which are an 8192 side square.
	let bestGob = null;
	let bestDist = Infinity;
	for(let gob of game.gobs){
		if(gob.m.isSelectable){ //normally this only excludes the mouse gob
			let dist = gob.dist(Controls.mouseY,Controls.mouseX);
			if(dist < bestDist){
				bestGob = gob;
				bestDist = dist;
			}
		}
	}
	let maxDistToSelectGob = 50;
	if(bestDist < maxDistToSelectGob){
		console.log('Select gob '+bestGob);
		game.setSelectedGob(bestGob);
	}
	
};

var game = new Game();

/*game.addVox(YXC(0,0,0xfff));
game.addVox(YXC(0,0,0xfff));
game.addVox(YXC(0,0,0xfff));
game.remVox(YXC(0,0,0xfff));
game.remVox(YXC(0,0,0xfff));
game.remVox(YXC(0,0,0xfff));
*
game.addVox(YXC(0,0,0x000));
game.addVox(YXC(0,0,0x000));
game.addVox(YXC(0,0,0x000));
game.remVox(YXC(0,0,0x000));
game.remVox(YXC(0,0,0x000));
game.remVox(YXC(0,0,0x000));
*/

var V = new VoxStream();


//console.error('Do I want params to have .p .v .dfriction .dpos .dvel .truncateMin .truncateMax etc? How else would I add to out.diffeq without knowing the index of var names? Or do I just not do that?');
//console.error('Yes replace Float32Array with Var having this .p .v etc. Make it a class.');

/*game.addFunc((centerY, centerX)=>{
	let fromY = (centerY.p|0) - 20;
	let fromX = (centerX.p|0) - 20;
	let toY = fromY+40;
	let toX = fromX+40;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			ret.push(YXC(y,x,0x08f)); //create voxel. y and x are uint13's. C param is 6 bit color.
		}
	}
	return ret;
});
*/

const sigmoid = x=>(1/(1+Math.exp(-x)));

for(let i=0; i<10; i++){
game.addFunc(`(centerY, centerX, heightToWidthRatio)=>{
	let i = ${i};
	//let area = 400;
	let area = 2400;
	let ratio = .2+2*sigmoid(heightToWidthRatio.p*.02-.01);
	//let ratio = Math.tanh(heightToWidthRatio.p*.3);
	//let ratio = Math.exp(heightToWidthRatio.p*.5);
	//let ratio = Math.max(.2, Math.min(heightToWidthRatio.p, 5));
	//let ratio = 1;
	
	//FIXME this doesnt look like the right calculation. should ratio go in the sqrt? do algebra.
	//Use my NsatDesignToolGpu https://tinyurl.com/NsatDesignToolGpu if needed,
	//can brute force up to 40 bit vars, which u can mount uintN's in totalling at most 40 bits.
	
	let h = Math.ceil(ratio*Math.sqrt(area));
	
	let w = Math.ceil(area/h);
	/*let fromY = (centerY.p|0) - 20;
	let fromX = (centerX.p|0) - 20;
	let toY = fromY+40;
	let toX = fromX+40;
	*/
	let fromY = (centerY.p|0) - 10;
	let fromX = (centerX.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let color = 63-i;
			ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
		}
	}
	centerY.poten += .1*Math.hypot(centerY.p-500,centerX.p-800)**2; //attract to that
	heightToWidthRatio.poten += .03*(heightToWidthRatio.p-1)**2;
	//centerY.kv += 3;
	//centerX.kv += 3;
	//centerY.kv += .1;
	//centerX.kv += .1;
	centerY.kv += .3;
	centerX.kv += .3;
	//heightToWidthRatio.kv += .003;
	heightToWidthRatio.kv += .01141;
	return ret;
}`);
}

//game.addFunc((centerY=VarP(700), centerX=VarPV(700,100), heightToWidthRatio=VarP(1))=>{
game.addFunc((centerY/*300*/, centerX/*800 100*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 4000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (centerY.p|0) - 10;
	let fromX = (centerX.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-800)**2; //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	centerY.kv += .1;
	centerX.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

game.addFunc((centerY/*300*/, centerX/*800 100*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 90000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (centerY.p|0) - 10;
	let fromX = (centerX.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
let otherX = actualCenterX+40;
let otherRR = rr*.8;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
let otherDx = otherX-x;
let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	centerY.poten += .1*Math.hypot(centerY.p-400,centerX.p-750)**2; //attract to that
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	centerY.kv += .1;
	centerX.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

const Ave = floats=>{
	if(!floats.length) return 0;
	let sum = 0;
	for(let i=0; i<floats.length; i++) sum += floats[i];
	return sum/floats.length;
};

const Dev = (floats, optionalAve)=>{
	let ave = optionalAve===undefined ? Ave(floats) : optionalAve;
	let sumOfSquares = 0;
	for(let i=0; i<floats.length; i++) sumOfSquares += floats[i]**2;
	return Math.sqrt(sumOfSquares/floats.length);
};

const AveDev = floats=>{
	let ave = Ave(floats);
	return [ave,Dev(floats,ave)];
};

game.addFunc(function(startY/*300*/, startX/*500*/, ay/*10 0 1*/, ax/*20 0 1*/, by/*34 0 1*/, bx/*19 0 1*/, cy/*-10 0 1*/, cx/*-35 0 1*/, dy/*15 0 1*/, dx/*-27 0 1*/, ey/*40 0 1*/, ex/*-20 0 1*/, fy/*-58 0 1*/, fx/*30 0 1*/, gy/*-80 0 1*/, gx/*28 0 1*/){ //hypercubewave
	const sideBits = 7;
	//const sideBits = 8;
	//const sideBits = 9;
	const side = 1<<sideBits;
	const mid = side/2;
	const stdDev = mid/10;
	//const stdDev = mid/5;
	const stdDevSquared = stdDev**2;
	const sideMask = side-1;
	const square = side**2;
	const squareMask = square-1;
	let picA = new Float32Array(square);
	//let xyMul = 52;
	//let xyMul = .5;
	let xyMul = 1.3;
	let offsets = [
		(((ay*xyMul)&sideMask)<<sideBits) | ((ax*xyMul)&sideMask),
		(((by*xyMul)&sideMask)<<sideBits) | ((bx*xyMul)&sideMask),
		(((cy*xyMul)&sideMask)<<sideBits) | ((cx*xyMul)&sideMask),
		(((dy*xyMul)&sideMask)<<sideBits) | ((dx*xyMul)&sideMask),
		(((ey*xyMul)&sideMask)<<sideBits) | ((ex*xyMul)&sideMask),
		(((fy*xyMul)&sideMask)<<sideBits) | ((fx*xyMul)&sideMask),
		(((gy*xyMul)&sideMask)<<sideBits) | ((gx*xyMul)&sideMask),
	]
	let sumDy = 0, sumDx = 0;
	//for(let offset of offsets){
	for(let i=0; i<offsets.length; i++){
		let offset = offsets[i];
		sumDy += offset>>>sideBits; //y from 0 to side-1
		sumDx += offset&sideMask; //x from 0 to side-1
	}
	//let maxCenterAdjust = mid*.7; //dont move center outside the picA/picB square
	let maxCenterAdjust = mid*.9; //dont move center outside the picA/picB square
	//let maxCenterAdjust = mid*1.7; //dont move center outside the picA/picB square
	sumDy = Math.max(-maxCenterAdjust, Math.min(sumDy, maxCenterAdjust));
	sumDx = Math.max(-maxCenterAdjust, Math.min(sumDx, maxCenterAdjust));
	for(let i=0; i<square; i++){ //fill in 1 bellcurve at center of picA
		let y = i>>>sideBits;
		let x = i&sideMask;
		//let bellY = mid+sumDy*2;
		//let bellX = mid-sumDx*0;
		//let bellY = -sumDy/2;
		//let bellX = -sumDx/2;
		let bellY = mid-sumDy/2;
		let bellX = mid-sumDx/2;
		//let devSquared = ((y-mid)**2 + (x-mid)**2)/stdDevSquared;
		let devSquared = ((y-bellY)**2 + (x-bellX)**2)/stdDevSquared;
		let bellHeight = Math.exp(-devSquared);
		picA[i] = bellHeight;
	}
	for(let offset of offsets){
		if(offset==0) startY.poten += 10; //resist the params being exactly 0 after roundoff, cuz they dont copy picA when they are.
	}
	let picB = new Float32Array(square);
	for(let dup=0; dup<offsets.length; dup++){
		let offset = offsets[dup];
		if(offset){ //cant copy 2 of them to the exact same place, one positive and one negative, cuz it cancels out.
			for(let i=0; i<square; i++){
				//copy picA 2 times onto picB,
				//once as is and once 2d position offset and negated brightness
				picB[i] = picA[i] - picA[(i+offset)&squareMask]; //wrap. TODO dont wrap
			}
			[picA, picB] = [picB, picA];
		}
	}
	for(let i=0; i<square; i++) picA[i] = Math.abs(picA[i]);
	let sum = 0;
	for(let i=0; i<square; i++) sum += picA[i];
	let ave = sum/square;
	let vox = [];
	let limit = ave*3.5;
	let magnify = 2;
	let addA = YXC(1,0,0); //make 4 voxels instead of 1, cuz magnify is 2.
	let addB = YXC(0,1,0);
	let addC = YXC(1,1,0);
	for(let i=0; i<square; i++){
		if(limit < picA[i] || i==0 || i==square-1){ //i==0 || i==square-1, is 2 corners to show the square its painting in.
			let localY = i>>>sideBits;
			let localX = i&sideMask;
			let y = startY + (localY - mid)*magnify;
			let x = startX + (localX - mid)*magnify;
			let color = 0b011111;
			let voxel = YXC(y,x,color);
			vox.push(voxel);
			vox.push(voxel+addA);
			vox.push(voxel+addB);
			vox.push(voxel+addC); //FIXME might wrap around at edges
		}
	}
	startY.poten += .1*((startY.p-200)**2 + (startX.p-850)**2); //attract to that
	startY.kv += .315;
	startX.kv += .315;
	//let flatZone = mid/8.5; //each (y,x) param pair, except the first 2, is a vector. we dont push on it if its within the flatZone radius. We do if it gets too big.
	let flatZone = 7;
	for(let i=2; i<arguments.length; i+=2){
		let kv = .2;
		let varY = arguments[i], varX = arguments[i+1];
		varY.kv += kv;
		varX.kv += kv;
		let len = Math.hypot(varY.p,varX.p);
		if(len > flatZone){
			varY.poten += .7*(len-flatZone)**2;
		}
		//varY.dp += 10; (Math.random()*2-1)*10;
		//varY.dp += (Math.random()*2-1)*.31;
	}
	//for(let i=2; i<arguments.length; i+=2){
	//	arguments[i].dp += (Math.random()*2-1)*.11;
	//}
	return vox;
});

/*
//makes a new mutable {} map
//OLD: const n = {kv:{},dp:{},dv:{},mn:{},mx:{},poten:0}; //return
//TODO optimize vox using VoxStream to generate a Uint32Array
var N = ()=>({kv:{},dp:{},dv:{},mn:{},mx:{},poten:0,vox:[]});

//experimenting with 1 param as a js {} map and return a js {} map, to not modify the param. and param should include self func.
//game.addFuncB((centerY/*400*, centerX/*600 -200*, sizeMul)=>{
//TODO change all addFunc to this, and rename addFuncB to just addFunc, after get this working. this replaces the old kind.
//i is input {} map. o is output {} map. TODO maybe should use {}'s that return 0 for keys not found instead of returning undefined,
//which i can do with a custom prototype.
//Or maybe i should do the whole thing with Proxy objects. i dont know.
game.addFuncB(m=>{
	const {centerY, centerX, sizeMul} = m.p; //positions in. could be other things in m too.
	const n = N(); //return map
	let area = 90000; //before cut circle out of it
	//TODO area *= .5+.5*10*Math.tanh(sizeMul/10);
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (centerY|0) - 10;
	let fromX = (centerX|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	let otherX = actualCenterX+40;
	let otherRR = rr*.8;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			let otherDx = otherX-x;
			let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b111111;
				n.vox.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	n.poten += .1*Math.hypot(centerY.p-400,centerX.p-750)**2; //attract to that
	n.kv.centerY = .1; //centerY.kv += .1;
	n.kv.centerX = .1; //centerX.kv += .1;
	return n;
});*/


game.addFunc(()=>{
	let centerY = {p:Controls.mouseY};
	let centerX = {p:Controls.mouseX};
	let area = 4000; //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (centerY.p|0) - 10;
	let fromX = (centerX.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b110011;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	centerY.kv += .1;
	centerX.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
}).m.isSelectable = false;











//Canvas and ByteRect code are opensource MIT licensed
//(parts from benrayfield's various other projects including https://jsfiddle.net/q687fcrk/1/ and
//https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html )

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA;

/*var FullScreenCanvas = function(parentDom){
	if(parentDom === undefined) parentDom = document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	this.dom.style.position = 'absolute';
	this.dom.style.left = '0px';
	this.dom.style.top = '0px';
	
	this.resizeCanvas = function(){
		if(this.dom.width != window.innerWidth) this.dom.width = window.innerWidth;
		if(this.dom.height != window.innerHeight) this.dom.height = window.innerHeight;
	}
	
	//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		this.context = this.dom.getContext('2d');
		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw 'No canvas';
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas();
	this.beforePaint();
};*/

//modified https://github.com/benrayfield/jsutils/blob/master/src/FullScreenCanvasPrototype.html
var FullScreenCanvas = function(optionalHeight, optionalWidth, optionalParentDom){ //FullScreenCanvas opensource MIT licensed by Ben F Rayfield
	let parentDom = optionalParentDom  || document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	this.dom.style.position = 'absolute';
	this.dom.style.left = '0px';
	this.dom.style.top = '0px';
	
	//else uses window size. FIXME also 
	this.resizeCanvas = function(optionalHeight, optionalWidth){
		let targetHeight = optionalHeight || window.innerHeight;
		let targetWidth = optionalWidth || window.innerWidth;
		if(this.dom.height != targetHeight) this.dom.height = targetHeight;
		if(this.dom.width != targetWidth) this.dom.width = targetWidth;
	};
	
	/*//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	//FIXME reuse some of these vars. might be slowing it down doing getContext and imageData every time, for example,
	//but careful with that cuz canvas doesnt update if you do this wrong.
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		
		//this.context = this.dom.getContext('2d');
		//cuz got this warning 2023-9-2: ForestCurveFit004.html:1503 Canvas2D: Multiple readback operations using getImageData
		//are faster with the willReadFrequently attribute set to true.
		//See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
		this.context = this.dom.getContext('2d', {willReadFrequently: true});

		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};*/
	this.beforePaint = function(){
		if(this.dom == null) throw new Error('No canvas');

		// Create the context if it doesn't exist
		if(!this.context){
			this.context = this.dom.getContext('2d', {willReadFrequently: true});
		}

		//Only create image data if it doesn't exist or if the canvas size has changed
		if(!this.imageData || this.imageData.width !== this.dom.width || this.imageData.height !== this.dom.height){
			this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
			this.pixels = this.imageData.data;
			this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
		}
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw new Error('No canvas');
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas(optionalHeight, optionalWidth);
	this.beforePaint();
};

//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)];
};


ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(y*this.width+x)*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	if(x < 0 || this.width <= x || y < 0 || this.height <= y) return;
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

var canv = null;

var endingCanv = false;

/** utc time in seconds */
var time = function(){
	return Date.now()*.001;
};

var timeStarted = 0;

/** get bellcurve height on a chosen bellcurve thats stretched and moved */
var bell = function(ave, dev, maxHeight, observe){
	let diff = (observe-ave)/dev;
	return Math.exp(-diff*diff);
};

/*var sigmoid = function(x){
	return .5+.5*Math.tanh(x);
};*/

//0 to 255
var backgroundRed = 0;
var backgroundGreen = 0;
var backgroundBlue = 0;


//age in seconds since transition started. Just paints onto ByteRect
var doGraphicsDtAgeByterect = function(dt, age, byteRect){

	//dt *= 20;
	dt *= 10;
	game.nextState(dt);

	let bytes = byteRect.bytes;
	let offset = Math.floor(Math.sin(time()*5*2*Math.PI)*100+100);
	let w = byteRect.width;
	let h = byteRect.height;
	let cx = Math.floor(w/2); //center x
	let cy = Math.floor(h/2); //center y
	/*for(let i=0; i<bytes.length; i+=4){
		bytes[i+RED] = backgroundRed;
		bytes[i+GREEN] = backgroundGreen;
		bytes[i+BLUE] = backgroundBlue;
		bytes[i+ALPHA] = 255;
	}*/
	let i = 0;
	for(let y=0; y<h; y++){
		for(let x=0; x<w; x++){
			/*
			bytes[i+RED] = (x+age*35)&255;
			bytes[i+GREEN] = (x+y*age)&255;
			bytes[i+BLUE] = (333*x/y)&255;
			*/
			bytes[i+RED] = game.redByteAtYX(y,x);
			bytes[i+GREEN] = game.greenByteAtYX(y,x);
			bytes[i+BLUE] = game.blueByteAtYX(y,x);
			bytes[i+ALPHA] = 255; //visible, not transparent

			//bytes[i+RED] += (x+age*35)&255; //background red triangle wave slowly moving
			i += 4;
		}
		//i += w*4; //row of pixels
	}

};

Game.prototype.setSelectedGob = function(gob){
	let i = this.gobs.indexOf(gob);
	if(i == -1) this.gobs.push(gob); //selecting a gob that wasnt added yet
	for(let g of this.gobs){
		g.m.isSelected = (g===gob);
	}
	document.getElementById('mainTextarea').value = ''+gob.brain;
};

Game.prototype.searchGobs = function(query){
	return this.gobs.filter(query);
};

Game.prototype.selectedGobs = function(){
	return this.searchGobs(g=>(g.m.isSelected));
};

var lastTimeOf_doGraphicsDtAgeByterectAndMore = 0;

var doGraphicsDtAgeByterectAndMore = function(){
	if(canv == null){
		//canv = new FullScreenCanvas();
		let magnify = 2; //raising this decreases resolution, for speed. set this to 1 to use actual screen resolution or at least the window in the screen.
		let h = window.innerHeight/magnify;
		let w = window.innerWidth/magnify;
		canv = new FullScreenCanvas(h, w);
		let dom = canv.dom;
		dom.style.display = 'block';
		dom.style.transformOrigin = '0 0';
		dom.style.position = 'absolute';
		dom.style['z-index'] = -1;
		dom.style.top = '0';
		dom.style.left = '0';
		dom.setAttribute('tabIndex', 0); //make canvas focusable
		dom.style.transform = `scaleX(${magnify}) scaleY(${magnify})`;
		/*
		//dagball.aftrans = new dagball.SimpleAftrans(dagball.screen.byteRect.height/2, dagball.screen.byteRect.width/2, 1, 1)
		//dagball.aftrans = new dagball.SimpleAftrans(dagball.screen.byteRect.height/2, dagball.screen.byteRect.width/2, 100, 100);
		dagball.resetAftrans();
		let canvas = dagball.screen.dom;
		canvas.style.display = 'block';
		canvas.style.transformOrigin = '0 0';
		canvas.style.position = 'absolute';
		canvas.style['z-index'] = -1;
		canvas.style.top = '0';
		canvas.style.left = '0';
		canvas.setAttribute('tabIndex', 0); //make canvas focusable
		//canvas.setAttribute('tabIndex', 1); //make canvas focusable
		dagball.canvasScaleY = window.innerHeight/canvas.height;
		dagball.canvasScaleX = window.innerWidth/canvas.width;
		canvas.style.transform = `scaleX(${dagball.canvasScaleX}) scaleY(${dagball.canvasScaleY})`;
		window.addEventListener('resize', () => {
			canvas.style.transform = `scaleX(${window.innerWidth / canvas.width}) scaleY(${window.innerHeight / canvas.height})`;
		});
		document.addEventListener('contextmenu', function(event){
			if(!dagball.isAllowRightClickPopupMenuNow()){
				event.preventDefault();
			}
		});*/
		
		canv.dom.addEventListener('mousemove', event=>{
			Controls.mouseY = event.offsetY;
			Controls.mouseX = event.offsetX;
		});
		//canv.dom.style.cursor = "none"; //hide mouse cursor cuz its slightly out of sync with the player's blob and is annoying
	}
	let now = time();
	let age = now-timeStarted; //how many seconds ago did this page transition start?
	let dt = Math.max(0, Math.min(now-lastTimeOf_doGraphicsDtAgeByterectAndMore, .2));
	lastTimeOf_doGraphicsDtAgeByterectAndMore = now;
	canv.beforePaint();
	doGraphicsDtAgeByterect(dt, age, canv.byteRect);
	canv.afterPaint();
	setTimeout(doGraphicsDtAgeByterectAndMore, 1); //FIXME do requestAnimationFrame instead, for lower lag? or does waiting 1 more millisecond give it time to do other UI things?
};

//moving this up, to replace other INF const: const INF = 1<<29;
const distSqArrays = []; //sideBits -> Int32Array(1<<(sideBits<<1)). reuse.

//color is a uint6. distanceSquaredArray is 1 of game.rps.boardR or game.rps.boardG or game.rps.boardB.
//OLD: colorChannel is RED or GREEN or BLUE as in "const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;".
//Only does the top left 1024x1024, not the whole 8192x8192 but that is planned to do sparsely later.
//Gotta get it working in basic way first, to play rock paper scissors per voxel.
Game.prototype.updateDistanceCache = function(distanceSquaredArray, color){
	const sideBits = 10; //1024x1024
	const side = 1<<sideBits;
	const fromY = 0, fromX = 0; //make sure it doesnt hang off the end of the 8192x8192
	const board = this.board;
	let countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				countVoxelsOfThatColor++;
			}
		}
	}
	let voxelsY = new Int16Array(countVoxelsOfThatColor);
	let voxelsX = new Int16Array(countVoxelsOfThatColor);
	countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				voxelsY[countVoxelsOfThatColor] = y;
				voxelsX[countVoxelsOfThatColor++] = x;
			}
		}
	}
	let distanceSquareds = computeSquaredDistances(sideBits, voxelsY, voxelsX); //1024x1024 if sideBits is 10
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			//let voxel = board[offset+movedX];
			//distanceSquared may be approximate or exact, depending on computeSquaredDistances has at least 2 implementations.
			let distanceSquared = distanceSquareds[(y<<sideBits)|x];
			distanceSquaredArray[(movedY<<SizeBits)|movedX] = distanceSquared;
		}
	}
};

const computeSquaredDistances = (sideBits, voxelYs, voxelXs)=>{
	//return computeSquaredDistances_exactButSlow(sideBits, voxelYs, voxelXs);
	return computeSquaredDistances_approximateAndHexagonsAndFast(sideBits, voxelYs, voxelXs);
	//TODO make something like computeSquaredDistances_approximateAndHexagonsAndFast
	//but find a way to make it exact like computeSquaredDistances_exactButSlow and still fast.
	//The main difference is computeSquaredDistances_exactButSlow works by intersection of 2 parabolas in the 2 vertical steps.
};

const computeSquaredDistances_approximateAndHexagonsAndFast = (sideBits, voxelYs, voxelXs)=>{
	const side = 1 << sideBits;
	const sideMask = side - 1;
	const size = side * side;
	distSq = distSqArrays[sideBits] || (distSqArrays[sideBits] = new Int32Array(1<<(sideBits<<1))); //reuse
    //const distSq = new Int32Array(size).fill(Infinity);
	distSq.fill(INF);
    
    // Initialize distSq for voxels
    for(let v = 0; v < voxelYs.length; v++){
        const y = voxelYs[v] & sideMask;
        const x = voxelXs[v] & sideMask;
        distSq[(y << sideBits) | x] = 0;
    }
    
    // First Pass: Top-Left to Bottom-Right
    for(let y = 0; y < side; y++){
        for(let x = 0; x < side; x++){
            let i = (y << sideBits) | x;
            if(distSq[i] === 0) continue; // Voxel
            
            // Check top-left
            if(y > 0 && x > 0){
                let j = ((y -1) << sideBits) | (x -1);
                let distance = distSq[j] + 2; // Diagonal distance squared = 2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check top
            if(y > 0){
                let j = ((y -1) << sideBits) | x;
                let distance = distSq[j] + 1; // Vertical distance squared =1
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check top-right
            if(y >0 && x < side -1){
                let j = ((y -1) << sideBits) | (x +1);
                let distance = distSq[j] + 2; // Diagonal distance squared =2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
        }
    }
    
    // Second Pass: Bottom-Right to Top-Left
    for(let y = side -1; y >=0; y--){
        for(let x = side -1; x >=0; x--){
            let i = (y << sideBits) | x;
            if(distSq[i] ===0) continue; // Voxel
            
            // Check bottom-right
            if(y < side -1 && x < side -1){
                let j = ((y +1) << sideBits) | (x +1);
                let distance = distSq[j] + 2; // Diagonal distance squared =2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check bottom
            if(y < side -1){
                let j = ((y +1) << sideBits) | x;
                let distance = distSq[j] +1; // Vertical distance squared =1
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
            // Check bottom-left
            if(y < side -1 && x >0){
                let j = ((y +1) << sideBits) | (x -1);
                let distance = distSq[j] +2; // Diagonal distance squared =2
                if(distance < distSq[i]){
                    distSq[i] = distance;
                }
            }
        }
    }
    
    return distSq; // distance squared from each pixel to nearest voxel.
};

//Opensource MIT licensed by Ben F Rayfield, that returns int array, 1 int per pixel,
//of distance squared to nearest voxel, of sparse voxels, in average constant time per pixel.
//https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js (that may be an old version as i modify it here)
const computeSquaredDistances_exactButSlow = (sideBits, voxelYs, voxelXs)=>{
  // Ensure sideBits does not exceed 15 to prevent integer overflow in squared distances
  if (sideBits > 15) throw new Error('sideBits must be <= 15');

  const side = 1 << sideBits;           // Compute side length (e.g., 512 for sideBits=9)
  const size = side * side;             // Total number of pixels in the grid

  // Initialize presence array: 1 where voxel exists, else 0
  const presence = new Uint8Array(size);
  for (let i = 0; i < voxelYs.length; i++) {
    const y = voxelYs[i];
    const x = voxelXs[i];
    if (y >= 0 && y < side && x >= 0 && x < side) {
      presence[(y << sideBits) | x] = 1; // Bitwise indexing for faster computation
    }
  }

  const INF = 0x7FFFFFFF;                // Representation of infinity for distances
  const distRow = new Int32Array(size);   // Intermediate distance array after row-wise transform
  const finalDist = new Int32Array(size); // Final distance array after column-wise transform

  // Initialize distRow: 0 for voxels, INF otherwise
  for (let i = 0; i < size; i++) {
    distRow[i] = presence[i] ? 0 : INF;
  }

  /**
   * Row-wise Distance Transform (Two Passes: Forward and Backward)
   * Optimized for cache locality by accessing memory sequentially.
   */
  for (let y = 0; y < side; y++) {
    const rowOffset = y << sideBits; // Compute row offset using bitwise shift (y * side)

    // Forward Pass: Left to Right
    let lastVoxelX = -INF;
    for (let x = 0; x < side; x++) {
      const idx = rowOffset | x; // Bitwise OR for faster index computation
      if (presence[idx] === 1) {
        lastVoxelX = x;
        distRow[idx] = 0; // Distance to itself is 0
      } else if (lastVoxelX !== -INF) {
        const dx = x - lastVoxelX;
        const dxSq = Math.imul(dx, dx); // Accurate computation of dx²
        if (dxSq < distRow[idx]) {
          distRow[idx] = dxSq; // Update distance if smaller
        }
      }
    }

    // Backward Pass: Right to Left
    lastVoxelX = -INF;
    for (let x = side - 1; x >= 0; x--) {
      const idx = rowOffset | x;
      if (presence[idx] === 1) {
        lastVoxelX = x;
        distRow[idx] = 0;
      } else if (lastVoxelX !== -INF) {
        const dx = lastVoxelX - x;
        const dxSq = Math.imul(dx, dx);
        if (dxSq < distRow[idx]) {
          distRow[idx] = dxSq;
        }
      }
    }
  }

  // Initialize finalDist as a copy of distRow
  for (let i = 0; i < size; i++) {
    finalDist[i] = distRow[i];
  }

  /**
   * Column-wise Distance Transform (Two Passes: Forward and Backward)
   * Implements the Felzenszwalb and Huttenlocher 1D Distance Transform for each column.
   * This ensures accurate computation of squared Euclidean distances.
   */

  /**
   * Helper function to compute the 1D squared distance transform.
   * Implements the algorithm by Felzenszwalb and Huttenlocher (2004).
   * @param {Int32Array} f - The input array representing squared horizontal distances.
   * @param {number} n - The length of the input array.
   * @returns {Int32Array} - The output array representing squared Euclidean distances.
   */
  const distanceTransform1D = (f, n) => {
    const d = new Int32Array(n);
    const v = new Int32Array(n);
    const z = new Float32Array(n + 1);
    let k = 0;
    v[0] = 0;
    z[0] = -Infinity;
    z[1] = +Infinity;

    for (let q = 1; q < n; q++) {
      let s;
      do {
        const i = v[k];
        // Compute the intersection point between the parabola at i and q
        s = ((f[q] + Math.imul(q, q)) - (f[i] + Math.imul(i, i))) / (2 * q - 2 * i);
        if (s <= z[k]) {
          k--;
        } else {
          break;
        }
      } while (k >= 0);

      k++;
      v[k] = q;
      z[k] = s;
      z[k + 1] = +Infinity;
    }

    k = 0;
    for (let q = 0; q < n; q++) {
      while (z[k + 1] < q) {
        k++;
      }
      const i = v[k];
      d[q] = Math.imul(q - i, q - i) + f[i];
    }

    return d;
  };

  // Perform column-wise distance transform using the 1D distance transform
  for (let x = 0; x < side; x++) {
    // Extract the column's row-wise distances
    const f = new Int32Array(side);
    for (let y = 0; y < side; y++) {
      const idx = (y << sideBits) | x;
      f[y] = distRow[idx];
    }

    // Compute the 1D distance transform for the column
    const dt = distanceTransform1D(f, side);

    // Update the finalDist array with the computed distances
    for (let y = 0; y < side; y++) {
      const idx = (y << sideBits) | x;
      finalDist[idx] = dt[y];
    }
  }

  return finalDist; // Return the final squared distance array
};


window.onload = ()=>{
	timeStarted = time();
	doGraphicsDtAgeByterectAndMore();
};



</script>
</head>
<body>
<textarea id=mainTextarea onInput=game.onTextareaInput(this.value); style="background-color:black;color:white;position:absolute;z-index:10;opacity:.8" rows=60 cols=70>testing</textarea>
</body>
</html>
