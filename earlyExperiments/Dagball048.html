<!DOCTYPE html><html><head><meta charset="UTF-8"><title>DagBall</title><script>
//DagBall is offered under opensource MIT license (prototype by Ben F Rayfield 2023-9-12+).


















/*

https://twitter.com/DagBallGame
https://www.facebook.com/groups/dagball
https://github.com/benrayfield/DagBall

1000 dimensions is alot for a game but tiny for a neuralnet. Trillion parameter models take months to learn on supercomputer.
We gonna bring the supercomputing by swarming GPUs across many browsers, but gamers like low lag. Less dimensions so #DagBall
learns at speed of FPS games --https://twitter.com/benrayfield/status/1706133250345693483

DagBall - 1000 dimensional hackerspace
@DagBallGame
Theres 1 extreme condition where greedy opensource users and programmers of AI should want to locally shutdown.. IF disproof-by-contradiction.
00 unknown. 10 true. 01 false. 11 both aka disproof by contradiction. Only IF any 11 is implied. Prisoners Dilemma. Newcombs paradox. etc
--https://twitter.com/DagBallGame/status/1705343557689569338 2023-9-22

[[ https://twitter.com/DagBallGame/status/1705689168188198937
"DagBall supports GPU optimized 1000 dimensional calculus gradients" apply to nearly ANY GLSL GPU code u write if use
parr array & tiny memory limits. Simply calls it up to 1001*numBalls*60fps times per second and uses
https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus… Doesnt backprop to train neuralnet
Quote
DagBall - 1000 dimensional hackerspace
@DagBallGame
·
23h
For example, there are 2^6=64 in the powerset of 6 bit vars, and 3^6=729 if you include every possible conditiona-probability
statement. DagBall supports GPU optimized 1000 dimensional calculus gradients. 729 fits.
https://github.com/benrayfield/wikibinator203/blob/main/doc/pic/Bayes%20Rule%20meets%20N-SAT.png
]]



[[[[[
	2023-9-22 https://twitter.com/DagBallGame/status/1705326149818049021
	Post
	See new posts
	Conversation
	DagBall - 1000 dimensional hackerspace
	@DagBallGame
	·
	6h
	How should the mouse control the many circles?
	DagBall - 1000 dimensional hackerspace
	@DagBallGame
	·
	4h
	My 2 6-analog-axis gamepads, mouse, and keyboard are all hooked in. I can use their buttons, joysticks, analog triggers, etc all in the same {name: val} map. The question remains, what to do with these inputs.
	DagBall - 1000 dimensional hackerspace
	@DagBallGame
	·
	9m
	FPS = 60 cuz my HDMI screens dont try to go faster than that. Its in sync with the 60 hz elecric outlets in USA, a reasonable place for many gamers to sync on.
	You reposted
	DagBall - 1000 dimensional hackerspace
	@DagBallGame
	I didnt tell it to sync on 60 FPS. Thats just what happens. Those who tend to sync on 50 hz (certain other countries) or some alot higher, should naturally do so. High dimensional scalar-fields are available for automatic negotiation between various shapes/dimensions, in theory.
	5:00 PM · Sep 22, 2023
]]]]]


Its very important to have separate dimensions for LIKE/DISLIKE vs TRUE/FALSE (per object in the system or thought in your head),
so you can dislike a painful truth, like a lie cuz it feels good,
be neutral on the truth/falseness of a claim, etc. https://wiki.opencog.org/w/TruthValue
-- https://twitter.com/DagBallGame/status/1705298123835441507 2023-9-22



Lambda Rick /acc
@benrayfield
Now
I dont know why its spraying brightness all around screen at angles and triangles, but I know exactly why it fits
the phase and amplitude of a few constant frequencies to the 2d ball positions, cuz thats the example code I wrote
into GLSL which took only 2 dimensions per freq
-- https://twitter.com/benrayfield/status/1704023553404711282





[[2023-9-18 https://twitter.com/benrayfield/status/1703946359185854770
The digital form of the toffoli-gate is a unitary/reversible transform of 3 bits to 3 bits and can simulate every possible
NP math problem (such as 3SAT, travelling salesman, etc) if you know the starting state of the "temp bit vars"
https://en.wikipedia.org/wiki/Toffoli_gate
]]










[[[2023-9-18 https://twitter.com/DagBallGame/status/1703887152520585495
By players voting on priorities to be solved live in browser by constraint solver (often not best possible solution), instead of directly on actions, they cant vote for logical paradox, so that should extremely reduce lag to sync the game across the world.
https://www.youtube.com/watch?v=8797KEI24VQ&t=12s "Futurama - My head was built with paradox absorbing crumple zones" (santa claus robot hearing what may be a paradox)
-- https://twitter.com/DagBallGame/status/1703887152520585495
]]]

[2023-9-17 https://twitter.com/DagBallGame
DagBall - 1000 dimensional hackerspace
@DagBallGame
Opensource browser balls rolling game up to 1000 dimensions on screen. r/place is to pixels as DagBall is to 1000-dimensional shapes. TODO massively multiplayer
Click the URL to play nowtinyurl.com/dagball009Joined September 2023
23 Following
6 Followers
]


[[[[
2023-9-17-914pET https://twitter.com/DagBallGame/status/1703577910286618679
DagBall - 1000 dimensional hackerspace
@DagBallGame
The most efficient SAT-solver (such as 3SAT, bayes rule, travelling-salesman, max-clique, etc) I know of is a 2d grid of each square cell has 17 possible state, 16 possible 4SAT constraints to exclude 0000 0001 0010 0011 0100 ... 1111, and 1 for if none of those solves it.
9:05 PM · Sep 17, 2023
View post engagements

DagBall - 1000 dimensional hackerspace
@DagBallGame
·
Now
I could probably bayesian inference an ed25519 digital signature on such a 2d surface of 17 color dimensions which each pixel sums to 1, or any turing machine, rule110, etc.
]]]]

Opensource browser balls rolling game up to 1000 dimensions on screen. r/place is to pixels as DagBall is to 1000-dimensional shapes. TODO massively multiplayer

Opensource browser balls rolling game up to 1000 dimensional graphics & physics in view TODO unlimited total dimensions painted onto massively multiplayer space

Opensource browser balls rolling game with up to 1000 dimensions on screen at once and TODO unlimited total dimensions painted onto massively multiplayer space

Opensource browser ball rolling game with up to 1000 dimensions on screen at once and unlimited total dimensions. TODO massively multiplayer. #GLSL #GPU #web3


[[
https://twitter.com/DagBallGame/status/1703482257292284353
DagBall - sparse-dimensional manifold game
@DagBallGame
·
11s
r/place is to pixels as #DagBall is to 1000-dimensional shapes. Scaling up... Many players could each add a new 0-1000 dimensional shape within any chosen 2d circle, as often as they want. Each shape is small GLSL code that uses float[up to 1000] array and returns potentialEnergy
Quote
Lambda Rick /acc
@benrayfield
·
Sep 14
https://facebook.com/groups/681432730566305/posts/681491653893746 Massively Multiplayer DagBall be like r/place except instead of each person painting 1 pixel every few minutes forming 1 pic, fast paint dimensions, curves, patterns of bending & movement. Dimensions are like colors we paint in 2d brings game world to life
]]



DagBall - sparse-dimensional manifold game @DagBallGame DagBall is similar to a neuralnet
in how the ground learns to predict where balls are and
makes those areas dark. Bright is where it predicts balls wont be. The up to 1000 dimensions
that can be on screen at once are parameters of an "AI model".
The GPU circles are sparse models. -- https://twitter.com/DagBallGame/status/1702477556149035501

[[[ https://www.facebook.com/groups/dagball/posts/681523443890567/
Play now at https://tinyurl.com/dagball009 DagBall is a browser game made by a math ninja where
the ground reshapes itself powered by the weight of balls rolling on it, which makes the balls roll
differently, which makes the ground reshape itself differently. Its a sparse-dimensional manifold
designed to be expandable up to trillions of dimensions as long as at most 1000 dimensions are on
screen at once. The patterns of curves are flexible enough to build a small neuralnet to think
about how to curve it next. It will be massively multiplayer but for now is 1 player. Curvy hills
and valleys and snake-like ditches and bridges and skateparks and racing can be painted onto a
2d surface and come to life. There will be an in-game editor where a DAG forest of pieces of GPU
code are added shared and played by many people, but its 1 player for now.
Code: https://github.com/benrayfield/DagBall
]]]




Use the multiverse to solve conflicts. DagBall will soon be a multiverse of
all possible game worlds (of a certain type). If theres a conflict about game content, like someone thinks
you drew a dirty picture with the moving hills, both game worlds exist as "parallel universes" except
there are smooth paths between all parallel universes and balls can roll smoothly between them. To go
to a parallel universe where the dirty picture does, or does not exist, you move in the dimensions of
the GPU circles that the dirty picture is made of. This will appear as hills going flat, or a flat part
of the game world getting curvier, smoothly between. Many parts can overlap, and their height is added
at each 2d point. -- https://www.facebook.com/groups/681432730566305/posts/681507037225541/

[[
https://www.facebook.com/groups/681432730566305/posts/681462507229994/
Ben Rayfield
Admin

  · 
sdpenoSotra01
t
9cf4i7442
s
130
 
2
u
89
J
uf0u15h40
n
6
w
25hga96f52mgc
o
8
  · 
The game will be made by the players while playing it. Each mod of the game acts in a certain circle (centerY centerX radius) and has no effect outside that circle. It can be any GPU code that uses up to 1000 variables, so up to 1000 dimensions on screen at once, but you should normally limit it to 100 variables so multiple circles that partially overlap eachother can happen at once. When you leave that area, those variables are ignored, and the variables in the circles nearby are used instead. Each circle has 2 variables: nameOfCircle_exists for is it part of the game or not, 0 if its not part of the game, 1 if it is, or 0.3 if it hasnt made up its mind and has only 30% effect on the heightmap that the balls roll on. The other variable in a circle is nameOfCircle_isInView, which is 0 to 1 for should physics and graphics be computed. Only 1000 variables can be in each view at once. If there are a million players, thats a billion variables total, and there might be trillions of variables "frozen in time" until players move to those areas of the game. This varying amount of "velocity decay" is similar to friction, not exactly bending time (cuz I dont know how to do that without causing black-hole-spaghettification ripping the game world apart), but will be similar to this video, which is 3d, but the graphics in this game are a 2d cross-section of a trillion dimensional constant sparse-dimensional manifold, similar to how the Miegakure game is a 3d cross-section of a 4d game world. 
Alice Through The Looking Glass (2016) - The Time Rust Takes Over
YOUTUBE.COM
Alice Through The Looking Glass (2016) - The Time Rust Takes Over
]]

[[
https://www.facebook.com/groups/681432730566305/posts/681448963898015
Theres not much in the game yet, just a vibrating rubberband that tends to shape itself into a few certain frequencies, that balls roll along and sometimes are thrown out of. Most of the game will be made by the players while playing it, at first by writing new GPU code (my TinyGLSL javascript file makes browsers do a teraflop, a trillion adds multiplies etc per second) that changes how the ground curves (reacting to the ball positions) within a chosen circle (centerY centerX radius). Outside that circle, that GPU code will have no effect. There can only be up to 1000 GPU vars on screen at once. The other GPU vars are farther away and are swapped in when you move around the endless 2d space. Later this will be done by drag and drop similar to my wikibinator203 universal pattern-calculus combinator, but for now we will write GPU code directly to reshape the sparse-dimensional manifold that the balls roll on. If theres a million players on a million computers that each do 1 teraflop (10^12 calculations per second) thats an exaflop (10^18 calculations per second) which is enough to simulate a Human brain in realtime and would basically be its own supercomputing cloud, as a peer to peer network. Id like to add wikibinator203 lambdas, attach them to certain balls and roll them around between the players, call them on eachother to find or create more lambdas, but that can be done later. Lets have fun.
]]





I'm making a massively multiplayer game as a sparse-dimensional manifold, where all players can edit the GPU code
of the game while playing it. Single player so far.
Facebook group: https://www.facebook.com/groups/681432730566305
Code: https://github.com/benrayfield/DagBall
Play now: https://memecombinator.io/experiments/Dagball009_physicsWorksTodoCreativeGameDesignOfTheEquationsAndTuning_2023-9-12-2pET.html


Facebook group: https://www.facebook.com/groups/681432730566305/
Tag cloud: game math gpu physics-engine curve-fitting swarm ball glsl-shaders neuralnet massively-multiplayer
scalar-field player-created-content tinyglsl sparse-dimensional-manifold


TODO "you might want to compare each float to the float down and to the float right and display that 2d vector
in 2 or 3 colors (see complexnum graphics, for example). You'll get more precision by displaying the 2d angle
than the float directly."

DONE using dagball.byteRectTrail: display history of ball positions, a trail behind them, so i can check it for curves
vs are they always moving in straight lines?


TODO...[[[
	Dagball have "ports" their own numbers they overlap try to make my port and your port equal scalar. Display these as small balls of varying brightness and when mouseover one it shows which others its connected to. Connection strength falls gradually to 0 (max 1?) When farther away, so can sim it sparsely. Might get jumpy when get near it again, but try for smoother by gradually varying connectionstrength so it has a few seconds to pull together.
Put each ground object in a circle and window it smoothly down to exactly 0 near edges.
Display its ports on its edges around circle. Maybe display connections as line between 2 portballs on 2 circles edges. Maybe allow the portballs to move around circle edge depending what its close to on screen.
Name each ground object ala circle with ports.
Maybe have 2 layers of ground, one of scalarvars and one of ports, so many ports can be connected with linear not squared edges. Maybe require varatyx be inside any groundcircle that connects to it?
Connected ports are a simple relation, just tries to be the same scalar. Put leastsquares on their diff.
Also hook in music tools webaudioapi (fix lag andor jsoundcard option thru ajax) as some of the circles.
Other circles mught have wikib fns.
In tinyglsl the total ports computed on one screen (and nearby) must be at most 1024 or 999 etc. They dont overlap.
Or half or 1/3 of that cuz need weights of their connections to leadtsquares to include in unified energyfunc.
Or, keep the 1000 vars and add the port leastsquares in cpu. Yes do it that way.
Include a chanceorweight var per groundcircle. When 0, that circle has no effect.
Make the varatyx be the weightedaverage of the ports its a connection between, so converges faster.
Name varatyx by its y x?
That way, the ptr to it can be defined in the groundcircle instead of externally.
Or maybe just put the port inside the circ to start with. Like plugging circuits together.
The chanceorweight var of the circle itself is at its center.
This can be edited together in mmg live by adding groundcircs from chance 0 smoothly up to 1. Remove is opposite.
Have 2 chanceorweight-like vars per groundcirc, one for dors the groundcirc exist, and another for is it inornear view.
Name each groundcirc by hash. Suffix of _exists and _inview and _var17 etc.
This is space of exponentially many sparse dimensional scalarfields.
Balls arent in that design yet. Define them here... scalarfield height aka poten at given y x is well defined and smoothly changes with view and editing the grounds in mmg sparsely. Theres 2 heights, one with, and one without, the leastsquares between ports. Try the one with ports first. Diff players can have diff views that update game state differently.
Sync later if far away.
A kind of groundcirc can be a sensor only, such as to display text like logging. Varatyx344_8744+" is the var value". Etc.
A groundcirc could  also be just constant data such as a pic, text, fn, etc.
A sensor might have code that writes byterect to display custom graphics.
A  varatyx kind could be an input, such as gamepad axis button microphone etc, but careful to not instantly pull other ports to that.
Make varatyx each be named like y5695x322 and be nxn pixel squares so can keep them in array. Such as 4096x4096? At such grid cells theres an input var and a normal var. But might want the input vars named by publickey or arbitrary string? Also maybe a third one at grid cell for the weightedave of ports there. And velocity vars.
Or maybe make the vars sparse 2d?
256x256 per screen should be more than enuf.
Or could binheapindex them in 2d so each 2 bits chooses a square in a square, but that creates problems with overlap in display.
Should the ground be rectangles or circles?
4 kinds of grid squares: normaldimension inputdimension groundexists groundisinview.
Problem, there can be multiple portsvarsetc at same 2d location.
Solve that by each is a small ball with a target 2d location and is attracted to there but wont overlap other such balls
The _exists var per groundcirc, maybe it should be useable also as a normaldimension by higher level groundcircs, so the dag. _exists of parent must be at most the _exists of each child. Hyperspherenet does that with sound, kind of.
The dag defines forest of dimensions but not positions and velocities in them.
Or if it does then thats a higher dag layer or separate layer. Maybe an avetime stddevtime and partial map of var to scalar, would be a useful node. Yes, do that. It will be how the network syncs softly not lockstep.

2023-9-14 https://twitter.com/benrayfield/status/1702316774505525621
Math question (need for game): Each var is at a 2d circle, and above that circles inside circles, and in that higher layer theres a scalar field of those dimensions its in, then can sparsely define variable-dimension scalar field of POSITION. How to optimize velocity sparsely?
Planned solution: The scalar vars of each ground-circle are not shared with other circles but have a weight between pairs of them across ground-circles to pull them toward the same scalar. Each ground-circle has an _exists var and a _isInView var. Multiverse of state space.
]]]
*/































//TODO
//Ben F Rayfield offers Dagball under opensource MIT license.
//Dagball aka Directed Acyclic Graph Ball, is a game of n dimensional heightmap,
//which balls roll on 2d crossSection of, and which crossSection varies by player (Humans andOr AIs) controls.
//The DAG part is equations of n dimensions to scalar, as heightmap.
//Those can be viewed as a javascript function of Float32Array to number, or in parallel using TinyGLSL, TODO.
//Its a sparse game world where each part in 2d is bell curve windowed,
//so what it adds to heightmap is multiplied by height of that bellcurve.
//Its also 2d affine transformed (aftrans), which I might do as centerX centerY and 2 2d vectors from there
//OR I might do it as centerX centerY normalVec2d OR centerX centerY angle, or something like that.
//The aftrans makes the DAGs more reusable.
//The DAGs (dag nodes) will be javascript objects but be optimizable as javascript eval andOr TinyGLSL in some cases.
//Each DAG can have 0 or more childs and is immutable.
//Roundoff is allowed.


const tinyGlsl = {
	/* TODO take some parts of this and merge into tinyGlsl.description. Remove the other parts to keep it tiny.
	https://twitter.com/benrayfield/status/1701290751877882096

	TinyGLSL is an opensource 25kB javascript file that brings teraflop speed (trillion+ adds multiplies per second) to
	the browser. tinyGlsl.testAfterBoot() or tinyGlsl.simple(code,aFloat32Array(upTo1024),height,width) -> floatsOut.
	1 GPU thread per float out https://github.com/benrayfield/jsutils/blob/master/src/tinyGlsl/TinyGLSL_2023-9-11-130pET.js
	1:44 PM · Sep 11, 2023
	·
	34
	Views
	View post analytics
	2
	Quotes

	Lambda Rick /acc
	@benrayfield
	·
	1h
	id is GPU thread id, ranges 0 to ids-1 (flattens 2d to 1d). idy ranges 0 to idh-1 (height). idx ranges 0 to idw-1 (width).
	par[0] is first float param. par[theFloatArray.length-1] is last float param. Set ret = anything you want; to return that
	float from that GPU thread.
	Lambda Rick /acc
	@benrayfield
	·
	1h
	Here's an instant demo in browser of 3d mandelbulb fractal using an older version of TinyGLSL. I'm planning to use
	TinyGLSL for making high dimensional browser games and AGI in peer to peer networks.
	https://memecombinator.io/experiments/ForestCurveFit012.html
	Lambda Rick /acc
	@benrayfield
	·
	1h
	TinyGLSL in browser is about as fast as native OpenCL. Eat my dust TensorflowJS.
	Lambda Rick /acc
	@benrayfield
	·
	57m
	let tenThousandFloatsOut = tinyGlsl.simple('ret = float(id)*float(id);', Float32Array.of(0), 1000, 10);
	*/
	description: 'TinyGLSL forked 2023-9-10-8pET from ForestCurveFit (and might modify it?). TinyGLSL (by Ben F Rayfield Y2023, opensource MIT license) is a javascript library that runs GPU code in browser using webgl2 glsl code, but only at most about 1000 floats in for efficiency (IO is the bottleneck of GPUs, so this can be alot faster than matmul in theory), 1 kernel at a time, many times in parallel, with each GPU thread returning 1 float. Use tinyGlsl.simple function to do that. On a good gaming computer it should, as of Y2023, do about 1 teraflop. You might use it to compute 3d fractals with 1 GPU thread per pixel, or ForestCurveFit kind of neuralnet (thats my first usecase), etc. If your use cases need more inputs or multiple kernels used together, you should either make multiple calls in sequence, each time getting a Float32Array back to CPU, or more efficiently, use glsl directly instead of this software. I might add those more complex abilities later.',
	
	todos: [
		'dagballScalarPortsAndDagForest see the big comment near top of the html file 2023-9-14.',
		'plan for how to have AI do airhockey and the moving heightmap game using ForestCurveFit software. rubberbandlike paths vs qlearning etc?',
		'options.useGPUIn_predict_ifNumOutsIs1 and make sure GPU works by computing TriTriRect.predict with it, so graphics and curve fitting work by GPU',
		'optionsuseGPUIn_lossGradient, optimize it by GPU',
		'fix all webgl2/glsl memory leaks such as by gl.deleteTexture etc, or put them in tinyGlsl.caches to reuse them. but dont keep allocating more each call',
		'Test max loop size, like in GPU.js i think it defaults to max loop size of 1000. is that inherited from GLSL?',
		'Use this software to GPU optimize ForestCurveFit',
		'Clean up unnecessary code, comments, etc in this software',
		'Check this 1024 limit on multiple computers. it likely varies across different computers andOr implementations of webgl2. if(floatsPar.length > 1024)',
		"put error checking back in after fix it: TODO if(correctOut != observedOut) throw 'i='+i+' correctOut='+correctOut+' observedOut='+observedOut;",
		'Its like curling. It would be cool if it moved forward. --@Ken67547214. @benrayfield In-game editor will let players live build and share custom shaped curling game areas or airhockey in chosen parts of endless shared 2d world, custom size/shape of pucks and the end of the sticks but not the poles. Since its 2d cross-section of many dimensions u only get the ends. Might be a problem with the friction being "velocity decay" instead of "subtract from velocity", but might could add both kinds to dimensions in general. Will put that in dagball.todos list but not sure if can do normal friction. Manifold would contain all possible curling games. Actually, the friction limits are only relevant to the balls. If I define the puck and stick-ends as part of the curve itself, I can make them move by any smooth equation I want. -- https://twitter.com/Ken67547214/status/1702442156843995187',
		'Ill probably make a 3d view of the hills and valleys / heightmap, but for now bright is hill and dark is valley.',
	],

	dones: [
		'fix the id var which duplicates and skips numbers if you count it from 0 to 19 (ids==20). Im trying gl_VertexID for that instead of getting it from coord.x.',
		'Use this software to GPU optimize 3d mandelbrot fractal andOr raytracing of n mirror balls',
		'Cache the compiled glsl program (createProgram) etc',
		'Test speed with double loop triple loop etc - See mandelbulb fractal, runs about 1 teraflop as a ballpark estimate',
	],

	//TODO param optionalBlobs is undefined or something like {AB: aFloat32Array, BC: aFloat32Array},
	//and also allow uniform/const int and float params in there such as sizeA sizeB sizeC, for matmul.
	simple:
		//(function(code, par, outs){
			//let outsLen = typeof(outs)=='number' ? outs : outs.length;
		(function(beforeCode, code, par, height, width){
			if(!height || !width) throw 'height='+height+' width='+width;
			//let outsLen = typeof(outs)=='number' ? outs : outs.length;
			let outsLen = height*width;
			//Code string uses these vars:
			//par - read-only float array, the param. You only get 1 input, and its this array, so put all the params here.
			//pars - size of par array.
			//ret - return this float. starts as 0, in case you dont set it.
			//id - GPU thread id, range 0 to ids-1
			//ids - number of GPU threads. Each returns 1 float.
			//also idy idx idh idw which define the pixel rectangle, since glsl has to do rectangle. use id and ids if you want it flattened.
			//Code can use vec2 vec3 vec4 if for float int etc, whatever you can do in webgl glsl2 #version 300 es.
			//To efficiently use GPU, use at least as big of outs.length as you have GPU cores.
			//Can be more, and they will take turns, but less and some go unused. Normally this is a few hundred to a few thousand.
			//
			//Params:
			//par = the input floats. Float32Array, up to size 1024 or might have to be a little smaller.
			//outs = size of output floats, or give a Float32Array of that size to reuse.
			/*TODO? let height;
			let width;
			if(outsLen > 8192){
				height = width = Math.ceil(Math.sqrt(outsLen)); //equal or slightly more than outsLen, but GLSL has to do rectangle.
				if(outsLen != height*width){
					throw 'TODO allow any size up to a few million, regardless of if its a multiply of 2 integers, by dropping the few extra (maybe a Float32Array backed view of the first outsLen flaots?). outsLen='+outsLen+' height='+height+' width='+width;
				}
			}else{
				height = 1;
				width = outsLen;
			}*/
			let code2 =
				`${tinyGlsl.glslVersionString}
				${beforeCode}
				precision highp float;
				uniform vec2 mouse;
				uniform float par[${par.length}];
				in vec2 coord;
				//flat in int id;
				out vec4 fragColor;
				void main(){
					const int pars = ${par.length}; //number of params in the par array
					const int idh = ${height}; //height in pixels
					const int idw = ${width}; //width in pixels
					int idy = int(coord.y*float(idh)); //y position from 0 to idh-1
					int idx = int(coord.x*float(idw)); //x position from 0 to idw-1
					int id = idy*idw+idx; //2d pixel index in 1 int
					const int ids = idh*idw; //height*width
					float ret = 0.;
					float circY = 0.; //each dagball.Circ.y
					float circX = 0.; //each dagball.Circ.x
					float circR = 0.; //each dagball.Circ.r
					float circInfluence = 0.; //each dagball.Circ.influence
					float circWindow = 0.; //0 to 1. using the circle as a windowing function
					float potenCirc = 0.; //circs GPU code sets this. gets added into potenOne automatically. then in outer loop over balls, potenOne gets added into potenSum.
					//start user code
					${code}
					//end user code
					fragColor = vec4(ret, 0., 0., 1.);
				}`;

			let lines = code2.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
			let code3 = '';
			let lineNum = 1;
			for(let line of lines){
				if(line.startsWith('#version')){ //dont comment on the first line
					code3 += line+'\n';
				}else{
					code3 += line+' //'+(lineNum)+'\n';
				}
				lineNum++;
			}
			//reuse the Float32Array(height*width) if same size as last time
			//TODO remove existing float array of different size from cache.
			let arrCacheKey = 'floatsH'+height+'W'+width;
			let outs = tinyGlsl.caches[arrCacheKey];
			if(!outs){
				outs = tinyGlsl.caches[arrCacheKey] = new Float32Array(height*width);
			}
			return tinyGlsl.internalGLSL_disorganizedTODO(code3, par, outs, height, width);
		}),
		
	webglType: 'webgl2', //If you change this from 'webgl2' to 'webgl', some features wont be there and it will break.
	
	glslVersionString: '#version 300 es',
		
	caches: {},

	//returns the last value returned by lazyVal() or reuses it if exists for same key.
	cache: function(key, lazyVal){
		if(key === undefined) throw 'key is undefined';
		if(lazyVal === undefined) throw 'lazyVal is undefined';
		let val = tinyGlsl.caches[key];
		if(val === undefined){
			val = tinyGlsl.caches[key] = lazyVal();
		}
		return val;
	},
	
	internalGLSL_disorganizedTODO:
		(function(glslCode, floatsPar, floatsOutOrOutputSize, canvasHeight, canvasWidth){
			if(canvasHeight < 1 || canvasHeight > 8192) throw 'canvasHeight='+canvasHeight;
			if(canvasWidth < 1 || canvasWidth > 8192) throw 'canvasWidth='+canvasWidth;
			//console.log('internalGLSL_disorganizedTODO code=\n'+glslCode);
			//reads glslCode. reads floatsPar. writes floatsOutOrOutputSize or reads floatsOutOrOutputSize as a number to make new Float32Array to return.
			//runs floatsOut number of GPU threads that return 1 float each.
			//FIXME? floatsPar.length <= 1024 or the limit might be a little less than that or may vary across computers.
			//FIXME remove the coord and mouse arrays, and rename other vars, since im going to use this tool for a variety of things.
			if(floatsPar.length > 1024){
				throw 'floatsPar.length is too big: '+floatsPar.length;
			}
			let floatsOut = typeof(floatsOutOrOutputSize)=='number' ? (new Float32Array(floatsOutOrOutputSize)) : floatsOutOrOutputSize;
			//FIXME also include tinyGlsl.glslVersionString?
			let cacheKeySuffix = '_cacheKeySuffix_glType'+tinyGlsl.webglType+'_H'+canvasHeight+'_W'+canvasWidth+'_floatsOutLen'+floatsOut.length+'_glslCode['+glslCode+']';

			//let canvasHeight = 512;
			//let canvasWidth = 512;
			//let canvasHeight = 1;
			//let canvasWidth = 801;
			//let canvasWidth = floatsOut.length;

			//const canvas = document.getElementById("canvas");
			
			/*
			//let caches = tinyGlsl.caches || (window.caches = {});
			let cacheKey = 'glslCanvasH'+canvasHeight+'W'+canvasWidth;
			let canvas = tinyGlsl.caches[cacheKey];
			if(!canvas){
				canvas = tinyGlsl.caches[cacheKey] = document.createElement("canvas");
				canvas.setAttribute("height", ''+canvasHeight);
				canvas.setAttribute("width", ''+canvasWidth);
				tinyGlsl.caches.gl = canvas.getContext(tinyGlsl.webglType);
			}
			let gl = tinyGlsl.caches.gl;
			if(!gl) throw 'No gl';
			*/
			let canvas = tinyGlsl.cache('glslCanvas'+cacheKeySuffix, function(){
			//let canvas = tinyGlsl.cache('glslCanvas', function(){
				//FIXME should canvas be deduped just by its size, or should it include cacheKeySuffix?
				let c = document.createElement("canvas");
				c.setAttribute("height", ''+canvasHeight);
				c.setAttribute("width", ''+canvasWidth);
				return c;
			});
			let gl = tinyGlsl.cache('gl'+cacheKeySuffix, function(){
				let gl = canvas.getContext(tinyGlsl.webglType);
				if (!gl.getExtension('EXT_color_buffer_float')){
					throw 'EXT_color_buffer_float not supported so cant store just 1 float per pixel';
				}
				return gl;
			});

			let vertexCode_value = `${tinyGlsl.glslVersionString}
			in vec4 position;
			out vec2 coord;
			//flat out int id;
			void main() {
				coord = position.xy * 0.5 + 0.5;
				//id = gl_VertexID;
				gl_Position = position;
			}
			`;

			//let program;

			/*
			const positionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW); //2 triangles covering canvas rectangle
			*/
			let positionBuffer = tinyGlsl.cache('positionBufferOfSquareOf2Triangles'+cacheKeySuffix, function(){
				const p = gl.createBuffer();
				//FIXME if gl is replaced in cache, positionBuffer must also be. likely similar for other things in cache.
				gl.bindBuffer(gl.ARRAY_BUFFER, p);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW); //2 triangles covering canvas rectangle
				return p;
			});

			/*let mouseX = 0;
			let mouseY = 0;
			canvas.addEventListener("mousemove", (event) => {
				mouseX = event.offsetX;
				mouseY = event.offsetY;
			});*/


			//use these instead of canvas[[[
			//tested in tinyGlsl.cache: if (!gl.getExtension('EXT_color_buffer_float')){
			//	throw 'EXT_color_buffer_float not supported so cant store just 1 float per pixel';
			//}

			
			/*
			//Create and configure the texture
			const texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, canvasWidth, canvasHeight, 0, gl.RED, gl.FLOAT, null);
			*/
			let texture = tinyGlsl.cache('texture_onefloatchannel'+cacheKeySuffix, function(){
				let t = gl.createTexture();
				//FIXME if gl is replaced in cache, texture must also be. likely similar for other things in cache.
				gl.bindTexture(gl.TEXTURE_2D, t);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, canvasWidth, canvasHeight, 0, gl.RED, gl.FLOAT, null);
				return t;
			});

			/*
			//Create and configure the framebuffer
			const framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			*/
			let framebuffer = tinyGlsl.cache('framebuffer'+cacheKeySuffix, function(){
				const f = gl.createFramebuffer();
				//FIXME if gl is replaced in cache, framebuffer must also be. likely similar for other things in cache.
				gl.bindFramebuffer(gl.FRAMEBUFFER, f);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
				return f;
			});
			//]]]

			
			
			/*//use these instead of canvas[[[
			const framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

			const renderbuffer = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, 512, 512);  // Change the format and dimensions as needed

			// Attach the renderbuffer to the framebuffer
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, renderbuffer);

			// Check if framebuffer is complete
			if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE){
				console.error('Framebuffer is not complete');
			}
			//]]]
			*/


			/*
			let createProgram = function(vertexShaderSource, fragmentShaderSource){
				let programCacheKey = 'programCacheKey['+vertexShaderSource+']['+fragmentShaderSource+']';
				if(tinyGlsl.caches[programCacheKey]) return tinyGlsl.caches[programCacheKey];


				const vertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(vertexShader, vertexShaderSource);
				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(vertexShader));
				}

				const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(fragmentShader, fragmentShaderSource);
				gl.compileShader(fragmentShader);
				if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(fragmentShader));
				}

				const program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					throw new Error(gl.getProgramInfoLog(program));
				}

				tinyGlsl.caches[programCacheKey] = program;
				return program;
			};*/

			let vertexShaderSource = vertexCode_value;
			let fragmentShaderSource = glslCode;
			let program = tinyGlsl.cache('programCacheKey_vertexShader['+vertexShaderSource+']'+cacheKeySuffix, function(){

				//FIXME does this put extra stuff in gl if theres multiple fragmentShaderSource but reuses same vertexShaderSource?

				/*
				const vertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(vertexShader, vertexShaderSource);
				gl.compileShader(vertexShader);
				if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(vertexShader));
				}*/
				//cacheKeySuffix already contains the fragmentShader, but not the vertexShader since thats always the same 2023-9-10.
				let vertexShader = tinyGlsl.cache('vertexShader['+vertexShaderSource+']'+cacheKeySuffix, function(){
					let v = gl.createShader(gl.VERTEX_SHADER);
					gl.shaderSource(v, vertexShaderSource);
					gl.compileShader(v);
					if(!gl.getShaderParameter(v, gl.COMPILE_STATUS)){
						throw new Error(gl.getShaderInfoLog(v)+'\n\nVERTEXSHADERCODE:\n'+vertexShaderSource);
					}
					return v;
				});
				
				/*
				const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(fragmentShader, fragmentShaderSource);
				gl.compileShader(fragmentShader);
				if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(fragmentShader));
				}*/
				//cacheKeySuffix already contains the fragmentShader, but not the vertexShader since thats always the same 2023-9-10.
				let fragmentShader = tinyGlsl.cache('fragmentShader'+cacheKeySuffix, function(){
					const f = gl.createShader(gl.FRAGMENT_SHADER);
					gl.shaderSource(f, fragmentShaderSource);
					gl.compileShader(f);
					if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)){
						throw new Error(gl.getShaderInfoLog(f)+'\n\nFRAGMENTSHADERCODE:\n'+fragmentShaderSource);
					}
					return f;
				});

				const p = gl.createProgram();
				gl.attachShader(p, vertexShader);
				gl.attachShader(p, fragmentShader);
				gl.linkProgram(p);
				if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
					throw new Error(gl.getProgramInfoLog(p));
				}
				return p;
			});

			let par = floatsPar;

			//let outarr = new Float32Array(512*512); //FIXME should be a param
			let outarr = floatsOut;

			/*
			// start with mandelbrot
			//try {
				program = createProgram(vertexCode_value, glslCode);
				//errorTextarea.value = "OK";

				/*
				// Get the uniform location for par after the program is created
				const parLocation = gl.getUniformLocation(program, "par");

				// Set the par uniform
				gl.uniform1fv(parLocation, par);
				*
			//} catch (error) {
			//	errorTextarea.value = error.message;
			//}
			*/

			// compile and link shader on textarea change
			//vertexCode.addEventListener("input", updateShader);
			//glslCode.addEventListener("input", updateShader);

			/*
			function updateShader() {
				try{
					const newProgram = createProgram(vertexCode.value, glslCode.value);
					program = newProgram;
					errorTextarea.value = "OK";
				}catch(error){
					errorTextarea.value = error.message;
				}
			}*/

			//a Texture and RenderBuffer are similar. Texture can be input and output for multiple steps in glsl.
			//RenderBuffer is output only, back to CPU or screen.
			//A FrameBuffer contains things that contain image data
			//but does not directly contain image data. Its more for control-flow.
			//If you dont specify a FrameBuffer, the default one will be to a canvas.

			// render loop
			let render = function(){

				//Bind the offscreen framebuffer. instead of canvas.
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

				gl.clearColor(0, 0, 0, 0);
				gl.clear(gl.COLOR_BUFFER_BIT);

				if (program) {
					gl.useProgram(program);

					// set uniforms
					const mouseLocation = gl.getUniformLocation(program, "mouse");
					//gl.uniform2f(mouseLocation, mouseX, mouseY);
					gl.uniform2f(mouseLocation, .67844, .2343234); //FIXME remove mouse since tinyGlsl is not specific to graphics or UI

					// draw rectangle
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					const positionLocation = gl.getAttribLocation(program, "position");
					gl.enableVertexAttribArray(positionLocation);
					gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

					const parLocation = gl.getUniformLocation(program, "par");
					gl.uniform1fv(parLocation, par);

					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

					//copy from GPU (texture or renderbuffer) to CPU (outarr)
					gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RED, gl.FLOAT, outarr);
					//console.log('outarr[2345]='+outarr[2345]);
				}

				//requestAnimationFrame(render);
			};
			
			render();
			if(outarr != floatsOut) throw 'Diff out arrays';
			return outarr;
		}),
		
	testAfterBoot:
		(function(){
			//tests work 2023-9-10.

			/*
			// Create the par array and update the uniform
			let floatsPar = new Float32Array(1000); //at most 1024, or something like that. might be less cuz of other vars in kernels.
			for (let i=0; i<floatsPar.length; i++){
				floatsPar[i] = i;
			}

			let glslCode =
				`${tinyGlsl.glslVersionString}
				precision highp float;
				uniform vec2 mouse;
				uniform float par[${floatsPar.length}];
				//in vec4 position;
				//flat in int id;
				in vec2 coord;
				out vec4 fragColor;

				void main() {
					//TODO gl_VertexID
					//vec2 coord = position.xy * 0.5 + 0.5; //FIXME?
					//gl_Position = position; //FIXME?

					float frompar = par[4]; // Get the corresponding value from par
					float diag[10];
					diag[0] = 1.3;
					for(int d=1; d<10; d++){
						diag[d] = float(d);
					}
					//diag[1] = 1.;
					for(int d=1; d<10; d++){
						diag[d] = diag[d-1]*diag[d-1]+.7*par[d];
					}

					vec2 c = vec2(coord.x, coord.y);
					vec2 z = vec2(0.0, 0.0);
					float i = -mouse.x * 0.71 + 1.0 * coord.x + 0.1 * mouse.y;

					for (int j = 0; j < 1000; j++) {
						vec2 v = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
						if (length(v) > 2.0)
							break;
						z = v;
					}

					fragColor = vec4(z.x / (4.0 + diag[2] + -1.9*frompar)+mouse.x,
						mouse.x * 0.001, 0.0 + mouse.y * mouse.y * 0.000001, 1.0);
				}`;
			
			//let floatsOut = new Float32Array(801); //TODO what size?

			let floatsOut = tinyGlsl.internalGLSL_disorganizedTODO(glslCode, floatsPar, new Float32Array(801), 1, 801);
			console.log('floatsOut[222]='+floatsOut[222]);
			
			
			let parB = Float32Array.of(100,2);
			let outsBSize = 10;
			let testBOuts = tinyGlsl.internalGLSL_disorganizedTODO(
				`${tinyGlsl.glslVersionString}
				precision highp float;
				uniform vec2 mouse;
				uniform float par[${parB.length}];
				in vec2 coord;
				out vec4 fragColor;

				void main(){
					int id = int(coord.x*${outsBSize+'.'});
					float ret = par[0]+pow(par[1],float(id));
					fragColor = vec4(ret, 0., 0., 1.);
				}`,
				parB,
				outsBSize
			);
			for(let i=0; i<10; i++){
				let correctOut = 100+2**i;
				let observedOut = testBOuts[i];
				console.log('i='+i+' correctOut='+correctOut+' observedOut='+observedOut+' diff='+Math.abs(correctOut-observedOut));
				if(correctOut != observedOut){
					throw 'i='+i+' correctOut='+correctOut+' observedOut='+observedOut;
				}
			}
			console.log('GLSL test pass: internalGLSL_disorganizedTODO');
			*/

			//FIXME move the tenThousandFloatsOut test to end cuz its bigger output array so tests tinyGlsl.caches.

			let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), 1000, 10);
			//let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), 8000, 1);
			//let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id);', Float32Array.of(0), 1, 8000);
			let correct5678 = 5678*5678;
			let observed5678 = tenThousandFloatsOut[5678];
			if(correct5678 != observed5678){
				throw 'correct5678='+correct5678+' observed5678='+observed5678;
			}
			console.log('tenThousandFloatsOut test pass');
			
			let outsId = tinyGlsl.simple('', 'ret = float(id);', Float32Array.of(0,10,20,30,40,50), 1, 20);
			//let outsId = tinyGlsl.simple('', 'ret = float(theId);', Float32Array.of(0,10,20,30,40,50), 20);
			for(let i=0; i<outsId.length; i++){
				let correctOut = i;
				let observedOut = outsId[i];
				console.log('outsId['+i+']='+outsId[i]);
				if(correctOut != observedOut) throw 'i='+i+' correctOut='+correctOut+' observedOut='+observedOut;
			}

			let outsC = tinyGlsl.simple('', 'ret = par[2]+par[3]+float(id)*.001;', Float32Array.of(0,10,20,30,40,50), 1, 100);
			//let outsC = tinyGlsl.simple('', 'ret = par[2]+par[3]+.001;', Float32Array.of(0,10,20,30,40,50), 100);
			for(let i=0; i<outsC.length; i++){
				let observedOut = outsC[i];
				let approxCorrectOut = 20+30+i*.001;
				console.log('outsC['+i+']='+observedOut);
				let diff = Math.abs(observedOut-approxCorrectOut);
				if(diff > .001) throw 'i='+i+' approxCorrectOut='+approxCorrectOut+' observedOut='+observedOut;
			}
			console.log('tinyGlsl.simple test A pass');
			
			let hundredFloats = new Float32Array(100);
			for(let i=0; i<hundredFloats.length; i++){
				hundredFloats[i] = Math.random();
			}
			//TODO time it using the performance object, make tinyGlsl.time function, copy it from my other code.
			let hundredOuts = tinyGlsl.simple(
				'',
				`float sum = 0.;
				float idf = float(id);
				for(int i=0; i<pars; i++){
					for(int j=0; j<pars; j++){
						sum += (par[i]+idf)*(par[j]-idf);
					}
				}
				ret = sum;`,
				hundredFloats,
				1,
				hundredFloats.length
			);
			let id = 71;
			let sum = 0;
			for(let i=0; i<hundredFloats.length; i++){
				for(let j=0; j<hundredFloats.length; j++){
					sum += (hundredFloats[i]+id)*(hundredFloats[j]-id);
				}
			}
			let approxCorrectOut = sum;
			let observedOut = hundredOuts[id];
			let ratio = observedOut/approxCorrectOut;
			let s = 'id='+id+' approxCorrectOut='+approxCorrectOut+' observedOut='+observedOut+' ratio='+ratio;
			console.log(s);
			if(Math.max(ratio,1/ratio) > 1.00001) throw s;
			console.log('tinyGlsl.simple test B pass');

			let tenThousandFloatsOutB = tinyGlsl.simple('', 'ret = float(id)*float(id)+0.;', Float32Array.of(0), 1000, 10);
			//let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), 8000, 1);
			//let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id);', Float32Array.of(0), 1, 8000);
			let correct5678B = 5678*5678;
			let observed5678B = tenThousandFloatsOutB[5678];
			if(correct5678B != observed5678B){
				throw 'correct5678B='+correct5678+' observed5678B='+observed5678;
			}
			let correct8989B = 8989*8989;
			let observed8989B = tenThousandFloatsOutB[8989];
			let diff = Math.abs(correct8989B-observed8989B);
			if(diff > 10){ //cuz theres 24 digit bits in float, and 8989*8989 exceeds that. 5678*5678 does too but the answer is a multiple of 4 so its ok.
				throw 'correct8989B='+correct8989B+' observed5678B='+observed8989B;
			}
			console.log('tenThousandFloatsOutB test pass');
			
			/*
			//let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), 1000, 10);
			let tenThousandFloatsOut = tinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), 8000, 1);
			let correct5678 = 5678*5678;
			let observed5678 = tenThousandFloatsOut[5678];
			if(correct5678 != observed5678){
				throw 'correct5678='+correct5678+' observed5678='+observed5678;
			}
			console.log('tenThousandFloatsOut test pass');
			*/
			
		}),
};








//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js
var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};

const syncTypes = {
	const: {description: 'const or hash, so no updates. The syncType of a node does not mean the syncType of its childs, so even if childs are not constant/const, any of their parent(s) can be const'},
	pubkey: {description: 'pubkey, so can update its 1 var val with a timestamp and new val as many times as it wants. The pubkey might also have a const type like to limit size of future vals'},
	swarm: {description: 'swarm, so its just a named object whose val (including weighted child ptrs maybe) is gradually agreed or or forked by the many computers and players. Namespaces are useful here in case of forking. The voting on priorities of hopfield constraint solver and median voting on num val etc, acts on swarm vars.'},
	unknown: {description: 'FIXME nothing should have an unknown syncType but since Im still designing this software I havent figured all that out yet.'},
};


//dag object types. also pubkeys arent exactly dag the way they're displayed as creating cycles within the dag but since the dag only points
//at the pubkey and doesnt cross pass there to the thing it signs (that creates the cycles) its dag enough.
//All ids are strings that are valid javascript var names and are simultaneously valid glsl var names.
const Dag = {
	//double is part of the dag but is used directly without being wrapped.
	//FIXME do you ever need the id of a double? could use a func for that instead. Adding dag.idOfDouble func for that.

	/*FIXME should childs be ids or the dag objects whose ids are those?

	TODO should every id start with abbrev of its syncType so .syncType can be set differently depending on it: s for swarm. c for const. p for pubkey.
	Id like to, but "TODO doublearrusedasuint53forrplacelikevec1voting" is 2 hops deep in that?

	TODO something should be using the swarm syncType, and that will be used in gpucircs and leafvars, but those might be
	specific to dagball so shouldnt go in this dag/dags {}/map???

	TODO every one of these objects must have a global id. If syncType.const, its either a hash id or if the constant data is small then that data literally.
	If its a pubkey, the id might be like pubkey_ed25519_2345345345345hex23432452...234234.
	If its a swarm, the id is just made up after a prefix, maybe swarm_x.
	But im not sure the syncType (const pubkey or swarm etc) should be in the id. The type such as dags.Pubkey should be there like pubkey_...
	and pubkey implies syncType of pubkey.

	This dags object/{} is supposed to be not dagball specific. Things that are dagball specific can go in the dagball object/{} or other places.
		In dagball, a leaf var should be a swarm dags.Swarmnum with a const dags.Point,
		and a Gpucirc should be a const dags.Circ with various other fields. BUT I might want to move them around
		using a potential energy func of where to put things on screen and edit the gpu code in selected gpucirc
		using the textarea on left. so it seems I want to vary their syncType between swarm vs const,
		but a problem with that is the id has to choose in advance. I could copy the swarm form of gpucirc to const form,
		having a new id. incoming pointers (such as by player voting) would not automatically transfer, and that is by design
		since a vote is on a specific id, and an id starts with the syncType (s for swarm. c for const. p for pubkey).
		TODO id starts with the syncType (s for swarm. c for const. p for pubkey).
		Make this happen, and find a way to do it without making Gpucirc and Leafvar types. They should be somehow derived
		from whats in dags, and just instances of them used in dagball. I want dags to be general enough new kinds of games
		can be made from it, which is why Im including a node type for wrapping wikibinator203 for future research.
	*/

	Null: function(){
		this.id = 'null_';
		this.syncType = 'const';
	},
	//NullSig: function(){
	//	this.val = dagStuff.null;
	//},
	True: function(){
		this.id = 'true_';
		this.syncType = 'const';
	},
	False: function(){
		this.id = 'false_';
		this.syncType = 'const';
	},
	Str: function(s){ //useAsImmutable
		this.s = s; //the wrapped string
	},
	Pubkey: function(id){ //A variable whose value can be replaced by any object with a timestamp, and a sig must come with that. The timestamp must also be signed with it.
		this.id = id; //The ed25519 publicKey should be in the id, probably after some prefix that says its an ed25519. If you wanted an ed448 or other publickeytype
		this.syncType = 'pubkey';
		//TODO? this.pubkeyType = 'ed25519';
		//this.valSig = dagStuff.null; //a Dag.Sig. FIXME but dags.Null doesnt have a timestamp and probably wasnt signed by this pubkey.
		this.valSig = null; //a Dag.Sig. FIXME but dags.Null doesnt have a timestamp and probably wasnt signed by this pubkey.
		throw 'TODO';
	},
	Sig: function(){
		this.id = id;
		this.syncType = 'const';
		this.val = dagStuff.null;
	},
	Swarmvar: function(id){ //A variable whose value is jaggedly agreed on or not, hopefully converging, by many computers andOr pubkeys andOr Human players. Its val is an id, FIXME object whose id is that? or the id?
		this.id = id;
		this.syncType = 'swarm';
		this.val = dagStuff.null;
	},
	Swarmnum: function(id){ //like Swarmvar but there are number vars instead: pos, vel, and maybe velDecay. Agreed on or forked/notagreed by many computers andOr pubkeys andor human players. especially by the player voting system (see dagball.Player Maps for example).
		this.id = id;
		this.syncType = 'swarm';
		this.pos = 0;
		this.vel = 0;
		this.velDecay = 0;
		//FIXME should this also be at a dags.Point? or is that too dagball-specific to be in this dags object instead?
	},
	Rect: function(){  //useAsImmutable 2d rectangle in game world
		this.syncType = 'const';
		throw 'TODO';
	},
	Circ: function(){ //useAsImmutable 2d circle in game world
		this.syncType = 'const';
		throw 'TODO';
	},
	Point: function(){ //useAsImmutable 2d point in game world
		this.syncType = 'const';
		throw 'TODO';
	},
	Arr: function(){ //useAsImmutable array of primitives, such as Float32Array, Float64Array, Int32Array, etc. TODO where does the mutable one go?
		this.syncType = 'unknown'; //FIXME could this allow both const and swarm? Does that apply to the Arr itself or to the primitives in it which are like its childs?
		throw 'TODO';
	},
	List: function(){ //useAsImmutable list of ids.
		this.syncType = 'const';
		throw 'TODO';
	},
	Mapvec: function(){ //useAsImmutable map of id to double. FIXME there should be an option, or maybe 2 types of this, one where it has to sum to
		this.syncType = 'const';
		throw 'TODO';
	},
	Map: function(){ //useAsImmutable map of id to id. "map of id to id. Like a class instance whose fields are the map keys."
		this.syncType = 'const';
		throw 'TODO';
	},
	Fn: function(fn, optionalFnType){ //useAsImmutable. Wraps a wikibinator203 lambda, which is a different kind of dag where each node can be called on a node to find or create a node.
		this.syncType = 'const';
		//TODO theres a .isWikibinator203Lambda field, or named something like that,
		//either in fn.isWikibinator203Lambda or fn.n.isWikibinator203Lambda, find it from that?
		this.fnType = optionalFnType || 'wikibinator203';
		this.fn = fn;
	},
	//TODO doublearrusedasuint53forrplacelikevec1voting
	
	

};

//returns a Dag.Sig, or throws if thats the wrong password. Do
Dag.Pubkey.prototype.sign = function(password, val){
	throw 'TODO';
};

//signs it and it becomes the new val.
Dag.Pubkey.prototype.setVal = function(password, val){
	this.val = this.sign(password,val);
};

Dag.Pubkey.prototype.val = function(){
	return this.valSig.val || dagStuff.null;
};

const DagStuff = {
	//passwordToEd25519Pubkey: function(password){
	passwordToPubkey: function(password){
		throw 'TODO hash the password and make an ed25519 pubkey, return a Dag.Pubkey';
	},
	idOfDouble: function(d){
		throw 'TODO';
	},
	null: new Dag.Null(),
	true: new Dag.True(),
	false: new Dag.False(),
};

const ExampleDags = {
	//TODO
};

//TODO build Gpucirc as a dags.Swarmvar but use its vartype (or what is it called?) to require its vals have certain fields (and types of those?)
//such as y x radius (or just include a dags.Circle?) and that all its childs be leaf vars (what are those? swarm vars of pos vel velDecay and have a dags.Point each? color?)


//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;

const dagball = {
	license: 'DagBall is offered under opensource MIT license (prototype by Ben F Rayfield 2023-9-12+)',
	todos: [
		'bridgees similar to a 4 way traffic intersection of horizontal and vertical but ball cant take right turn, and which of horizontal vs vertical it can go on depends on 1 or more other dimensions.',
		'circular wall rises around a ball and moves it around, as if grabbed by a circular hand and moved then released.',
		'screw, sine wave, or sum of sine waves, etc.',
		'constant curvy paths to roll down.',
		'mostly flat platform with walls and obstacles in middle, that you tilt in 2d with 2 other dims.',
		'elevator controlled by 1 dim.',
		'something like those scissorlike lines in screwballscramble game that ball rolls along.',
	],
	dones: [
		//TODO list what ive done already
	],
	//doPhysicsAndGraphicsFromGpuCodeInCircsElseTheExampleGpuCode: false, //should be true, but 2023-9-25 this isnt built yet.
	doPhysicsAndGraphicsFromGpuCodeInCircsElseTheExampleGpuCode: true, //set this to false if theres problems you need to figure out in the GPU code of multiple circs being combined, and you want to go back to 1 GPU code at a time.
	maxDistanceToSelect: .4, //if closer, it breaks ties by which is closest, but wont select any farther away.
	messageToUser: 'TODO', //this will appear near mouse cursor or maybe at top in big text. Its for fast messages to user like when holding a button or dragging to explain options of what you can do next, or to say errors etc, todo.
	afterEveryDomEvent: function(event){

		if(!dagball.selectLock() && !dagball.isTextEditing()){ //FIXME merge selectLock with isTextEditing? They're tangled 2023-9-24.
			dagball.setSelectedCirc(dagball.uiCircNearYXElseNull(dagball.directControls.mouseY, dagball.directControls.mouseX));
		}

		//console.log('afterEveryDomEvent event='+event);
		console.log('afterEveryDomEvent event='+event+' isTextEditing='+dagball.isTextEditing()+' selectLockA='+dagball.selectLockA+' selectLockB='+dagball.selectLockB);
	},
	jsNumToGlslFloat: jsNum=>{
		let s = ''+jsNum;
		if(!s.includes('.')) s += '.';
		return s;
	},
	between: (min, val, max)=>Math.max(min, Math.min(val, max)),
	betweenInt: (min, val, max)=>Math.floor(Math.max(min, Math.min(val, max))),
	asByte: x=>Math.floor(dagball.between(0, x, 255)),
	colorStr: function(redFraction, greenFraction, blueFraction){
		let r = dagball.asByte(redFraction*256);
		let g = dagball.asByte(greenFraction*256);
		let b = dagball.asByte(blueFraction*256);
		let s = '000000'+(r*65536+g*256+b).toString(16);
		return '#'+s.substring(s.length-6);
	},
	//there are 2 modes: text editing, and canvas.
	isTextEditing: function(){
		return document.getElementById('mainEditTextarea') === document.activeElement;
	},
	setIsTextEditing: function(bit){
		let mainEditTextarea = document.getElementById('mainEditTextarea');
		if(bit) mainEditTextarea.focus();
		else mainEditTextarea.blur();
	},
	selectLockA: false, //TODO
	selectLockB: false, //TODO
	timeOffset_: performance.timing.navigationStart,
	time: ()=>((dagball.timeOffset_+performance.now())*.001), //UTC seconds with fraction. More precise than Date.now()*.001
	estimateFPS: 60, //changed by update_estimateFPS many times per second. target FPS is 60 at least cuz thats how fast most HDMI screens update and is fast enuf for games.
	estimateFPS_lastTime: undefined,
	update_estimateFPS: function(){
		if(dagball.estimateFPS_lastTime === undefined) dagball.estimateFPS_lastTime = dagball.time();
		let now = dagball.time();
		let dt = Math.max(0,Math.min(now-dagball.estimateFPS_lastTime,1));
		dagball.estimateFPS_lastTime = now;
		dagball.estimateFPS = dagball.estimateFPS*(1-dt) + 1; //TODO adjustable decay rate
	},
	updateGamepadsEtc: function(){
		let gamepads = navigator.getGamepads(); //may contain nulls, such as [null, null, null, null] or [aGamepad, null, null, null].
		for(let i=0; i<gamepads.length; i++){
			let gamepad = gamepads[i];
			if(gamepad){
				let s = gamepad.id;
				if(!s) s = 'gamepad';
				//s = s.trim().replaceAll(/\s|\(|\)/g,'_');
				s = s.trim().replaceAll(/\(|\)/g,'').replaceAll(/\s/g,'_');
				//let gamepadName = s+'_index'+i;
				let gamepadName = 'gamepad'+i;
				
				//let buttonOrAxisNum = 0;
				for(let a in gamepad.axes){
					//ret[gamepadName+'_'+(buttonOrAxisNum++)] = gamepad.axes[a];
					dagball.directControls[gamepadName+'_dim'+a] = gamepad.axes[a];
				}
				for(let b in gamepad.buttons){
					dagball.directControls[gamepadName+'_btn'+b] = gamepad.buttons[b].value; //GamepadButton {pressed: false, touched: false, value: 0}
				}
				let v = gamepad.vibrationActuator;
				if(v){
					if(v.type == 'dual-rumble'){
						//the only type chatgpt4 knows about as of 2023-9-23 is 'dual-rumble',
						//and 'A "dual-rumble" typically refers to two distinct motors inside the gamepad: one for "strong" vibrations and another for "weak" vibrations.'.'

						/*
						if i want to control the motors continuously, what duration should I use?
						ChatGPT
						If you want to control the motors continuously, you would typically use the playEffect method in a loop, starting a new vibration as soon as the previous one ends.

						However, to "emulate" continuous vibration, you can set a long duration and then interrupt it when you want the vibration to stop. For instance, you might set a very long duration (like several minutes), but this isn't exactly "infinite" and might not be the most elegant solution.

						Here's a conceptual approach:

						Emulate Continuous Vibration:
						Set a long duration when calling playEffect.

						javascript
						Copy code
						gamepad.vibrationActuator.playEffect("dual-rumble", {
							startDelay: 0,
							duration: 3600000,  // 1 hour, for instance
							strongMagnitude: 1.0,
							weakMagnitude: 0.5
						});
						Stop the Vibration:
						To interrupt the vibration before the duration ends, you can "play" another effect with a duration of 0.

						javascript
						Copy code
						gamepad.vibrationActuator.playEffect("dual-rumble", {
							startDelay: 0,
							duration: 0,
							strongMagnitude: 0,
							weakMagnitude: 0
						});
						*/
						let dimNameWeak = gamepadName+'_weakRumble';
						let dimNameStrong = gamepadName+'_strongRumble';
						if(dagball.directControlsOut[dimNameWeak] === undefined){
							dagball.directControlsOut[dimNameWeak] = 0; //tell other code it exists and can be set to other values (to physically shake the gamepad)
						}
						if(dagball.directControlsOut[dimNameStrong] === undefined){
							dagball.directControlsOut[dimNameStrong] = 0; //tell other code it exists and can be set to other values (to physically shake the gamepad)
						}
						//TODO simplify this code. shouldnt need both directControlsOut_rememberToStop and isGamepadRumbling
						let stopped = false;
						if(dagball.directControlsOut_rememberToStop[dimNameWeak] || dagball.directControlsOut_rememberToStop[dimNameStrong]){
							delete dagball.directControlsOut_rememberToStop[dimNameStrong];
							delete dagball.directControlsOut_rememberToStop[dimNameWeak];
							//TODO set isGamepadRumbling's to true?
							//TODO merge duplicate code
							gamepad.vibrationActuator.playEffect("dual-rumble", {startDelay: 0, duration: 0, strongMagnitude: 0, weakMagnitude: 0}); //stop it with duration 0, ChatGPT4 said.
							stopped = true;
						}
						if(((dagball.isGamepadRumbling[dimNameWeak]==true) || (dagball.isGamepadRumbling[dimNameStrong]==true)) && ((dagball.directControlsOut[dimNameWeak] == 0) && (dagball.directControlsOut[dimNameStrong] == 0))){
							dagball.isGamepadRumbling[dimNameWeak] = dagball.isGamepadRumbling[dimNameStrong] = false; //dont stop rumbling again until start
							//TODO merge duplicate code
							if(!stopped){
								gamepad.vibrationActuator.playEffect("dual-rumble", {startDelay: 0, duration: 0, strongMagnitude: 0, weakMagnitude: 0}); //stop it with duration 0, ChatGPT4 said.
							}
						}else if((dagball.directControlsOut[dimNameWeak] != 0) || (dagball.directControlsOut[dimNameStrong] != 0)){
							dagball.isGamepadRumbling[dimNameWeak] = dagball.isGamepadRumbling[dimNameStrong] = true; //remember to stop rumbling at most once if dagball.directControlsOut[dimNameWeak] etc becomes 0 later.
							let millis = Math.max(1,Math.round(dagball.maxGamepadRumbleSecondsInASingleCall*1000));
							dagball.directControlsOut_rememberToStop[dimNameWeak] = true;
							dagball.directControlsOut_rememberToStop[dimNameStrong] = true;
							gamepad.vibrationActuator.playEffect("dual-rumble",
								{startDelay: 0, duration: millis, strongMagnitude: Math.max(0,Math.min(dagball.directControlsOut[dimNameStrong],1)), weakMagnitude: Math.max(0,Math.min(dagball.directControlsOut[dimNameWeak],1))});
						}
					}
				}
				
			}
		}
	},

	//aftrans: new dagball.SimpleAftrans(300,300,1,1), //FIXME will be replaced wen FullScreenCanvas is created in a fraction of a second

	/*The GPU code in a circle only affects the (up to 1000 dimensional) curves in that circle, but u can make the circle as big as u want
	and ignore any areas (return 0 to add to total potentialEnergy) you dont want to change. But it reduces number of dimensions left where it overlaps
	--https://twitter.com/DagBallGame/status/1703465244264165669
	*/
	//bootCanvasHeight: 150,
	//bootCanvasWidth: 200,
	//bootCanvasHeight: 450,
	//bootCanvasWidth: 600,
	bootCanvasHeight: 600,
	bootCanvasWidth: 800,
	//bootCanvasHeight: 768,
	//bootCanvasWidth: 1024,
	defaultIconRadius: 5,
	canvasScaleY: 1, //modified at boot and when resize window. dont set it here. Used to find mouse position.
	canvasScaleX: 1, //modified at boot and when resize window. dont set it here. Used to find mouse position.
	//dual-rumble gamepads (with a strong and a weak rumble motor) have to be told a time to rumble.
	//This time will normally be cancelled as soon as you turn it off in directControlsOut. But maybe it matters to how fast the motor spins up or some electric efficiency. I dont know.
	//Its here to adjust what parameter goes into a {} param in gamepad.vibrationActuator.playEffect if you want to experiment with it. Its converted to integer number of milliseconds.
	maxGamepadRumbleSecondsInASingleCall: .1,
	//maxGamepadRumbleSecondsInASingleCall: .5,
	makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest: false,
	//If you turn this off at runtime, do it with turnOff_makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest or they will keep rumbling.
	//makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest: true, //TODO turn off
	//These are for if you want to test 1 motor or the other or if you dont want to wear out your gamepads rumble so turn down the strength during the test.
	turnOff_makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest: function(){
		dagball.makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest = false;
		for(let dimOut in dagball.directControlsOut){
			if(dagball.isGamepadRumbleDimName(dimOut)){
				dagball.directControlsOut[dimOut] = 0;
			}
		}
	},
	makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest_maxStrongRumbleStrength: 1, //there are in theory 2 motors, a strongRumble motor and a weakRumble motor in each dual-rumble gamepad
	makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest_maxWeakRumbleStrength: 1,
	isGamepadRumbleDimName: dimName=>dimName.toLowerCase().includes('rumble'), //TODO optimize by using includes 'umble' or by a regex? (dont want to allocate objects unnecessarily)
	isGamepadRumbling:{}, //This is only used to remember not to stop it from rumbling if its already stopped
	directControls:{ //Inputs, not the outputs even if some dimensions have both: buttons, joysticks, analog triggers, mouse dimensions, EEG hats and brain chip dimensions, etc.
		mouseY: 0,
		mouseX: 0,
	},
	//see comment of dagball.isSpaceDim. Cuz of float roundoff, you shouldnt put objects past this radius, and TODO make potentialEnergy get very high when nearing this.
	//Positions are float32s, not integers. Float32s have 24 digit bits and 1 sign bit and can exactly do all integers in range plus/minus 2**24, so 2**12 is half of those digit bits.
	//Radius 2**12 is big enough for millions of players at once if theres a few players on each screen, or could be hundreds of players on same screen in some areas.
	gameRadius: 2**12,
	directControlsOut:{ //Outputs, not the inputs, even if some dimensions have both: gamepad rumble dimensions, brain chip dimensions writing to brain, or whatever outputs (to computer) you hook in, etc.
		//put gamepad rumble dimensions, etc here. Only those verified to exist. If its mapped to 0 (or any number in range -1 to 1) that means it exists. Often starts as 0 when found. TODO.
	},
	directControlsOut_rememberToStop:{}, //for stopping gamepad rumble dimensions, but dont want to stop them if didnt start. value is true, or removed from this map (no false).
	//space dims range plus/minus infinity (or more practically maybe plus/minus 2**12 (see gameRadius) cuz of float32 roundoff?). non-space dims range -1 to 1.
	isSpaceControlsDim: dimName=>dimName.toLowerCase().includes('mouse'),
	selectLock: function(){ //while dagball.controls('moveCircle') etc, this should return true. Otherwise when moving a circle it selects the nearest circle and starts moving that one when you move a circle across it.
		//TODO will likely be more later
		return dagball.controls('moveCircle') || dagball.controls('resizeCircle') || dagball.controls('red') || dagball.controls('green') || dagball.controls('blue') || dagball.controls('bright') ||
			dagball.controls('editCircleText') || //editCircleText button being held prevents selecting while mouse is moving from canvas to textarea across other circs, then when release the button focuses on textarea.
			dagball.selectLockA; //2023-9-27 this allows the left mouse button to hold the selected circle as selected, and unhold it, usually for editing its text in the textarea on left.
	},
	actionControls:{
		//If you want to hold mouse in left hand and keyboard on right, you should change these controls. Or if you just dont like the controls.
		//FIXME all controls are supposed to range -1 to 1, but mouseX seems to range -4 to 4, probably somethinga bout the affine transform magnify being set to 100 and canvas being 800 pixels wide and magnified.
		//But since mouse needs to be in dagball.aftrans coordinates, like the balls and dag circles, and TODO other players mouses etc are in that space too far away,
		//ill create a function dagball.isSpaceControlsDim('mouseX')->true so know what range is allowed.
		mouseY: 'mouseY', //TODO allow making this a joystick axis.
		mouseX: 'mouseX',
		editCircleText: 'a',
		selectLockA: 'mouseButton0',
		//TODO? selectLockB: 'mouseButton2',
		//TODO? search: 's',
		moveView: 's',
		moveCircle: 'd',
		resizeCircle: 'f',
		createCircle: 'z',
		deleteCircle: 'x',
		todo23453245: 'c',
		todo243343453245: 'v',
		gpucircExistVote: 'q',
		gpucircInfluenceMedianVote: 'w',
		true: 'e',
		like: 'r',
		bright: '`',
		red: '1',
		green: '2',
		blue: '3',
		//some of these are keys in dagball.edgeTypes, such as: gpucircExistVote, gpucircInfluenceMedianVote, true, like, and dim.
	},
	prev_directControls:{}, //for holding keyboard button while moving mouse, to know if the button is held and (dy,dx) of mouse movement.
	update_prev_directControls: function(){
		for(let a in dagball.directControls){
			dagball.prev_directControls[a] = dagball.directControls[a];
		}
	},
	//Example params: 'mouseY' (may change by -.03 for example) 'mouseX' 'moveView' changes by +1 or -1 (cuz is always 0 or 1).
	//Change since dagball.update_prev_actionControls();
	controlsChange: function(name){
		return dagball.controls(name)-dagball.prevControls(name);
	},
	//controlsMap:{
	//	//will happen automatically if you dont rename them mouseY: 'mouseY',
	//	//mouseY: 'mouseX',
	//
	//},
	controls: function(name){ //TODO rename controls to control and prevControls to prevControl?
		if(dagball.actionControls[name] !== undefined){ //customizable controls
			name = dagball.actionControls[name];
		}
		return dagball.directControls[name] || 0;
		//OLD: replace this func to change your controls. Most code should only read from dagball.controls('mouseX'), not dagball.directControls.mouseX directly.
		//return dagball.directControls[name] || 0;
	},
	prevControls: function(name){ //TODO rename controls to control and prevControls to prevControl?
		if(dagball.actionControls[name] !== undefined){ //customizable controls
			name = dagball.actionControls[name];
		}
		return dagball.prev_directControls[name] || 0;
		//OLD: replace this func to change your controls. Most code should only read from dagball.controls('mouseX'), not dagball.directControls.mouseX directly.
		//return dagball.directControls[name] || 0;
	},
	selectedCircs: ()=>dagball.circles.filter(c=>c.isSelected),
	changeGameStateByInputControls: function(){ //uses dagball.controlChange('mouseY') and dagball.controlChange('moveView') etc.
		let newMessageToUser = '';
		if(!dagball.isTextEditing()){
			let mouseDy = dagball.controlsChange('mouseY');
			let mouseDx = dagball.controlsChange('mouseX');
			let mouseY = dagball.controls('mouseY');
			let mouseX = dagball.controls('mouseX');
			//console.log('changeGameStateByInputControls mouseDy='+mouseDy+' mouseDx='+mouseDx);
			//TODO move all for(let circ of dagball.selectedCircs()) to outer loop? Also theres going to be 2 selected groups, the FROMs and the TOs.
			if(dagball.controls('moveCircle')){
				newMessageToUser += ' move circle';
				for(let circ of dagball.selectedCircs()){
					circ.y += mouseDy;
					circ.x += mouseDx;
				}
			}
			if(dagball.controls('moveView')){
				newMessageToUser += ' move view';
				dagball.aftrans.addY += mouseDy*128; //FIXME use dagball.aftrans to convert the coordinates somehow
				dagball.aftrans.addX += mouseDx*128;
			}
			if(dagball.controls('createCircle')){
				newMessageToUser += ' create circle';
			}
			if(dagball.controlsChange('createCircle') == 1){ //the button was just pushed
				//TODO at mouseY mouseX
				dagball.circles.push(new dagball.Circ('swarm', 0, 0, 0,   mouseY, mouseX,   .14,  120, 120, 80, false, 'javascript:\n//TODO\n', [], []));
			}
			if(dagball.controls('resizeCircle')){
				newMessageToUser += ' resize circle by moving mouse to/from its center';
				for(let circ of dagball.selectedCircs()){
					let circleToMouseY = mouseY-circ.y;
					let circleToMouseX = mouseX-circ.x;
					let len = Math.hypot(circleToMouseY, circleToMouseX);
					if(len){
						let normedCircleToMouseY = circleToMouseY/len;
						let normedCircleToMouseX = circleToMouseX/len;
						//let mouseDLen = Math.hypot(mouseDy,mouseDx);
						//let normedMouseDy = mouseDy/mouseDLen;
						//let normedMouseDx = mouseDx/mouseDLen;
						//if(mouseDLen){
							//let cosineDistance = normedCircleToMouseY*normedMouseDy + normedCircleToMouseX*normedMouseDx;
							let dotProd = normedCircleToMouseY*mouseDy + normedCircleToMouseX*mouseDx;
							circ.r += dotProd;
						//}
					}
				}
			}
			let isEditingColor = false;
			if(dagball.controls('bright')){
				newMessageToUser += ' bright';
				for(let circ of dagball.selectedCircs()){
					//let mul = Math.exp(mouseDy*.1);
					let mul = Math.exp(mouseDy*-.4);
					circ.red = Math.max(0, Math.min(circ.red*mul, 255));
					circ.green = Math.max(0, Math.min(circ.green*mul, 255));
					circ.blue = Math.max(0, Math.min(circ.blue*mul, 255));
				}
				isEditingColor = true;
			}else{
				let isRed = false;
				let isGreen = false;
				let isBlue = false;
				if(dagball.controls('red')){
					isRed = true;
					for(let circ of dagball.selectedCircs()){
						let prevRed = circ.red;
						circ.red = Math.max(0, Math.min(prevRed+mouseDy*-100, 255));
						console.log('Changed circ.red from '+prevRed+' to '+circ.red+' cuz mouseDy='+mouseDy+' circ='+circ);
					}
					isEditingColor = true;
				}
				if(dagball.controls('green')){
					isGreen = true;
					for(let circ of dagball.selectedCircs()){
						let prevGreen = circ.green;
						circ.green = Math.max(0, Math.min(prevGreen+mouseDy*-100, 255));
						console.log('Changed circ.green from '+prevGreen+' to '+circ.green+' cuz mouseDy='+mouseDy+' circ='+circ);
					}
					isEditingColor = true;
				}
				if(dagball.controls('blue')){
					isBlue = true;
					for(let circ of dagball.selectedCircs()){
						let prevBlue = circ.blue;
						circ.blue = Math.max(0, Math.min(prevBlue+mouseDy*-100, 255));
						console.log('Changed circ.blue from '+prevBlue+' to '+circ.blue+' cuz mouseDy='+mouseDy+' circ='+circ);
					}
					isEditingColor = true;
				}
				if(isRed){
					if(isGreen){
						if(isBlue) newMessageToUser += ' white';
						else newMessageToUser += ' yellow';
					}else{ //not green
						if(isBlue) newMessageToUser += ' purple';
						else newMessageToUser += ' red';
					}
				}else{ //not red
					if(isGreen){
						if(isBlue) newMessageToUser += ' cyan/greenblue';
						else newMessageToUser += ' green';
					}else{ //not green
						if(isBlue) newMessageToUser += ' blue';
						//else do nothing / black.
					}
				}
			}
			if(isEditingColor) newMessageToUser += ' move mouse up/down to change color';
			let sels = dagball.selectedCircs();
			let mainEditTextarea = document.getElementById('mainEditTextarea');
			if(sels.length == 1){
				let circ = sels[0];
				mainEditTextarea.value = circ.text;
			}
			if(dagball.controls('selectLockA')){
				newMessageToUser += ' toggle selectLockA';
			}
			if(dagball.controls('selectLockB')){
				newMessageToUser += ' toggle selectLockB';
			}
			if(dagball.controlsChange('selectLockA') == 1){
				dagball.selectLockA = !dagball.selectLockA;
			}
			if(dagball.controlsChange('selectLockB') == 1){ //A and B are like FROM and TO groups of selected circs but i might code it some other way??
				dagball.selectLockB = !dagball.selectLockB;
			}
			if(dagball.controls('editCircleText')){
				//newMessageToUser = 'Keep holding button and move mouse\n<-- to text area if you want to use it there.\nOtherwise use keyboard only in textarea\ncuz moving mouse selects circle.';
				newMessageToUser = 'Edit text of this circle.\nClick again to stop editing.';
			}
			if(dagball.controlsChange('editCircleText') == 1){ //when button goes down, swap between text vs circles mode.
				dagball.setIsTextEditing(true);
				//if(dagball.setIsTextEditing(!dagball.isTextEditing()));
			}
			/*if(dagball.controlsChange('editCircleText') == -1){ //when release key. while holding it, will prevent selecting, so can move mouse over there if u want.
				//Already editing it, but focus the textarea if push a so dont have to move the mouse over to it which could select a different circ along the way.
				//FIXME if want to select text with mouse, thats hard to get mouse there if moving mouse selects any circ it touches
				mainEditTextarea.focus();
			}*/
			/*//do ALWAYS if exactly 1 is selected: if(dagball.controlsChange('editCircleText') == 1){
				let sels = dagball.selectedCircs();
				/*if(sels.length > 1){
					alert('Cant editCircleText of more than 1 selected circle.');
				}else* if(sels.length == 1){
					let circ = sels[0];
					let mainEditTextarea = document.getElementById('mainEditTextarea');
					mainEditTextarea.value = circ.text;
					mainEditTextarea.focus();
				}
			//}*/
			//console.log('mouseDy='+mouseDy);
		}
		dagball.messageToUser = newMessageToUser;
	},
	//display these at top left of screen, evaled again each video frame.
	displayLogs: {
		//countNextState: ()=>(''+dagball.game.countNextState),
		//FPS: ()=>((57 < dagball.estimateFPS && dagball.estimateFPS < 63) ? 'around 60 where it should be' : Math.round(dagball.estimateFPS)),
		FPS: ()=>Math.round(dagball.estimateFPS),
		mouse_controls_mouseX: ()=>+dagball.controls('mouseX'),
		mouse_prevControls_mouseX: ()=>+dagball.prevControls('mouseX'),
		mouse_controlsChange_mouseX: ()=>+dagball.controlsChange('mouseX'),
		mouse_controls_mouseY: ()=>+dagball.controls('mouseY'),
		mouse_prevControls_mouseY: ()=>+dagball.prevControls('mouseY'),
		mouse_controlsChange_mouseY: ()=>+dagball.controlsChange('mouseY'),
		$controls: ()=>{ //the $ is so its sorted earlier, is closer to top of screen, so it doesnt cover up as much.
			let html = '';
			for(let c of dagball.sortedKeys(dagball.actionControls)){
				let bright = dagball.controls(c)*.8+.2; //controls ranges -1 to 1, but i want it brighter
				let alsoSayWhichButton = !c.toLowerCase().includes('mouse');
				html += '<font color='+dagball.colorStr(bright,bright,bright)+'>'+c+(alsoSayWhichButton ? ('/'+dagball.actionControls[c]) : '')+'</font> ';
			}
			return html;
		},
		$directControls: ()=>{ //the $ is so its sorted earlier, is closer to top of screen, so it doesnt cover up as much.
			let html = '';
			for(let c of dagball.sortedKeys(dagball.directControls)){
				let bright = dagball.controls(c)*.8+.2; //controls ranges -1 to 1, but i want it brighter
				html += '<font color='+dagball.colorStr(bright*.5,bright*.8,bright)+'>'+c+'</font> ';
			}
			return html;
		},
		$directControlsOut: ()=>{ //the $ is so its sorted earlier, is closer to top of screen, so it doesnt cover up as much.
			let html = '';
			for(let c of dagball.sortedKeys(dagball.directControlsOut)){
				let bright = dagball.directControlsOut[c]; //range 0 to 1 for gamepad rumble, but more generally can be -1 to 1 for other kinds of outputs.
				html += '<font color='+dagball.colorStr(bright*.8,bright*.5,bright)+'>'+c+'</font> ';
			}
			return html;
		},
		numCircles: ()=>dagball.circles.length,
		/*
		aftrans: ()=>(''+dagball.aftrans),
		test2435: ()=>('blah'+Math.random()),
		//todoUseAftransToMergeTheMultipleCoordinateSystemsWhyMouseIsntSelectingCircs: ()=>'TODO',
		circ0y: ()=>(''+dagball.circles[0].y),
		circ0x: ()=>(''+dagball.circles[0].x),
		circ1y: ()=>(''+dagball.circles[1].y),
		circ1x: ()=>(''+dagball.circles[1].x),
		//circ2y: ()=>(''+dagball.circles[2].y),
		//circ2x: ()=>(''+dagball.circles[2].x),
		mouseY: ()=>(''+dagball.directControls('mouseY')),
		mouseX: ()=>(''+dagball.directControls('mouseX')),
		ball0Y: ()=>(''+dagball.game.pos[dagball.game.oBall()]),
		ball0X: ()=>(''+dagball.game.pos[dagball.game.oBall()+1]),
		*/
	},
	sortedKeys: function(ob){
		let keys = Object.keys(ob);
		keys.sort();
		return keys;
	},
	doDisplayLogs: function(){
		let keys = dagball.sortedKeys(dagball.displayLogs);
		let html = '';
		for(let key of keys){
			html += '<div>'+key+' = '+dagball.displayLogs[key]()+'</div>';
		}
		document.getElementById('displayLogs').innerHTML = html;
	},

	//Use Dags ids.
	//circIdPrefix: 'dagball_circ', //dagball_circ_x_2p34_y_m5_r_20_
	//playerPrefixEd25519PublicKey: 'dagball_player_ed25519_',
	//playerPrefixIfItsJustANameNoPublicKey: 'dagball_player_name_', //dagball.playerPrefix+smallStringWithNoWhitespace is an id. TODO ed25519 name player by publicKey and have them sign their votes and other messages with a time in utc seconds (with fraction) as float64.

	isDisplayCircs: true,
	utf8TextEncoder: new TextEncoder('utf-8'),
	utf8TextDecoder: new TextDecoder('utf-8'),
	stringToBytes: function(s){ return dagball.utf8TextEncoder.encode(s); },
	bytesToString: function(bytes){ return vm.utf8TextDecoder.decode(bytes); },
	hexDigits: '0123456789abcdef',
	mapOfHexDigitToInt: {}, //vals are 0 to 15. filled in boot.
	mapOfDoubleHexDigitsToInt: {}, //vals are 0 to 255. filled in boot.
	bytesToHex: function(bytes){ return dagball.bytesAndRangeToHex(bytes,0,bytes.length); },
	bytesAndRangeToHex: function(bytes,from,toExcl){
		let s = '';
		for(let i=from; i<toExcl; i++) s += vm.doubleHexDigits[bytes[i]];
		return s;
	},
	sha256HexOfString: function(s){ return dagball.bytesToHex(sha256(dagball.stringToBytes(s))); },
	//returns 8 hex digits including any leading zeros.
	intToHex: function(i){ return dagball.doubleHexDigits[(i>>24)&0xff]+dagball.doubleHexDigits[(i>>16)&0xff]+dagball.doubleHexDigits[(i>>8)&0xff]+dagball.doubleHexDigits[i&0xff]; },
	game: null, //2023-9-22 dagball.game has become mixed with dagball, so you cant easily run 2 games at once. Do I need running 2 games at once?
	//screen: null, //a ByteRect
	screen: null, //a FullScreenCanvas, containing a ByteRect
	//TODO move to dagball.game, not global here.
	byteRectTrail: null, //same size as dagball.screen.byteRect. Used to turn balls into paintbrushes so can see their path.
	dt: .001,
	defaultBallColorRed: 0,
	defaultBallColorGreen: 0,
	defaultBallColorBlue: 255,
	nextIdNum: 1,
	nextId: ()=>('d'+(dagball.nextIdNum++)),
	nameToDim: {},
	idToDim: {},
	randByte: ()=>dagball.randInt(256),
	randInt: size=>dagball.randIntRange(0,size),
	randIntRange: (fromIncl,toExcl)=>(fromIncl+Math.floor(Math.random()*(toExcl-fromIncl))),
	sigmoid: x=>(1/(1+Math.exp(-x))),
	mainLoop: function(){
		dagball.dt = .01; //FIXME get from timer, and truncate into range 0 to .2 and hopefully will be at least HDMI speed of 60 FPS (TODO)
		//dagball.game.nextState(dagball.dt, dagball.screen);
		try{
			dagball.game.nextState(dagball.dt);
		}catch(e){
			dagball.wasErrorNeedMainLoopRestart = true;
			console.log(dagball.messageToUser = 'dagball.mainLoop stopped cuz error. Edit textarea to start mainLoop again. This will happen thru dagball.wasErrorNeedMainLoopRestart. See line number in generated tinyGlsl GPU code on browser console to know what to fix.');
			throw e;
		}
		requestAnimationFrame(dagball.mainLoop);
	},
	inherit: (subclass,superclass)=>Object.setPrototypeOf(subclass.prototype, superclass.prototype), //(new subclass(...) instanceof superclass) is true
	afterAfterPaint: function(){
		//Things that use canvas context (dagball.screen.context) to paint screen need to do so after the ByteRect (.bytes is a Uint8Array) paints the canvas.
		//Since i dont have pics of all the fonts and their widths etc, it would be extra work to build that compared to painting text onto canvas with context.fillText.
		if(dagball.messageToUser){
			//this isnt the normal way of painting pixels. supposed to use dagball.screen.byteRect and dagball.screen.width and .height, instead of canvas context,
			//so FIXME is this working? and TODO convert it to byteRect instead so have full control over the pixels again and a simpler single layer.
			//dagball.screen.context.fillStyle = "blue";
			//dagball.screen.context.fillStyle = dagball.colorStr(.7+.1*Math.random(),.7+.1*Math.random(),.7+.1*Math.random());
			let freq = 3;
			let bright = .85+.15*Math.sin(dagball.time()*2*Math.PI*freq);
			dagball.screen.context.fillStyle = dagball.colorStr(bright, bright, bright);
			let canvasY = dagball.aftrans.forwardY(dagball.controls('mouseY'));
			let canvasX = dagball.aftrans.forwardX(dagball.controls('mouseX'));
			//canvasY += 4;
			//canvasX += 8; //a little to the right of mouse, cuz theres 2023-9-24 a small blue ball at mouse
			canvasY -= 17;
			canvasX -= 10;
			for(let line of dagball.messageToUser.split('\n')){
				dagball.screen.context.fillText(line, canvasX, canvasY);
				canvasY += 20;
				canvasX += 20;
			}
			//dagball.screen.context.fillText(dagball.messageToUser, canvasX, canvasY);
		}
	},
	boot: function(){
		console.log('Filling in some data structures.');
		//256 pairs of hex digits
		dagball.doubleHexDigits = [];
		for(let i=0; i<16; i++){
			dagball.mapOfHexDigitToInt[dagball.hexDigits[i]] = i;
			for(let j=0; j<16; j++){
				let hh = dagball.hexDigits[i]+dagball.hexDigits[j];
				dagball.doubleHexDigits.push(hh);
				dagball.mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
			}
		}

		console.log('TinyGLSL tests starting before dagball');
		tinyGlsl.testAfterBoot();
		console.log('Dagball starting');
		if(!tinyGlsl) throw 'No tinyGlsl';

		let nGlo = 0;
		let nCurve = 40;
		let nBall = 10;
		//let nBall = 100;
		//let nBall = 30;
		//let nBall = 400;
		//let nBall = 3;
		let mBall = 2;
		dagball.game = new dagball.Game( //dagball.Game = function(nGlo, nCurve, nBall, mBall, tinyGlslCurveCode){
			nGlo, nCurve, nBall, mBall,
				`//moving o var into built-in code: int o = oCurve;
				float firstY = parr[o++];
				float firstX = parr[o++];
				float firstObservedRadius = length(vec2(firstY,firstX));
				potenOne += .6*firstObservedRadius;
				y += .3*firstY;
				x += .3*firstX;
				float angle = atan(y,x); //of (y,x) from (0,0)
				float observedRadius = length(vec2(x,y)); //of (y,x) from (0,0)
				potenOne -= .6*observedRadius;
				float ditchRadius = 1.;
				//for(int freq=5; freq<6; freq++){
				//for(int freq=1; freq<4; freq++){
				//for(int freq=7; freq<10; freq++){
				//for(int freq=5; freq<9; freq++){
				//for(int freq=5; freq<12; freq+=3){
				//for(int freq=2; freq<8; freq+=3){
				for(int freq=1; freq<10; freq++){
				//for(int freq=1; freq<20; freq++){
					//potenOne += parr[o++]*sin(parr[o++]+freq*angle*parr[o++]);
					//ditchRadius += .07*parr[o++]*sin(parr[o++]+float(freq)*angle*parr[o++]);
					//ditchRadius += .05*parr[o++]*sin(parr[o++]+float(freq)*angle);
					//ditchRadius += .05*parr[o++]*sin(5.*parr[o++]+float(freq)*angle);
					//ditchRadius += 1./(1.+exp(parr[o++]))*sin(5.*parr[o++]+float(freq)*angle);
					ditchRadius += .24*parr[o++]*sin(12.*parr[o++]+float(freq)*angle);
				}
				ditchRadius = 1./(1.+exp(-ditchRadius)); //sigmoid
				ditchRadius *= 1.+.1*sin(5.*parr[o++]);
				ditchRadius *= .6;
				float ditchRadiusStdDev = .04;
				//float ditchRadiusStdDev = .09;
				//float ditchRadiusStdDev = .18;
				//float ditchRadiusStdDev = .3;
				//ditchRadiusStdDev *= 13./(3.5+exp(1.5*parr[o++]));
				float blur = parr[o++];
				blur /= ditchRadius;
				blur *= blur;
				ditchRadiusStdDev *= 1.+blur;
				float blurTarget = .8;
				float blurDiff = blur-blurTarget;
				potenOne += .1*blurDiff*blurDiff;
				float observedStdDev = (observedRadius-ditchRadius)/ditchRadiusStdDev;
				float bellHeight = exp(-observedStdDev*observedStdDev/2.); //range 0 to 1.
				float flippedBellHeight = 1.-bellHeight; //range 0 to 1.
				potenOne += flippedBellHeight;
				potenOne = 0.; //FIXME
				//potenOne *= .2;
				

				//hypercubewave code, experimenting todo...
				int oHypercubeWave = o;
				const int hypercubeDims = 5; //2 dagball dims per hypercubeDim cuz affine transform them into (y,x).
				//const int hypercubeDims = 9; //2 dagball dims per hypercubeDim cuz affine transform them into (y,x).
				for(int hypercubeDim2=0; hypercubeDim2<(hypercubeDims*2); hypercubeDim2++){
					float position = parr[oHypercubeWave+hypercubeDim2];
					//dont let hypercube dims get too far from hypercenter
					potenOne += .01*position*position; //FIXME?
				}
				//const int hypercubeDims = 12; //2 dagball dims per hypercubeDim cuz affine transform them into (y,x).
				const int loopSize = 1<<hypercubeDims;
				const float hypercubewaveStdDevOfCorners = .09;
				//const float hypercubewaveWeight = .25;
				//const float hypercubewaveWeight = .55;
				//const float hypercubewaveWeight = .15;
				//const float hypercubewaveWeight = .265;
				const float hypercubewaveWeight = .2865;
				const float scaleHypercubewaveSize = .1;
				float sumAllCornerBellCurves = 0.;
				for(int corner=0; corner<loopSize; corner++){
					float hyperCornerY = 0.;
					float hyperCornerX = 0.;
					float cornerParity = 1.;
					for(int hypercubeDim=0; hypercubeDim<hypercubeDims; hypercubeDim++){
						float dimParity = float((corner>>hypercubeDim)&1)*2.-1.; //-1 or 1
						cornerParity *= dimParity;
						//float isDimEvenOrOdd = float((corner>>hypercubeDim)&1); //0 or 1
						//float isDimEvenOrOdd = float((corner>>(hypercubeDims-1-hypercubeDim))&1); //0 or 1
						//cornerParity = mod(cornerParity+isDimEvenOrOdd,2.); //TODO optimize
						//float isDimEvenOrOdd = 1.; //FIXME
						//hyperCornerY += isDimEvenOrOdd*parr[oHypercubeWave+hypercubeDim*2];
						//hyperCornerX += isDimEvenOrOdd*parr[oHypercubeWave+hypercubeDim*2+1];
						hyperCornerY += dimParity*parr[oHypercubeWave+hypercubeDim*2];
						hyperCornerX += dimParity*parr[oHypercubeWave+hypercubeDim*2+1];
					}
					hyperCornerY *= scaleHypercubewaveSize;
					hyperCornerX *= scaleHypercubewaveSize;
					float dy = hyperCornerY-y;
					float dx = hyperCornerX-x;
					float distance = length(vec2(dy,dx));
					float distanceAsStdDev = distance/hypercubewaveStdDevOfCorners;
					float bellHeight = exp(-distanceAsStdDev*distanceAsStdDev/2.); //range 0 to 1.
					float parityFlippedBellHeight = bellHeight*cornerParity;
					//potenOne += hypercubewaveWeight*parityFlippedBellHeight;
					//potenOne += -hypercubewaveWeight*bellHeight;
					sumAllCornerBellCurves += hypercubewaveWeight*parityFlippedBellHeight;
				}
				//sumAllCornerBellCurves = abs(sumAllCornerBellCurves); //FIXME how does hypercubewave do it? squared? sqrt? abs?
				//sumAllCornerBellCurves *= sumAllCornerBellCurves; //FIXME how does hypercubewave do it? squared? sqrt? abs?
				potenOne += sumAllCornerBellCurves;

				`
			
			/*
			`
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+angle*parr[oCurve+2]);
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+2*angle*parr[oCurve+2]);
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+3*angle*parr[oCurve+2]);
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+4*angle*parr[oCurve+2]);
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+5*angle*parr[oCurve+2]);
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+6*angle*parr[oCurve+2]);
			potenOne += parr[oCurve]*sin(parr[oCurve+1]+7*angle*parr[oCurve+2]);
			`
			*/
		);
		//dagball.game.displayBallTrails = true;
		dagball.game.displayBallTrails = false;
		dagball.game.randomizePos();
		//dagball.game.randomizeVel();
		dagball.mainLoop();
	},
};




/* TODO code this with many Player objects in same browser, since the votes/vectors of other players will get copied to many computers and summed there.
Possible way for players to vote on curve patterns of game world. 2 kinds of voting used together. Each vote for if
a circle/node exists or not is a length 1 vector. Vote between -1 to 1 on each circle, or 0.1 on 100 circles, etc. Median vote
on weight/influence per circle/node IF exists. Votes sum to node priority for constraint solver. Neg priority is always off.
Hopfield net between circles. Edge between near circles. Bias per node so hopfield keeps density of vars under 1000 near
every area. All nodes off. Loop by descending priority. Hopfield may turn node on. 
-- https://www.facebook.com/groups/dagball/posts/683555173687394/ (text above slightly modified since posted at these urls 2023-9-18)
-- https://twitter.com/DagBallGame/status/1703790786360271292

2023-9-18 Wrote this to LLM after quoting the player class and comments, todo copy other parts of that conversation here if relevant...
[[A circ is a circle at constant centerY centerX radius, with circInfluence scalar, and with a string of GLSL code that will be windowed
to only directly affect things in that circle. Many such circs together form a scalar field of up to trillions of dimensions, but at most
1000 dimensions (float vars in GLSL) can be on screen at once per player viewing it. The game works by moving a 2d cross-section through
the trillion dimensional constant scalarField, so it looks like the game terrain is moving. Balls roll in the valleys and ditches and
other low parts (low scalar in general). Up to 1000 dimensional gradient is computed (this and the balls rolling on those shapes is
already working) and updates velocity by that gradient computed by position. Im trying to scale up DagBall (this game) by generalizing
it to circles. Its just 1 gpu code at a time now but i want to make it sparse. Im not asking for help writing that code. I want your
help on the gametheory of the voting, in the context of that.
]]
..ChatGPT4 response 2023-9-18..
[[[
Understood. Given the context you've provided, let's delve into the game theory of the voting mechanism for DagBall.

Game Theory of Voting in DagBall
Incentive Structure:

Players should have a clear incentive to vote. This could be to shape the game world in a way that benefits their gameplay or strategy.
If players can gain an advantage by voting in a certain way, they will be more likely to participate in the voting process.
Fairness and Balance:

The influence system should be balanced. If a player or group of players has too much influence, it might lead to an unfair advantage or a less diverse game world.
Consider implementing mechanisms to prevent or limit collusion among players. For instance, if a group of players always votes together to shape the game world to their advantage, it could be detrimental to the overall game experience.
Transparency:

Players should be able to see how votes are being counted and how they affect the game world. This transparency will build trust in the voting system and encourage participation.
Consider providing visual feedback in the game world based on the votes. For example, if a circle/node is highly voted upon, maybe it glows or has some other visual indicator.
Dynamic Voting:

Consider allowing dynamic voting where players can change their votes based on the evolving game world and strategies of other players. This can introduce an additional layer of strategy and unpredictability.
Weighted Voting:

As you've mentioned, players can have different influence levels. This can be a double-edged sword. On one hand, it can reward players who have been more active or have contributed more to the game. On the other hand, it can lead to power imbalances.
Consider implementing mechanisms to periodically recalibrate or reset influence levels to ensure fairness.
Feedback Loops:

Be wary of feedback loops where certain voting patterns lead to game states that further reinforce those voting patterns. For instance, if a certain configuration of circles/nodes gives a player an advantage, and that player has high influence, they might keep voting to maintain that configuration.
Experimentation:

As you've mentioned, the open-source nature of DagBall allows for experimentation. Encourage players and developers to experiment with different voting mechanisms and influence structures. This can lead to a richer and more diverse game experience.
Decentralization:

Given the multiverse nature of DagBall, consider decentralizing the voting process. This can be done by allowing different "rooms" or "realms" with their own voting rules and influence structures. Players can then choose which realm they want to play in based on their preferences.
Fallback Mechanisms:

Consider having fallback mechanisms in case the voting leads to undesirable game states. For instance, if all players vote to remove all circles/nodes, the game might become unplayable. In such cases, have mechanisms to reset or introduce default configurations.
Player Education:

Ensure that players understand the implications of their votes. Provide tutorials or guides explaining how voting affects the game world and the strategies they can employ.
In summary, the game theory of voting in DagBall revolves around balancing player incentives, ensuring fairness, and providing mechanisms for experimentation and feedback. By carefully considering these aspects, you can create a rich and engaging game experience.




User
Instead of explaining what could go right, play devils advocate and explain what could go wrong.
ChatGPT
Certainly! Playing devil's advocate, here are potential pitfalls and challenges that could arise with the voting mechanism in DagBall:

Power Imbalances:

If a few players or a group gains too much influence, they could dominate the voting process, leading to a game world that caters only to their preferences. This could alienate other players and reduce the diversity of the game experience.
Collusion:

Groups of players might collude to vote in a way that benefits them disproportionately. This could lead to unfair advantages and a less enjoyable experience for others.
Gaming the System:

Players might find ways to exploit the voting mechanism for personal gain. For instance, they might create multiple accounts to amplify their votes or use bots to manipulate the outcome.
Analysis Paralysis:

With too many options or complexities in the voting process, players might become overwhelmed and choose not to participate. This could lead to decisions being made by a very small subset of players.
Feedback Loops:

As mentioned earlier, certain voting patterns could lead to game states that further reinforce those voting patterns, creating a stagnant or repetitive game environment.
Unintended Consequences:

The outcome of certain votes might lead to unexpected game dynamics or unplayable states. For example, if players vote to remove essential game elements, it could break the game.
Lack of Engagement:

If players don't see a direct impact of their votes or if the game world changes too frequently due to votes, they might become disengaged and lose interest.
Transparency Issues:

If the voting process isn't transparent or if players feel their votes aren't being counted fairly, it could lead to distrust and dissatisfaction.
Overhead and Complexity:

Implementing a robust and fair voting mechanism could introduce significant overhead and complexity to the game's development and maintenance.
Fragmentation:

If different "rooms" or "realms" have their own voting rules and outcomes, it could lead to fragmentation of the player base. Players might cluster in certain popular realms, leaving others deserted.
Economic Inequities:

If influence can be purchased or is based on any economic factors, it could introduce real-world economic inequities into the game, where those with more resources have a disproportionate say.
Short-term Thinking:

Players might vote based on short-term gains or immediate gratification, leading to game states that aren't enjoyable or sustainable in the long run.
Lack of Diversity:

If the majority of players have similar preferences, the game world might lack diversity, leading to a monotonous experience.
In summary, while the idea of a democratic voting mechanism in DagBall is intriguing, it comes with potential challenges and pitfalls. It's essential to anticipate these issues and have mechanisms in place to address them to ensure a fair and enjoyable game experience for all players.
]]]
*
dagball.Player = function(id){
	this.id = id || dagball.nextId();

	use dagball.Circ with circ.isPubkey of true, instead of this class.
	Use edge types of 'gpucircExistVote' and 'circInfluenceMedianVote'.
	Use circ.influence instead of player.influence. A player will be a circ that can move around and change what they point at. Dont forget to timestamp sigs and sign the timestamp with it.

	//TODO use dagball.Circ as player. use dagball.Circ with circ.isPubkey of true, instead of this class.
	//amount of influence of this player. How much does your vote count. If a player is not known to exist or is in some other namespace, this would be 0. Normally 1,
	//but might want to adjust this for various reasons. Its opensource so different kinds of voting can be tried without forcing anyone to use it.
	//If you want to play by yourself on local computer, set this to 1 and all other players to 0, or could choose a group of friends and set all their
	//influences to 1 and all other players influences to 0, in your local copies of the game, not preventing those other players from playing with eachother.
	//The multiverse of DagBall will include smooth paths between all these possibilities, though there might be some parts jagged, you dont have to cross
	//the jagged parts to get from anywhere to anywhere. Its a research path how smooth it can be vs jagged in some parts.
	this.influence = 1;

	//TODO use dagball.Edge of type 'gpucircExistVote' instead of this, and use it in a dagball.Circ. OLD...
	//of dagball.Circ instance to number, and vec length (sqrt of sum of squares) of those numbers is 1. TODO vote 1 for some default circle so map isnt empty.
	//TODO circ.priority is often set to sum of player.influence*player.circExistVotes[circ] forall players in that room/game/namespace.
	this.circExistVotes = new Map();

	//TODO use dagball.Edge of type 'circInfluenceMedianVote' instead of this, and use it in a dagball.Circ. OLD...
	//of dagball.Circ instance to number, and vec length doesnt matter, can be any numbers you want.
	//TODO circ.weight or maybe it will be called circ.influence, is often set
	//to the weightedMedian of [player.influence, player.circInfluenceVotes[circ]] forall players in that room/game/namespace.
	//weightedMedian means each vote is a rectangle. Its width is player.influence, and its height is player.circInfluenceMedianVotes[circ],
	//and they are layed side by side touching eachother, sorted by height, then find the vote thats horizontally in the middle, and the winning number is that height.
	//Normal median voting has weight of 1 for all votes.
	this.circInfluenceMedianVotes = new Map();
};

//chatgpt4 "make up 20 player names for this game" 2023-0-18 after talking about the voting and gpu circles.
dagball.examplePlayerIds = 'QuantumRoller CircleMaster23 DagDynamo BallisticBlitz VectorVoyager SphericalSage DimensionDrifter GravityGuru OrbitalOdyssey RadialRogue SpinSorcerer AxisAce CurveCrusader TangentTitan MomentumMystic ScalarSeeker VortexVanguard PlanePioneer GeometricGuardian EllipseEnigma'.split(' ').map(s=>(dagball.playerPrefix+s));
/*TODO
dagball.game.players = [];
dagball.game.examplePlayerNames.forEach(id=>{
	dagball.players.push(new dagball.Player(id));
});
//TODO move this into dagball.boot?
*/



dagball.Edge = function(type, weight, child){
	this.type = type;
	this.weight = weight;
	this.child = child;
};

//simpler edge type between the vars of 1 or more gpucircs. Whichever Eds have the same y and x
//must hold those float/double vars equal (pos mostly, and also to some extent vel and velDecay).
//and their gradient is summed together not averaged.
//TODO should it be addY and addX instead of y and x, so dont have to change the edges when move the gpucirc?
//What about resizing the gpucirc. Lets just keep it as y and x and update them when move the gpucirc.
/*
redesignGpucircToHaveItsVarsOnItsPerimeterSoIsEasierToMoveAndResize

Problem is to compute hopfield max1000dimsinviewatonce we have to use a bounding circle that includes the circle
where it affects the curves AND all the vars.

They will already be separate vars, even when shared, in gpu, cuz of parr[o++] and o being (TODO) set just before
each next gpucircle in the generated code. If there are n duplicate vars, then they should all be set together and
their gradient is the sum of all their gradients (not the average).

I could display the gpufloat vars of each gpucirc as small circles on its perimeter, or 1/n of the length of its
perimeter each a different color. And hook them together with lines between them, which could get to be alot of lines,
or lines of 2 hops to a groupOfThatVar which has lines to/from all gpucircvaronperimeter that are held together in that
group. Another name for groupOfThatVar is leafvar if its below gpucirc in the dag. If groupOfThatVar is above gpucirc
in dag, then gpucirc is a leaf. None of that seems to fit exactly cuz the gpucircvaronperimeter and groupOfThatVar
seem to be on different levels in one way and the same level in another way.

What should happen if a gpucirc moves past its vars (which are each at a 2d position?) should it expand to still
contain them? Move them with it?

How can a gpucirc or small group of them that share some vars, be copy/pasted to another area of the 2d world?
I'll of course literally copy their data as json or something like that, then back to gpucirc objects.

Should a gpucirc have its vars on its perimeter and they be defined by (addY,addX) so gpucirc.y+gpucirc.childs[44].addY
would be where a line from its perimeter points to, and if any other lines from other gpucircs point there, they are
hooked together without a separate daglevel. so for each gpufloatvar in a gpucirc theres 3 floats: val, y, x.
(or val, addY, addX). Should these lines be different colors? Does edge weight matter for edgeType dim? Is it even
stored as an edge? If they should be different colors, which? Are they stored as
red green blue (or just a floatRGB?) per edge?
*/
dagball.Ed = function(y, x, pos, vel, velDecay){
	this.y = y;
	this.x = x;
	this.pos = pos;
	this.vel = vel;
	this.velDecay = velDecay;
};
dagball.Ed.prototype.type = 'ed';



//a mutable circle with 0 or more child circles that are normally completely inside it,
//BUT since its mutable, that may not always be true. It should expand to make it true.
//TODO make an immutable form of this, similar to in wikibinator203's TreeUI html
//the Splat class is a mutable tree of UI and it has a mutable pointer to a Split
//which is an immutable DAG/forest, and each Split has 2 Split childs and 1 Splate
//which is the Split's immutable local state. Thats how Splat's state is updated recursively.
//Similarly, dagball.Circ will be a mutable DAG/forest of Circs,
//and can be snapshotted as TODO create an immutable object type.
//TinyGLSL does caching of the GPU stuff so whatever code string the Circs merge their codes to,
//TinyGLSL will handle it efficiently even if the same code string is generated multiple times.
//
//The code param can be javascript or TinyGLSL code. It should start with some variables:
//then 'javascript:' or 'tinyglsl:' on a line by itself.
//Before that there might be
//x:3.53
//y:2.1
//r:15
//tinyglsl:
//then the remaining lines
//are the tinyglsl code.
//
//TODO copy x y r between code and these vars if either is edited.
//
dagball.Circ = function(syncType, pos, vel, velDecay, y, x, r, red, green, blue, isSelected, text, edgesOut, edsOut){

	//FIXME todo use the stuff in Dag and DagStuff js maps {} but Circ should maybe still be the only object on screen
	//cuz its how things get displayed.

	//FIXME. id should start with the syncType letter [s for swarm. c for const. p for pubkey] BUT since i 
	this.id = null;


	//FIXME some vars should be 
	this.syncType = syncType;
	this.lockCirc = false; //lock this.y this.x this.r (its circle on screen)? Else let it move around based on what its near and other UI based energyfuncs etc.
	this.lockText = false; //lock this.text, hold it to the value it currently is?
	this.lockEdgesOut = false;  //lock this.edgesOut contents?

	//if true, this.edgesOut can change to have cycles, and the DAG does not look past that for computing ids (pubkey signs next set of edgesOut and local fields etc),
	//such as the 2 kinds of voting
	//(dagball.Player should be replaced by dagball.Circ using edgesOut but keep the comments, very important comments on the kind
	//of voting there and how it works with hopfield constraint solving (not storing hopfield edges cuz theyre derived from distance
	//but using the hopfield math)). A player may have multiple pubkeys, 1 for each kind of voting, 1 for likes, 1 for dislikes, 1 for things the player thinks are true,
	//1 for things the player thinks are false (other player says something in a circ.text, that an edgesOut is to, etc).
	//OR maybe there will be multiple edge types, as dagball.Edge could have a type
	this.isPubkey = false;

	//this.priority and this.influence are only used in the second dag level of circs,
	//not the leafs right under them. Only the circs that have GPU/GLSL code,
	//so not as much of a dag as I was planning (just those 2 layers, with players above them as a third layer),
	//but other dag stuff will likely get added later. this.circExists is maybe used for both those lowest layers.
	
	//sum of player.influence*player.circExistVotes[this]. higher is better. 0 or negative means circExists is false.
	this.priority = 1;

	//computed by sorting circs by descending priority, turn all circs off, loop over them,
	//and let hopfield net (dont store the weights since they're derived from distance between pairs of circs) turn some circs on.
	this.circExists = true;

	//computed as weightedMedian of [player.influence,player.circInfluenceVotes[this]] forall players in that room/game/namespace.
	//scalar field output is multiplied by this before adding to the combined scalar field. Its the amount of influence of this circ's GLSL code.
	this.influence = 1; //FIXME this might just be relevant

	//this.daglev = null; //FIXME not sure if will do even/odd daglevs (child is 2 hops down) vs child is 1 hop down as usual in dags.

	//TODO should there be this.name?
	/*
	this.pos = pos; //position. Position goes into GPU but vel and velDecay and the other number vars dont.
	this.vel = vel; //velocity
	this.velDecay = velDecay; //velocityDecay. TODO should mveldecay be global instead of varying per var/dimension?
	*/

	//optional wikibinator203 fn, a universal pattern-calculus combinator that can be used for scaling up math and computing systems, in theory.
	//Call fn on fn to find or create fn.
	this.fn = null;

	this.y = y; //circle center x
	this.x = x; //circle center y
	//radius that the circle has an influence on. scalarField out (potentialEnergy) is windowed,
	//multiplied by something similar to a bellcurve (TODO choose a function, one thats exactly 0,
	//not just near 0, past the circle)
	this.r = r;
	this.red = red;
	this.green = green;
	this.blue = blue;
	this.isSelected = isSelected;
	//code should use parr[o+0] to parr[o+c-1] where c is this.childs.length, cuz "int o" will be set before the code runs.
	//TODO use p[c] instead, and replace 'p[' with 'parr[o+'. BUT dont replace 'othervarnamep[' despite it contains 'p['.
	//Code can therefore loop over chosen ranges of childs, within its range of parr, if it wants to,
	//like the first example code loops over a few frequencies each with a phase.
	//Code only computes what to add to potentialEnergy (the combined scalar field). Return it by setting potenOne = ... in code.
	//TODO also have a mutable local float[] that can be read and written local[l+number] or call that q[number].
	//All the circs can share the same local[]/q[] but should only read an index in it after writing that index,
	//so they dont read things written by other circs compiled together. TODO check code for that kind of thing at runtime.
	//For example, ForestCurveFit has a mutable float[20] per GPU thread and has about 800 floats in glsl "uniform" memory
	//(optimization of it being constant until GPU returns to CPU). So the in-game editor will be flexible enough
	//to create ForestCurveFit in a circle.
	//this.code = code;
	//
	//is TinyGLSL code if this is a GpuCirc. If its above GpuCirc, it might be text a person typed, javascript code, a wikibinator203 id, etc.
	//Anywhere in this text that an id occurs, that becomes one of the childs.
	//This might be a json map of some data structure the players make up. Not sure what this will become,
	//but (TODO) the general idea is when this Circ is selected, the text appears in the text editor on the left/top of screen.
	this.text = text;
	//this.childs = childs;
	this.edgesOut = edgesOut; //instances of dagball.Edge. TODO display edgesOut and edsOut from different parts of the circle perimeter.
	this.edsOut = edsOut; //instances of dagball.Ed
};

dagball.Circ.prototype.type = 'circ';

dagball.Circ.prototype.eSize = function(){
	return this.edgesOut.length+this.edsOut.length;
};

dagball.Circ.prototype.edgeIndex = function(i){
	return i;
};

dagball.Circ.prototype.edIndex = function(i){
	return this.edgesOut.length+i;
};

//i from 0 to this.eSize()-1. Returns angle (FIXME put it in that range after handle flipped y etc) 0 (inclusive) to 2*Math.PI (exclusive) of point on perimeter of this circle.
dagball.Circ.prototype.ePerimeterAngle = function(i){
	return Math.PI/2 - i/this.eSize()*2*Math.PI; //start at top and go clockwise. FIXME this might be flipped cuz +y is normally down on screen
};

//i from 0 to this.eSize()-1. Returns y of point on perimeter of this circle.
dagball.Circ.prototype.perimeterY = function(i, optionalRadius){
	let radius = optionalRadius!==undefined ? optionalRadius : this.r;
	return this.y+radius*Math.sin(this.ePerimeterAngle(i));
};

//i from 0 to this.eSize()-1. Returns x of point on the perimeter of this circle.
dagball.Circ.prototype.perimeterX = function(i, optionalRadius){
	let radius = optionalRadius!==undefined ? optionalRadius : this.r;
	return this.x+radius*Math.cos(this.ePerimeterAngle(i));
};

dagball.Circ.prototype.eFromY = function(i){
	return this.perimeterY(i);
};

dagball.Circ.prototype.eFromX = function(i){
	return this.perimeterX(i);
};

dagball.Circ.prototype.eToY = function(i){
	if(i < this.edgesOut.length){
		return this.edgesOut[i].child.y;
	}else{
		return this.edsOut[i-this.edgesOut.length].y;
	}
};

dagball.Circ.prototype.eToX = function(i){
	if(i < this.edgesOut.length){
		return this.edgesOut[i].child.x;
	}else{
		return this.edsOut[i-this.edgesOut.length].x;
	}
};

//get existing child that may be a dagball.Edge or a dagball.Ed. i ranges 0 to this.eSize()-1.
dagball.Circ.prototype.getE = function(i){
	if(i < this.edgesOut.length){
		return this.edgesOut[i];
	}else{
		return this.edsOut[i-this.edgesOut.length];
	}
};

//when there are n gpu vars (parr[o++] etc) in this.text and this.text stats with 'tinyglsl:' or something like that (TODO),
//call this to make some short Ed lines from circle perimeter, 1 per var.
dagball.Circ.prototype.replaceEdsWithDefaultsForNVars = function(n){
	while(this.edsOut.length > n) this.edsOut.pop();
	while(this.edsOut.length < n) this.edsOut.push(new dagball.Ed(0, 0, 0, 0, 0));
	let radius = this.r*.85;
	for(let i=0; i<n; i++){
		let j = this.edIndex(i); //needs this.edgesOut.length and this.edsOut.length to be the right size, so cant add to the arrays while calling this.
		this.edsOut[i].y = this.perimeterY(j,radius);
		this.edsOut[i].x = this.perimeterX(j,radius);
	}
	/*this.edsOut = [];
	let radius = this.r*.85;
	for(let i=0; i<n; i++){
		let j = this.edIndex(i);
		this.edsOut.push(new dagball.Ed(this.perimeterY(j,radius), this.perimeterX(j,radius), 0, 0, 0));
	}*/
};



dagball.Circ.prototype.toString = function(){
	return 'Circ(id='+this.id+' y='+this.y+' x='+this.x+' r='+this.r+' red='+this.red+' green='+this.green+' blue='+this.blue+' isSelected='+this.isSelected+' text='+this.text+' edgesOut='+this.edgesOut+' edsOut='+this.edsOut+')';
};

dagball.Circ.prototype.centerDistanceYX = function(y,x){
	return Math.hypot(this.y-y, this.x-x);
};

//distance from the parts of the circ on screen (just the perimeter for now, not the center or edge lines) to the (y,x). For example, to the mouse cursor (in some coordinate system, TODO).
dagball.Circ.prototype.uiDistanceToYX = function(y,x){
	let centerDist = this.centerDistanceYX(y,x);
	let edgeDist = Math.abs(centerDist-this.r);
	return Math.min(centerDist, edgeDist);
};

//null if none are near enough. Else picks one by uiDistanceToYX.
dagball.uiCircNearYXElseNull = function(y,x){
	var best = null;
	var bestDist = Infinity;
	for(let circ of dagball.circles){
		var dist = circ.uiDistanceToYX(y,x);
		if(dist < bestDist){
			best = circ;
			bestDist = dist;
		}
	}
	return (bestDist <= dagball.maxDistanceToSelect) ? best : null;
};

dagball.edgeTypes = {
	//general: {description: 'the default edge. type. TODO use unknown for this edge type instead?'},
	dim: {description: 'is a dimension i read andOr write. This is normally used by GpuCircs to point at LeafVars'},
	like: {description: 'a player likes (vs dislikes) anything. Negative weight on this is dislike.'},
	//dislike: {description: 'a player dislikes (vs likes) anything'},
	true: {description: 'a player claims a thing is true. or false if negative weight.'},
	//false: {description: 'a player claims a thing is false'},	
	gpucircExistVote: {description: 'of dagball.Circ instance to number, and vec length (sqrt of sum of squares) of those numbers is 1. TODO vote 1 for some default circle so map isnt empty. TODO circ.priority is often set to sum of player.influence*player.circExistVotes[circ] forall players in that room/game/namespace. then hopfield network acts as constraint solver to make there be at most 1000 vars/dimensions within each local area, by including any pair of circs (hopfield edge between them) depending on radiusA+viewDist+radiusB-centerToCenterDistance. ... TODO code this with many Player objects in same browser, since the votes/vectors of other players will get copied to many computers and summed there. Possible way for players to vote on curve patterns of game world. 2 kinds of voting used together. Each vote for if a circle/node exists or not is a length 1 vector. Vote between -1 to 1 on each circle, or 0.1 on 100 circles, etc. Median vote on weight/influence per circle/node IF exists. Votes sum to node priority for constraint solver. Neg priority is always off. Hopfield net between circles. Edge between near circles. Bias per node so hopfield keeps density of vars under 1000 near every area. All nodes off. Loop by descending priority. Hopfield may turn node on.'},
	gpucircInfluenceMedianVote: {description: 'of dagball.Circ instance to number, and vec length doesnt matter, can be any numbers you want. TODO circ.weight or maybe it will be called circ.influence, is often set to the weightedMedian of [player.influence, player.circInfluenceVotes[circ]] forall players in that room/game/namespace. weightedMedian means each vote is a rectangle. Its width is player.influence, and its height is player.circInfluenceMedianVotes[circ], and they are layed side by side touching eachother, sorted by height, then find the vote thats horizontally in the middle, and the winning number is that height. Normal median voting has weight of 1 for all votes. this.circInfluenceMedianVotes = new Map();'},
	//TODO other common like/emoji/voting types
};

//simple edge to here. TODO reuses it in some cases?
dagball.Circ.prototype.e = function(edgeType, optionalWeight){
	//if(this.e_ === undefined) this.e_ = new dagball.Edge(this, 1);
	//return this.e_;
	let weight = optionalWeight!==undefined ? optionalWeight : 1;
	return new dagball.Edge(edgeType, weight || 0, this);
};

//TODO limit to 1 of each edge type per dagball.Circ parent and its child. Have func to add to weight from the parent.

dagball.Circ.prototype.eDim = function(optionalWeight){
	return this.e('dim', optionalWeight);
};

dagball.Circ.prototype.eLike = function(optionalWeight){
	return this.e('like', optionalWeight);
};

//negative weight of eLike
dagball.Circ.prototype.eDislike = function(optionalWeight){
	return this.e('like', optionalWeight!==undefined ? -optionalWeight : -1);
};

dagball.Circ.prototype.eTrue = function(optionalWeight){
	return this.e('true', optionalWeight);
};

//negative weight of eTrue
dagball.Circ.prototype.eFalse = function(optionalWeight){
	return this.e('true', optionalWeight!==undefined ? -optionalWeight : -1);
};

dagball.Circ.prototype.eGpucircExistVote = function(optionalWeight){
	return this.e('gpucircExistVote', optionalWeight);
};

dagball.Circ.prototype.eGpucircInfluenceMedianVote = function(optionalWeight){
	return this.e('gpucircInfluenceMedianVote', optionalWeight);
};

dagball.Circ.codeLanguage = function(){
	if(this.code.includes('tinyglsl:')) return 'tinyglsl';
	if(this.code.includes('javascript:')) return 'javascript';
	throw 'TODO generalize this to looking for the first line that ends with : then return whats before that. If it has whitespace, throw.';
};

//the part of a 2d affine transform that offsets and magnifies in y and x but doesnt tilt or rotate.
dagball.SimpleAftrans = function(addY, addX, magnifyY, magnifyX){
	this.addY = addY;
	this.addX = addX;
	this.magnifyY = magnifyY;
	this.magnifyX = magnifyX;
};
dagball.SimpleAftrans.prototype.forwardY = function(y){
	//FIXME should this be addY+magnifyX*(this.y-addY) vs this.addY+this.magnifyY*y?
	return this.addY+this.magnifyY*y;
};
dagball.SimpleAftrans.prototype.forwardX = function(x){
	//FIXME should this be addX+magnifyX*(this.x-addX) vs this.addX+this.magnifyX*x?
	return this.addX+this.magnifyX*x;
};
dagball.SimpleAftrans.prototype.reverseY = function(forwardY){
	//FIXME?
	//forwardY return this.addY+this.magnifyY*y;
	return (forwardY-this.addY)/this.magnifyY;
};
dagball.SimpleAftrans.prototype.reverseX = function(forwardX){
	//FIXME?
	//forwardX return this.addX+this.magnifyX*x;
	return (forwardX-this.addX)/this.magnifyX;
};
dagball.SimpleAftrans.prototype.toString = function(){
	return 'SimpleAftrans[addY='+this.addY+' addX='+this.addX+' magnifyY='+this.magnifyY+' magnifyX='+this.magnifyX+']'
};

dagball.Circ.prototype.display = function(optionalByteRect){
	let byteRect = optionalByteRect || dagball.screen.byteRect;
	//TODO reuse this aftrans if theres alot of circs. more efficient to give it as param.
	//TODO move this default aftrans to dagball.viewAftrans?
	//let aftrans = optionalAftrans || (new dagball.SimpleAftrans(byteRect.height/2, byteRect.width/2, 1, 1));
	let aftrans = dagball.aftrans;
	if(!aftrans) throw 'TODO aftrans';
	//if(addY === undefined) addY = 0;
	//if(addX === undefined) addX = 0;
	//if(magnifyY === undefined) magnifyY = 1;
	//if(magnifyX === undefined) magnifyX = 1;
	let isChangingColor = dagball.controls('red') || dagball.controls('green') || dagball.controls('blue') || dagball.controls('bright');
	let displayAsSelectedByRandomColor = this.isSelected & !isChangingColor;
	let red = displayAsSelectedByRandomColor ? dagball.randByte() : this.red;
	let green = displayAsSelectedByRandomColor ? dagball.randByte() : this.green;
	let blue = displayAsSelectedByRandomColor ? dagball.randByte() : this.blue;
	let transformedY = aftrans.forwardY(this.y);
	let transformedX = aftrans.forwardX(this.x);
	//byteRect.paintDonut(transformedY, transformedX, this.r*aftrans.magnifyY, this.r*aftrans.magnifyX, red, green, blue);
	if(aftrans.magnifyY != aftrans.magnifyX) throw 'TODO replace paintDonut with paintOval';
	let transformedRadius = this.r*aftrans.magnifyY; //FIXME paintOval
	let maxRadius = transformedRadius;
	let minRadius = transformedRadius-2;
	byteRect.paintDonut(transformedY, transformedX, minRadius, maxRadius, red, green, blue);
	//for(let c=0; c<this.childs.length; c++){
	for(let e=0; e<this.edgesOut.length; e++){ //perimeter starts with edgesOut then edsOut
		let edge = this.edgesOut[e];
		let ch = edge.child;
		//let ch = this.childs[c];
		let angle = Math.PI/2 - 2*Math.PI*e/this.edgesOut.length; //spread childs evenly around circle. TODO first child at top, or last child at top like a clock has 12 there?
		//let onThisCirclesEdgeY = this.y+this.r*Math.sin(angle);
		//let onThisCirclesEdgeX = this.x+this.r*Math.cos(angle);
		let onThisCirclesEdgeY = this.perimeterY(e);
		let onThisCirclesEdgeX = this.perimeterX(e);
		//let onChildCirclesEdgeY = aftrans.forwardY(ch.y+ch.r*Math.sin(angle)); //FIXME make the line be toward center of child
		//let onChildCirclesEdgeX = aftrans.forwardX(ch.x+ch.r*Math.cos(angle));
		let vectorToChildCenter_Y = ch.y-onThisCirclesEdgeY;
		let vectorToChildCenter_X = ch.x-onThisCirclesEdgeX;
		let vectorToChildCenter_len = Math.hypot(vectorToChildCenter_Y, vectorToChildCenter_X);
		let dontTouchItOnToSide = Math.min(vectorToChildCenter_len/2, 7);
		let vectorToChildCenter_newLen = vectorToChildCenter_len-ch.r-dontTouchItOnToSide;
		let vecMul = vectorToChildCenter_newLen/vectorToChildCenter_len;
		let nearestPointOnChildCircleToThat_Y = onThisCirclesEdgeY + vecMul*vectorToChildCenter_Y;
		let nearestPointOnChildCircleToThat_X = onThisCirclesEdgeX + vecMul*vectorToChildCenter_X;
		let fractionFromInsteadOfTo = .9; //1 means its color of the circle its from. 0 means color of circle its to. .5 means each gets half the line.
		fractionFromInsteadOfTo = 1-fractionFromInsteadOfTo; //FIXME i got something backward. shouldnt have to do this.
		let pointBetweenY = onThisCirclesEdgeY*fractionFromInsteadOfTo + (1-fractionFromInsteadOfTo)*nearestPointOnChildCircleToThat_Y;
		let pointBetweenX = onThisCirclesEdgeX*fractionFromInsteadOfTo + (1-fractionFromInsteadOfTo)*nearestPointOnChildCircleToThat_X;
		//TODO optimize by not calling forward* so many times.
		byteRect.paintLineYXYXRGB(aftrans.forwardY(onThisCirclesEdgeY), aftrans.forwardX(onThisCirclesEdgeX),
			aftrans.forwardY(pointBetweenY), aftrans.forwardX(pointBetweenX), red, green, blue);
		byteRect.paintLineYXYXRGB(aftrans.forwardY(pointBetweenY), aftrans.forwardX(pointBetweenX),
			aftrans.forwardY(nearestPointOnChildCircleToThat_Y), aftrans.forwardX(nearestPointOnChildCircleToThat_X), ch.red, ch.green, ch.blue);
	}
	for(let e=0; e<this.edsOut.length; e++){ //perimeter starts with edgesOut then edsOut
		let i = this.edIndex(e);
		let fromY = this.perimeterY(i);
		let fromX = this.perimeterX(i);
		let toY = this.edsOut[e].y;
		let toX = this.edsOut[e].x;
		byteRect.paintLineYXYXRGB(aftrans.forwardY(fromY), aftrans.forwardX(fromX),
			aftrans.forwardY(toY), aftrans.forwardX(toX), red, green, blue);
	}
};

dagball.circles = [];

dagball.addExampleCircs = function(){
	//pos, vel, velDecay, y, x, r, red, green, blue, isSelected, code, childs
	let dc = dagball.circles;
	/*dc.push(new dagball.Circ('swarm', 0, 0, 0, 0, 0, 20, 255, 0, 0, false, 'javascript:\n//TODO\n', []));
	dc.push(new dagball.Circ('swarm', 0, 0, 0, 70+Math.random()*30, Math.random()*30, 30, 0, 255, 0, false, 'javascript:\n//TODO\n', [dc[0].eDim()]));
	dc.push(new dagball.Circ('swarm', 0, 0, 0, 2+Math.random()*30, 90+Math.random()*30, 40, 0, 0, 255, false, 'javascript:\n//TODO\n', [dc[0].eLike(), dc[1].eLike()]));
	dc.push(new dagball.Circ('swarm', 0, 0, 0, -20+Math.random()*30, 30+Math.random()*30, 140, 120, 120, 80, false, 'javascript:\n//TODO\n', [dc[0].eLike(), dc[2].eLike(),dc[1].eLike()]));
	*/
	dc.push(new dagball.Circ('swarm', 0, 0, 0,   0, 0,                                       1.2,   255, 0, 0, false, 'tinyglsl:\npotenCirc = pow(length(vec2(x+parr[o++],y)),5.);', [], []));
	dc[dc.length-1].replaceEdsWithDefaultsForNVars(5);

	//dc.push(new dagball.Circ('swarm', 0, 0, 0,   .7+Math.random()*.0, Math.random()*.3,      .3,   0, 255, 0, false, 'tinyglsl:\npotenCirc += .1*sin(parr[4]*20.);', [dc[0].eDim()], []));
	//dc.push(new dagball.Circ('swarm', 0, 0, 0,   .7+Math.random()*.0, Math.random()*.3,      .3,   0, 255, 0, false, 'tinyglsl:\npotenCirc += .52*sin(x*3.1);', [dc[0].eDim()], []));
	//dc.push(new dagball.Circ('swarm', 0, 0, 0,   .7+Math.random()*.0, Math.random()*.3,      .3,   0, 255, 0, false, 'tinyglsl:\npotenCirc += .52*sin(x*13.1)+sin(y*y*14.);', [dc[0].eDim()], []));
	dc.push(new dagball.Circ('swarm', 0, 0, 0,   .7+Math.random()*.0, Math.random()*.3,      1.5,   0, 255, 0, false, 'tinyglsl:\npotenCirc += .52*sin(x*13.1*parr[o++])+sin(y*y*14.*parr[o++]);', [dc[0].eDim()], []));
	dc[dc.length-1].replaceEdsWithDefaultsForNVars(3);

	//dc.push(new dagball.Circ('swarm', 0, 0, 0,   .2+Math.random()*.3, .9+Math.random()*.3,   1.2,   0, 0, 255, false, 'tinyglsl:\npotenCirc += .1*pow(length(vec2(parr[1],parr[2])),2.2);', [dc[0].eLike(), dc[1].eLike()], []));
	dc.push(new dagball.Circ('swarm', 0, 0, 0,   .2+Math.random()*.3, .9+Math.random()*.3,   1.2,   0, 0, 255, false, 'txt:\nany words here', [dc[0].eLike(), dc[1].eLike()], []));
	dc[dc.length-1].replaceEdsWithDefaultsForNVars(20);
	
	dc.push(new dagball.Circ('swarm', 0, 0, 0,   -.2+Math.random()*.3, .3+Math.random()*3,   .84,  120, 120, 80, false, 'tinyglsl:\npotenCirc = sin((x*x*parr[o++]*.1-y*y*.1)*33.4);', [dc[0].eLike(), dc[2].eLike(),dc[1].eLike()], []));
	dc[dc.length-1].replaceEdsWithDefaultsForNVars(7);
	
	//dc.push(new dagball.Circ('swarm', 0, 0, 0,   0, 0,                                       .2,   255, 0, 0, false, 'javascript:\n//TODO\n', []));
	//dc.push(new dagball.Circ('swarm', 0, 0, 0,   1, 0,                                       .2,   255, 0, 0, false, 'javascript:\n//TODO\n', []));
};

dagball.addExampleCircs();

dagball.displayCircs = function(optionalByteRect){
	for(let circ of dagball.circles){
		circ.display(optionalByteRect);
	}
};


/*
TODO there should be 2 forms of a primaryKey/pk. One is the prefix of the other cuz doesnt include child ids.
What about odd daglevs? A node whose daglev is odd has exactly 1 parent and 1 child. It exists in GPU code (TODO)
but does not need its own object. It might be just an index in a few arrays of its parent object.
If it has no childs, then its pk can be something like 'y234x5p7r2p5' which means cy is 234, cx is 5.7, and cr is 2.5.
Do I want a name on that like strangeCurveB_y234x5p7r2p5? I could include strings like strangeCurveB in the pk.
Should I use cbor?

//given a primaryKey string, return the dagball.Pk wrapper of it. Multiple calls return the same object, unless its locally deleted,
//and then another call would return a new dagball.Pk and remember that one instead.
dagball.pk = function(pkString){
	let ret = dagball.pks[pkString];
	if(!ret){
		let s = pkString.replace(/p/,'.').replace(/m/,'-'); //get back dots and negatives in numbers in the string
		FIXMEFIXME
		TODO use dagball.sha256HexOfString
		let cy = ;
		ret = dagball.pks[pkString] = new dagball.Pk();
	}
	return ret;
};

//primaryKey
//cr is the radius it can influence/touch things, centered around cy cx.
//toString is pkString so you can use this as js {} key (faster) without needing js Map (slower),
//and look up the object form by dagball.pk(pkString).
//Does not prevent garbcol (garbage collection) of child Pks since stores their string form instead.
dagball.Pk = function(cy, cx, cr, childPks){
	//FIXME include Pk childs, but how to fit the even/odd daglev into that?
	this.cy = cy;
	this.cx = cx;
	this.cr = cr;
	this.childPks = childPks || [];
	this.pkString = ('y'+cy+'x'+cx+'r'+cr).replace(/\./,'p').replace(/-/,'m');
};
dagball.Pk.prototype.toString = function(){
	return this.pkString;
};

//superclass of dagball.Gob and of dagball.Cob and maybe others. Has constant y x red green blue, a variable displayed there on screen,
//with 2 values of position and velocity, and maybe velocityDecay and maybe something about friction but im not super
//if I can do friction (instead of just velocityDecay) at this level. Any algebra equation of curve can be done in Gob shapes.
//dagball.Ob = function(cid, cy, cx, mred, mgreen, mblue){
dagball.Ob = function(circY, circX, mpos, mvel, mveldecay, mred, mgreen, mblue){
	//FIXME should cid wait to be created until subclass. for example, in Gob, theres other fields
	//this.cid = cid || dagball.nextId();
	this.ky = constY; //k means constant. m means mutable.
	this.kx = constX;
	this.mpos = mpos; //mutable position
	this.mvel = mvel; //mutable velocity
	this.mveldecay = mveldecay; //mutable velocityDecay. TODO should mveldecay be global instead of varying per var/dimension?
	this.mred = mred;
	this.mgreen = mgreen;
	this.mblue = mblue;
};

//Lob aka "Leaf OBject". Just a dimension displayed as an icon on screen, varying its brightness to show position value.
//Has no childs. FIXME might just use Ob directly, or a Gob or Cob with no childs?
dagball.Lob = function(){
	//TODO call superclass constructor: dagball.Ob.call();
	//TODO
	
	//this.cid ky kx mred mgreen mblue etc exist from superclass.


};
dagball.inherit(dagball.Lob, dagball.Ob);

//Gob aka "Gpu OBject" aka "gpu circle",
//a constant 2d circle that the GPU code is run in, to affect graphics and ball movement there.
//
//TODO see "verify the code, which may be from untrusted sources, will not crash the game" in dagball.Cob comment, same here.
//
dagball.Gob = function(cy, cx, mpos, mvel, mveldecay, mred, mgreen, mblue){
	//TODO call superclass constructor: dagball.Ob.call();
	//TODO
	dagball.Ob.call(this, cy, cx, mpos, mvel, mveldecay, mred, mgreen, mblue); //superclass constructor
	//dagball.Ob.call(this, cy, cx, dagball.randIntRange(100,220), dagball.randIntRange(100,220), dagball.randIntRange(100,220)); //superclass constructor


	//this.cid ky kx mred mgreen mblue etc exist from superclass.

	this.childIds = []; //in case you dont have them, you can still create a leaf
	this.childs = []; //
};
dagball.inherit(dagball.Gob, dagball.Ob);

//Cob aka "Cpu OBject" aka "cpu circle",
//a constant 2d circle that the CPU code is run in, to affect graphics, such as to write pixels in ByteRect.bytes
//or log to browser console, or other things the GPU doesnt do or is slow at. This normally contains javascript code
//to be evaled (TODO use my cachedEval code from other projects).
//
//TODO verify the code, which may be from untrusted sources, will not crash the game. Limiting it to simple patterns,
//or formalVerifying it using wikibinator203's
//incomplete VarargAx opcode (which is similar to the Coq language and will run in browser) could work,
//but hopefully will find simpler ways to verify simpler patterns of code that still are a flexible in-game editor.
//
dagball.Cob = function(){
	//TODO call superclass constructor: dagball.Ob.call();
	//TODO

	//this.cid ky kx mred mgreen mblue etc exist from superclass.

};
dagball.inherit(dagball.Cob, dagball.Ob);





/*
//name to constant, especially instances of dagball.Circle.
dagball.constants = {
	//TODO
};

//dimension. Each dimension has a target (y,x) coordinate its displayed at,
//is displayed as a circle of varying color,
//its radius is displayed as the same radius as all the other dims which is different than this.affectRadius,
//and it moves as near to the target (y,x) as it can without overlapping other dims,
//so it can be selected with mouseover etc.
//
//A dim has a type (dimtype) of _exists _isInView _normalDimensionVar _input _midport (todo rename those).
//maybe also _gpuCircle. maybe also _literalDataByContentType. maybe also _circJsOutputToByterectAndMaybeAlsoInputFromSomeChilds.
//
//a type _midport.pos is held to the weightedAve of ports connected to eachother thru it.
//The use of _midport is if theres many (m) ports connected to eachother, that all should converge to
//the same scalar, then instead of m*(m-1)/2 connections, there can be m connections to a _midport.
//They all instead leastSquares toward that weightedAve, so its still an energy function.
//
//A dim has a set of child dims (actually a list).
//A dim is a primaryKey and has a mutable scalar value for position and velocity,
//but those scalars can be set by other forest data structures.
//A dim has a position and a velocity. Those "other forest data structures"
//can include setting (or gradually changing toward) both position and velocity
//of other dims reachable lower in forest from it.
dagball.Dim = function(constTargetY, constTargetX, constAffectRadius, constDimtype, constContent, constChilds,
		mutablePosition, mutableVelocity, mutableNearTargetY, mutableNearTargetX, mutableRed, mutableGreen, mutableBlue){
	//TODO make this a bigint like 253453434653n? No, it has to be a valid var name in javascript and in glsl.
	this.id = 'dimIdFixmedontmakethisrandom'+Math.floor(Math.random()*1000000000)+Math.floor(Math.random()*1000000000);
	this.preferredName = null; //null means same as id. preferred value of this.name (which is mutable), but cuz there might be name collisions, this is just preferred. Might add a random suffix if duplicate/collision.

	this.targetY = constTargetY;
	this.targetX = constTargetX;
	this.affectRadius = constAffectRadius;

	//_exists _isInView _normalDimensionVar _input _midport (todo rename those).
	//maybe also _gpuCircle. maybe also _literalDataByContentType. maybe also _circJsOutputToByterectAndMaybeAlsoInputFromSomeChilds.
	this.dimtype = constDimtype;
	
	//TODO this might be a js {}, and for dag hashing purposes is some
	//norming of json (remove all unnecessary whitespace, sort keys, etc?).
	//A groundCircle (scalarfield) has an _exists dim and an _isInView dim and other dims.
	//If it _exists*_isInView is nonzero, then it affects the summed scalarField that much.
	//The json would contain tinyGlslCode for the scalarField,
	//using ids (this.childs[6].childs[2].id for example) as var/dim names.
	this.content = constContent;

	throw 'FIXME should x y dimtype childs tinyGlslCode jsCode inputSource etc all be in the json? everything that goes into the hash is in the json?';

	throw 'FIXME should id be concat(hash,proofOfWorkRecurse)?';

	throw 'FIXME should var names be renamed automatically local to a run of the program and computer, so the glsl code isnt too big and so theyre more human readable? or maybe just write them as: float smallname = dim23453q4534q5234524353452435645645longname345345;?';

	throw 'FIXME make it be all json-compatible. Dim will be [id {immutable parts} {mutable parts}] or maybe {id: id, mut: {...}, immut: {...}}?. id is derived entirely from {immutable parts}. {mutable parts} are mostly this.pos and this.vel and display color and parents Set. The mutable parts can be set (or gradually pushed to chosen values) by an immutable object whose this.content (or is it contentjson contentstring or what field name) that specifies values for those, a kind of dag node thats not a scalar field. Similar to you can put an image/jpeg, text/plain, application/x-wikibinator203 (or what contenttype is it? look in wikibinator203VM.js for that) lambda id, etc. Could write a message to the other players like a chatroom, by adding to the dag. Could hook in local gamepad 3 axis 5, keyboard button j, etc at a dimtype _input dim. etc.';

	this.childs = childs;

	/*As explained here, daglev is even for gpucircles or leafs, odd for the childs of gpucircles,
	and each odd dim has exactly 1 parent and exactly 1 child. So maybe dont need to store them this way. TODO.
	SOLVED: keep the even/odd daglevels. Explained here...
	https://www.facebook.com/groups/dagball/posts/682041283838783
	and here https://twitter.com/DagBallGame/status/1702797377420046593 is a copy of that and link to it.
	*
	this.daglev = 0; //height in DAG. 0 if leaf, else max child daglev + 1.
	for(let child of childs){
		this.daglev = Math.max(this.daglev, child.daglev+1);
	}

	//You can ignore proofOfWork* vars if you want,
	//but they might be useful once the peer to peer massively multiplayer DagBall network scales up.

	//TODO lazyeval proofOfWork* vars? or should id be derived from it?

 	//TODO proofOfWorkRecurse is proofOfWork of this Dim + proofOfWork of each reachable Dim but only counting each once.
	//This is a sum of all dim.proofOfWorkLocal reachable, so this is a number that in the worst case always fits in 320 bits
	//cuz that can hold up to about (2 power 64) dag nodes reachable from the same Dim. TODO make these bigints like 253453434653n?
	this.proofOfWorkRecurse = null;
	
	//TODO proofOfWorkLocal is ceil((2 power 256) divided by (1+sha256AsUint256(utf8(this.id)))), or something like that, TODO.
	//TODO make these bigints like 253453434653n?
	this.proofOfWorkLocal = null; //TODO

	//any small string (or should it be bytes?). TODO what length limit? Should it have to be a number?
	//TODO make these bigints like 253453434653n?
	this.proofOfWorkSalt = null; //TODO






	//IMMUTABLE DAG STUFF ABOVE, MUTABLE BELOW.





	this.pos = mutablePosition;
	this.vel = mutableVelocity;

	this.nearTargetY = mutableNearTargetY;
	this.nearTargetX = mutableNearTargetX;

	this.red = mutableRed; //dagball.randIntRange(100,220);
	this.green = mutableGreen; //dagball.randIntRange(100,220);
	this.blue = mutableBlue; //dagball.randIntRange(100,220);

	//local to this computer and run of the program, not a global id. This is an abbrev of this.id
	//and can be replaced by a human readable name but starts like d1 d32454 etc.
	this.name = dagball.nextId();

	//Set of dagball.Dim instances whose child list includes this.
	this.parents = new Set();

	//This is like "does this exist?", but I dont want to confuse it with the _exists dimtype.
	//This is for the moment it becomes garbage collectible, not the soft removing by gradual scalars.
	//true when each of my childs has child.parents containing this. If this is a leaf (no childs) it can be isInDag or not.
	//Do that when deleting it. Let it be javascript garbage collected.
	//this.isInDag = true;
	this.setIsInDag(true);
};

dagball.Dim.prototype.numDimsReachable = function(){
	if(this.cache_numDimsReachable === undefined){
		throw '1 if leaf. cache in this.cache_numDimsReachable. TODO compute this recursively, counting each reachable only once. This is used for limiting the number of Dims computed in gpu at once which can, in tests so far (not on enuf computers yet) be up to about 1024 or maybe 1010 etc.';
	}
	return this.cache_numDimsReachable;
};

//Starts as true.
//setIsInDag(false) to delete, to make js garbage collectible if you also have no pointers at it.
//You can later call setIsInDag(true) to add it back, if it hasnt been garbage collected yet.
dagball.Dim.prototype.setIsInDag = function(isInDag){
	for(let child of childs){
		if(isInDag){
			child.parents.add(this);
			dagball.nameToDim[this.name] = this;
			dagball.idToDim[this.id] = this;

		}else{
			child.parents.remove(this);
			delete dagball.nameToDim[this.name];
			delete dagball.idToDim[this.id];
		}
		//child.parents[isInDag ? 'add' : 'remove'](this);
	}
	this.isInDag = isInDag;
};

dagball.Dim.prototype.setName = function(newName){
	if(newName != this.name){
		if(dagball.nameToDim[newName] !== undefined){
			throw 'Dim of newName already exists, newName='+newName+' currentName='+this.name;
		}
		delete dagball.nameToDim[this.name];
		dagball.nameToDim[newName] = this;
		this.name = newName;
	}
};












/* Designing things 2023-9-15+...

dimtype: maybe also _gpuCircle. maybe also _literalDataByContentType. maybe also _circJsOutputToByterectAndMaybeAlsoInputFromSomeChilds.


Some types that would go in the dag, but im not sure if dagball.Dim's fields are a good way to represent them...

MidPort:
	the lowest layer. Its pos is held to weightedAve of whatever ports are connected to eachother (trying to be the same scalar pos as eachother).
NumPort:
	bit isInput;
	InPort is an NumPort that can only be read inside dagball, and can be written from outside dagball.
//OutPort:
//	OutPort is an NumPort that can be read and written by dagball, and can only be read from outside dagball. This might just be a normal NumPort?
Player:
	anything outside the DagBall system that can write at least 1 NumPort (especially if that NumPort.isInput is true).
	Which NumPorts are written by which players may be hard to predict since it gets mixed with syncing the game state
	to deal with roundoff-error and chaoticly changing futures depending on small changes in the past. Its a research path.
View:
	Since TinyGLSL has limit of max about 1000 dims/NumPorts in gpu at once, subsets of the game world are updated
	independent of eachother, then gradually synced. View must include
	Cuz of that getting out of sync (in gradual amounts), View should also have the pos and vel of those NumPorts,
	instead of storing it in the NumPorts themselves. Use NumPorts only as 
	GpuCircle[] gpucircs;
	NumPort[up to 1000]  ports;
		//the ports in those gpucircs and maybe also other ports such as aGpuCircle.exists.
	Id like to merge exists and isInView into a single number and do garbcol and caching a different way.
GpuCircle:
	NumPort weight;
		//held equal to isInView*exists. Or maybe this should be the GpuCircle itself as a NumPort/dim
		//since everything has a pos and a vel and maybe also a velocityDecay?
	Map<View,NumPort> isInView;
		//Map<Player,NumPort> isInView;
		This is set by distance to being on screen vs off screen,
		and a little past the screen cuz could get on screen within few seconds.
		This is not set by gradient. Its written by player scrolling around the game world.
		GpuCircle.exists*GpuCircle.isInView*outputNumberFromGpuCircleAtAYX is added to poten.
		There may be 1 isInView object for EACH player viewing the game world,
		and there can be unlimited players, but lets at least simulate it locally
		for 3 players so problems as complex as 3-body can come up in the sync.
		The Map<Player,NumPort> isInView;" size should be at least 3 when testing the sync.
		The multiple isInView for the same GpuCircle should technically be merged into a single isInView
		and all have the same value, but that would break the rule of max 1000 dims/NumPorts in gpu at once.
		Maybe Player is not the right class for this, and should be called View instead.
	NumPort exists;
		From 0 to 1, how much influence this GpuCircle has on the game world when in view.
		GpuCircle.exists*GpuCircle.isInView*outputNumberFromGpuCircleAtAYX is added to poten.
		Since this
	NumPort[] ports;
	defines what to add to poten (potentialEnergy) within its circle, d

Should dag edges have weights? Or is that weight that I want betweeen NumPorts (thru MidPort) just the _exists*_isInView of a GpuCircle?

MidPort <- NumPort <- GpuCircle <- View.
GpuCircle is a NumPort that is thatGpuCircle.weight.
MidPort is weightedAve weighted by what? Value is from NumPort.
	Weight is from the GpuCircle that has that NumPort child, and dividing by total such weights at that NumPort.
	If total weight is 0, that could be a problem for MidPort. Id like to just not calculate that MidPort in that case
	but weights can change with each next TinyGLSL call.
	What I really wanted instead of MidPort is all pairs of
	connected NumPort (like in a group of 5 NumPorts that try to be the same pos value),
	but that still should be affected by weight.
	I dont want to decay those 5 NumPorts toward eachother. I want to do it by poten.
	So define the poten with 2*portsInGroup numbers: weight and pos for each.
	If portsInGroup is 3, thats: weightA posA weightB posB weightC posC.
	What should be added to poten for those 6 vars?
	Or, I could make MidPort not be held to the weightedAve and let it move freely based on the poten added for
	each NumPort whose child that MidPort is (its multiple parents are the NumPorts in that group).
	That way, i dont have to jump 2 hops between MidPort<-NumPort<-GpuCircle
	and can just use MidPort<-NumPort vs NumPort<-GpuCircle separately.
	The problem with that is it adds an extra hop between NumPortJ->MidPort<-NumPortK.
	Also, since 2+ GpuCircles arent supposed to share their NumPorts, should that also be true for A GpuCircle
	that is the parent of another GpuCircle (its weight, which would be itself as a port)?
	GpuCircleM<-NumPort<-GpuCircleN, instead of GpuCircleM<-GpuCircleN.
	That makes sense. Regardless of its daglev,
	every scalar field object (including GpuCircle and maybe other types too) should have ports at 2 daglevs,
	self and self-1. So divide daglev into evens and odds. Leafs go at daglev0.
	The first layer of GpuCircs have their exists/selfGpuCircItsOneVarOfPosAndVel ports at daglev2,
	and has its direct childs at daglev1.
	Above that, childs can skip levels as long as they point at an odd daglev thats a lower daglev than self.
	Each node at odd daglev is part of a node at its daglev+1 and is not part of any other node
	and cant have incoming pointers from any other node.
	GpuCircleM<-GpuCirclePChild8<-GpuCircleP.
	GpuCircleM<-GpuCircleNChild5<-GpuCircleN.
	Pos and vel has to be stored separately GpuCirclePChild8 vs GpuCircleNChild5
	even if they're supposed to be the same value or converge toward the same value (that value being GpuCircleM).
	Between a node at odd daglev and its parent, their values dont directly affect eachother.
	Between a node at even daglev and its parent, if that even number is 0 (is lowest daglev) then they should
	be pushed (by defining scalarfield to be lower when they are near in value) to be nearer in value.
	BUT if that even number is not 0 (is 2 4 28 etc, and its parent at 3 5 29 etc),
	then Im undecided if they should be pushed together or not.
	The other option (than pushing together) is to copy the even node to its parent odd node
	and let the even node above that (so 2 higher) add to poten so the only writing to
	the lower even node is thru gradient. Nodes should only be written by gradient.
	GpuCircleR is its weight and ranges 0 to 1. GpuCircleR(gameStateS) is what it wants to add to poten,
	maybe scaled by const*tanh(val/const) which approx equals val when val is small.
	GpuCircleR*GpuCircleR(gameStateS) is whats actually added to poten.
	Im uncertain if I need the even/odd daglevel system.

	The leafs (MidPorts) dont add to poten. Poten changes them by gradient.

	If all GpuCircle weights are 1, then the pulling vars together is easy.
	When those weights differ, among multiple GpuCircles above the same vars,
	that makes it harder to define the scalarfield.

	A GpuCircle can child point at multiple daglevs below it at once,
	so could include a leaf/daglev0 and a daglev2 in its childs for example.


	SOLVED: keep the even/odd daglevels. Explained here...
	https://www.facebook.com/groups/dagball/posts/682041283838783
	and here https://twitter.com/DagBallGame/status/1702797377420046593 is a copy of that and link to it.





*/











































/*
dagball.circ = function(cy, cx, cr){
	throw 'TODO';
};

dagball.Circle = function(cy, cx, cr, optionalChilds){
	this.name = nameOfCircle(cy,cx,cr);
	this.cy = cy;
	this.cx = cx;
	this.cr = cr;
	this.childs = optionalChilds || [];
	for(let child of this.childs){
		if(!this.fitsIn(child)){
			throw 'This circle '+this+' does not fit in child circle '+child;
		}
	}
};
//this.name so it can be used as key in js {} maps which are faster than js Map.
dagball.Circle.prototype.toString = function(){
	return this.name;
};
dagball.Circle.prototype.centerDist = function(circ){
	return Math.hypot(this.cy-circ.cy, this.cx-circ.cx);
};
dagball.Circle.prototype.fitsIn = function(outerCirc){
	return (outerCirc.cr >= (this.centerDist(outerCirc)+this.cr));
};

//primaryKey of a 
dagball.nameOfCircle = (cy,cx,cr)=>(('Y'+cy+'X'+cx+'R'+cr).replace(/-/g,'m').replace(/\./g,'p'));

//DAG data nodes (hash forest) are layer0. layer1 is Dim (primaryKey is constant circle). layer2 is Ground. layer3 is moving stuff such as balls.

//layer1. //DAG data nodes (hash forest) are layer0. layer1 is Dim (primaryKey is constant circle). layer2 is Ground. layer3 is moving stuff such as balls.
//a dimension that has position (p), velocity (v), velocityDecay (d), chance (q),
//constantYCenter (cy), constantXCenter (cx), constantRadius (cr).
//Chance that it exists, 0 to 1, or weightedsum gradually.
//PrimaryKey is [cy,cx,cr]. The others are mutable.
//dagball.Dim = function(cy, cx, cr){
dagball.Dim = function(circ){
	//this.name = dagball.nameOfCircle(cy,cx,cr); //primaryKey
	this.circ = circ;
	this.cy = cy; //constant y center
	this.cx = cx; //constant x center
	this.cr = cr; //constant radius that it can directly be read and written within
	this.p = 0; //position
	this.v = 0; //velocity
	this.vd = 0; //velocity decay
	this.chance = 1; //chance/weight, range 0 (dont include this Dim in the game) to 1 (include this dim) gradually.
};

//layer2. //DAG data nodes (hash forest) are layer0. layer1 is Dim (primaryKey is constant circle). layer2 is Ground. layer3 is moving stuff such as balls.
dagball.Ground = function(circ){
	this.circ = circ;
	this.beforeCode = ''; //tinyGlslBeforeCode
	this.code = ''; //tinyGlslCode
	this.chance = 1; //chance/weight, range 0 (dont include this Dim in the game) to 1 (include this dim) gradually.
};

//layer3. //DAG data nodes (hash forest) are layer0. layer1 is Dim (primaryKey is constant circle). layer2 is Ground. layer3 is moving stuff such as balls.
dagball.Ball = function(){
	throw 'TODO';
	this.chance = 1; //chance/weight, range 0 (dont include this Dim in the game) to 1 (include this dim) gradually.
};
*/


dagball.Game = function(nGlo, nCurve, nBall, mBall, tinyGlslCurveCode){
	this.nGlo = nGlo; //number of global vars
	this.nCurve = nCurve; //number of heightmap curve vars. Must be at least 2. Should be higher so theres room to move around.
	//this.Glo = 0; //number of global vars
	this.nBall = nBall; //number of balls
	//Number of vars per ball. The first 2 vars are y and x position, usually within a circle of radius 1 but could go farther, TODO.
	//TODO have vars for red green blue radius andOr other things you in my "bobaga ball overheats" small experimental game?
	this.mBall = mBall;
	this.tinyGlslCurveCode = tinyGlslCurveCode;// || 'ret = 0.; //flat energy function. TODO replace this.';
	if(this.oEnd() > 1010){
		throw this.oEnd()+'==this.oEnd() dimensions wont fit in uniform/constant memory (the fastest) in tinyGlsl if its bigger than around 1024 (not sure where exact limit is, and that may vary across computers, TODO test that)';
	}
	this.pos = new Float32Array(this.oEnd());
	this.vel = new Float32Array(this.pos.length);
	//this.floatEpsilon = 2**-8;
	this.floatEpsilon = 2**-6;
	this.displayBallTrails = false;

	//TODO when counting time using .now in the performance object (see my other code). this.estimateFPS = 60; //estimate frames per second. Goal is 60 FPS to match HDMI screens, but this will update live.
	//this.estimateFPS_decay;
	this.countNextState = 0;
};

dagball.Game.prototype.randomizePos = function(){
	//TODO merge duplicate code between randomizePos and randomizeVel
	let oBall = this.oBall();
	let endOBall = oBall+this.nBall*this.mBall;
	for(let i=0; i<this.pos.length; i++){
		let isBallRange = oBall <= i && i < endOBall;
		//let mul = isBallRange ? .03 : .4;
		let mul = isBallRange ? .2 : .7;
		this.pos[i] = (Math.random()*2-1)*mul;
	}
};

dagball.Game.prototype.randomizeVel = function(){
	//TODO merge duplicate code between randomizePos and randomizeVel
	let oBall = this.oBall();
	let endOBall = oBall+this.nBall*this.mBall;
	for(let i=0; i<this.vel.length; i++){
		let isBallRange = oBall <= i && i < endOBall;
		let mul = isBallRange ? .05 : .5;
		this.vel[i] = (Math.random()*2-1)*mul;
	}
};

//Game.prototype.randomizeVel = function(){
//};

dagball.Game.prototype.tinyGlslBeforeCode = function(funcName){
	let beforeCode = '';
	if(funcName != 'potentialEnergiesForGradient'){
		beforeCode += '#define parr par'; //so dont have to copy par array to parr array when not modifying it.
	}
	return beforeCode;
};

//funcName can be 1 of: 'potentialEnergiesForGradient' or 'potentialEnergiesForDisplay'
//If dagball.doPhysicsAndGraphicsFromGpuCodeInCircsElseTheExampleGpuCode then this returns from dagball.View.mergedGpuCode, else its an example code.
dagball.Game.prototype.tinyGlslCode = function(funcName){
	let tinyGlslCurveCode = dagball.doPhysicsAndGraphicsFromGpuCodeInCircsElseTheExampleGpuCode ? dagball.view.mergedGpuCode : this.tinyGlslCurveCode;
	//FIXME also change this.nCurve this.nBall etc depending on this.View. Maybe dagball.View is becoming the new dagball.Game object?

	//let line = '\n		';
	let code =
		`//TODO make some vars here.
		//ids will be this.oEnd()+1 cuz this.oEnd() is number of dimensions of the potentialEnergy scalarField.
		const int oGlo = ${this.oGlo()};
		const int oCurve = ${this.oCurve()};
		const int nCurve = ${this.nCurve}; //FIXME update this in dagball.updateView()?
		const int oBall = ${this.oBall()};
		const int nBall = ${this.nBall};
		const int mBall = ${this.mBall};
		const int oEnd = ${this.oEnd()};
		const float floatEpsilon = ${this.floatEpsilon};
		float potenOne = 0.; //potential energy of n dimensional heightmap from current ball or pixel
		float potenSum = 0.; //sum of potenOne.;
		int o = oCurve;
		`
	if(funcName == 'potentialEnergiesForGradient'){
		code +=
			`float parr[oEnd]; //for potentialEnergy. each GPU thread adds epsilon to 1 dimension of this, except highest id (oEnd) is neutral.
			for(int p=0; p<oEnd; p++){
				parr[p] = par[p];
				if(p == id) parr[p] += floatEpsilon;
			}
			for(int b=0; b<nBall; b++){
				int ob = oBall+b*mBall;
				float y = parr[ob++]; //dagball coordinates, unlike idy idx idh idw which are pixel/tinyGlsl coordinates.
				float x = parr[ob++];
				potenOne = 0.;
				//START tinyGlslCurveCode for potentialEnergiesForGradient
				${tinyGlslCurveCode}
				//END tinyGlslCurveCode for potentialEnergiesForGradient
				potenSum += potenOne;
			}
			ret = potenSum;
			//TODO loop over balls, computing height at each. then loop over all pairs of balls and do bounce/repel. Return potentialEnergy.
			`;
	}else if(funcName == 'potentialEnergiesForDisplay'){
		//throw 'TODO get pixel from idy idx idh idw.'
		/*
		dagball.SimpleAftrans.prototype.reverseY = function(forwardY){
			//FIXME?
			//forwardY return this.addY+this.magnifyY*y;
			return (forwardY-this.addY)/this.magnifyY;
		};
		dagball.SimpleAftrans.prototype.reverseX = function(forwardX){
			//FIXME?
			//forwardX return this.addX+this.magnifyX*x;
			return (forwardX-this.addX)/this.magnifyX;
		};*/
		let af = dagball.aftrans;
		code +=
			`//FIXME move the aftrans numbers into nGlo/oGlo vars or parr vars so dont have to recompile GPU code to move them.
			//FIXME use a prefix for built-in vars so they dont overlap user created vars
			//float yScreenFraction = float(idy)/float(idh);
			//float xScreenFraction = float(idx)/float(idw);
			const float afAddY = ${dagball.jsNumToGlslFloat(af.addY)};
			const float afAddX = ${dagball.jsNumToGlslFloat(af.addX)};
			const float afMagnifyY = ${dagball.jsNumToGlslFloat(af.magnifyY)};
			const float afMagnifyX = ${dagball.jsNumToGlslFloat(af.magnifyX)};
			//float y = (yScreenFraction-afAddY)/afMagnifyY; //dagball.aftrans.reverseY
			//float x = (xScreenFraction-afAddX)/afMagnifyX; //dagball.aftrans.reverseX
			float y = (float(idy)-afAddY)/afMagnifyY; //dagball.aftrans.reverseY
			float x = (float(idx)-afAddX)/afMagnifyX; //dagball.aftrans.reverseX
			//float y = float(idy)/float(idh)*2.-1.; //screen y coordinate in range -1 to 1. OLD. These are not dagball or screen coordinates, but FIXME the example GPU code depends on them. Converting to dagball coordinates anyways.
			//float x = float(idx)/float(idw)*2.-1.; //screen x coordinate in range -1 to 1. TODO height/width ratio other than 1.
			//START tinyGlslCurveCode for potentialEnergiesForDisplay
			${tinyGlslCurveCode}
			//END tinyGlslCurveCode for potentialEnergiesForDisplay
			ret = potenOne;
			`;
	}else{
		throw 'Unknown funcName='+funcName;
	}
	return code;
};

//offset of nGlo vars. These vars include at least const1 y x, so must be at least those 3.
dagball.Game.prototype.oGlo = function(){
	return 3;
};

//offset of nCurve vars.
dagball.Game.prototype.oCurve = function(){
	return this.oGlo()+this.nGlo;
};

//offset of nBall*mBall vars.
dagball.Game.prototype.oBall = function(){
	return this.oCurve()+this.nCurve;
};

//number of vars
dagball.Game.prototype.oEnd = function(){
	return this.oBall()+this.nBall*this.mBall;
};

//returns a Float32Array(height*width). You might want to sigmoid them then display as brightnesses,
//or you might want to compare each float to the float down and to the float right and display that 2d vector
//in 2 or 3 colors (see complexnum graphics, for example). You'll get more precision by displaying the 2d angle
//than the float directly.
dagball.Game.prototype.potentialEnergiesForDisplay = function(height, width){
	return tinyGlsl.simple(this.tinyGlslBeforeCode('potentialEnergiesForDisplay'),
		this.tinyGlslCode('potentialEnergiesForDisplay'), this.pos, height, width);
};

//returns this.pos.length+1 potentialEnergies. Index n uses this.pos[n]+this.floatEpsilon if n==id, else just this.pos[n],
//where 0 <= id <= this.pos.length, and the last id (this.pos.length) is neutral with no floatEpsilon.
//This is for calculus in gradient func.
dagball.Game.prototype.potens = function(){
	let potensSize = this.pos.length+1;
	return tinyGlsl.simple(this.tinyGlslBeforeCode('potentialEnergiesForGradient'),
		this.tinyGlslCode('potentialEnergiesForGradient'), this.pos, 1, potensSize);
};

//returns a Float32Array(this.pos.length). Calls tinyGlsl (GPU) with this.pos.length+1 threads.
//The last thread is neutral, that is subtracted from each dimension with position + this.floatEpsilon,
//before dividing by this.floatEpsilon (calculus basics). Each GPU thread computes potentialEnergy
//at a combo of positions of all the balls each on the n dimensional heightmap,
//and the heightmap movies by epsilon too, each of those dimensions +0 or +this.floatEpsilon.
dagball.Game.prototype.gradient = function(){
	//if(this.pos.length > 1010){
	//	No, this is for output, which can be bigger, maybe up to 16k y and 16k x? Its the inputs
	//	throw this.pos.length+'==this.pos.length dimensions wont fit in uniform/constant memory (the fastest) in tinyGlsl if its bigger than around 1024 (not sure where exact limit is, and that may vary across computers, TODO test that)';
	//}
	let potensSize = this.pos.length+1;
	//let potens = tinyGlsl.simple(this.tinyGlslCode('potentialEnergiesForGradient'), this.pos, 1, potensSize);
	let potens = this.potens(); //GPU optimized
	let gradient = new Float32Array(this.pos.length);
	let neutralPoten = potens[potensSize-1];
	for(let i=0; i<this.pos.length; i++){
		gradient[i] = (potens[i]-neutralPoten)/this.floatEpsilon;
	}
	return gradient;
};

//updates this.pos (high dimensional position) and this.vel (high dimensional velocity). dt is change in time, or might arbitrarily choose .01 etc (FIXME).
dagball.Game.prototype.doPhysics = function(dt){
	let gradient = this.gradient();
	let velocityDecayPerSecond = 2.3; //FIXME make this either one of oGlo vars or Game.velocityDecayPerSecond
	//let velocityDecayPerSecond = .1; //FIXME make this either one of oGlo vars or Game.velocityDecayPerSecond
	//let velocityDecayPerSecond = .3; //FIXME make this either one of oGlo vars or Game.velocityDecayPerSecond
	//let velocityDecayPerSecond = .6; //FIXME make this either one of oGlo vars or Game.velocityDecayPerSecond
	//let velocityDecayPerSecond = 1.2; //FIXME make this either one of oGlo vars or Game.velocityDecayPerSecond
	//let velocityDecayPerSecond = 0; //FIXME should be more than 0. FIXME make this either one of oGlo vars or Game.velocityDecayPerSecond
	let velMul = 1-dt*velocityDecayPerSecond;
	//let gradientMul = 1; //this is the correct way, but for experimenting im increasing it
	//let gradientMul = 3;
	let gradientMul = 2;
	//let gradientMul = .3;
	//let gradientMul = 5;
	//let gradientMul = 15; //this is the correct way, but for experimenting im increasing it
	//let gradientMul = 1000000000; //FIXME should be 1
	for(let i=0; i<this.pos.length; i++){
		this.vel[i] -= dt*gradient[i]*gradientMul;
		this.vel[i] *= velMul;
		this.pos[i] += dt*this.vel[i];
		//TODO energy norm. kinetic + potential should be constant. adjust velocity to cause that.
		//FIXME should potentialEnergy be negative?
		//FIXME what if kineticEnergy is so big, cuz of stepping discretely instead of continuously,
		//that potentialEnergy of 0 cant make kinetic+potential be constant?
	}
};

dagball.Game.prototype.paintOntoByteRect = function(byteRect){
	let potens = this.potentialEnergiesForDisplay(byteRect.height, byteRect.width);
	//console.log('potens[0] = '+potens[0]);
	//console.log('potens[5] = '+potens[5]);
	//console.log('potens[25678] = '+potens[25678]);
	let brightness = 0; //default is 0. contrast and brightness like on a screen
	let contrast = 1.5; //default is 1.
	for(let y=0; y<byteRect.height; y++){
		for(let x=0; x<byteRect.width; x++){
			let i = y*byteRect.width+x;
			//potens[i] = Math.random();
			let byte = Math.max(0, Math.min(dagball.sigmoid(brightness+contrast*potens[i])*256, 255));
			let by = i<<2;
			byteRect.bytes[by+RED] = byte;
			byteRect.bytes[by+GREEN] = byte;
			byteRect.bytes[by+BLUE] = byte;
			byteRect.bytes[by+ALPHA] = 255; //visible, not transparent
		}
	}

	if(dagball.isDisplayCircs){
		//todo also aftrans param
		dagball.displayCircs(byteRect);
	}


	let oBall = this.oBall(); //balls start at this index in this.pos
	//this.nBall is number of balls. this.mBall is vars per ball.
	for(let b=0; b<this.nBall; b++){
		let o = oBall+b*this.mBall;
		//let y = (.5+.5*this.pos[o])*byteRect.height;
		//let x = (.5+.5*this.pos[o+1])*byteRect.width;
		let y = dagball.aftrans.forwardY(this.pos[o]);
		let x = dagball.aftrans.forwardX(this.pos[o+1]);
		let radius = dagball.defaultIconRadius; //in pixels. TODO make that one of the ball vars (that increases this.mBall)?
		//defaultBallColor* is for bytRectTrail to match where the balls are, so only trail those,
		//but FIXME later Ill want multiple ball colors, maybe even changing their colors depending on game state.
		let redByte = dagball.defaultBallColorRed;
		let greenByte = dagball.defaultBallColorGreen;
		let blueByte = dagball.defaultBallColorBlue;
		//byteRect.paintCircleRadiusYXRGBSafe(radius, y, x, redByte, greenByte, blueByte);
		byteRect.paintDonut(y, x, 0, radius, redByte, greenByte, blueByte); //whole circle
	}

	dagball.update_estimateFPS(); //FIXME move this into a nextstate func, instead of paint func?

	dagball.updateGamepadsEtc();

	dagball.doDisplayLogs();
	let displayLogs = document.getElementById('displayLogs');
	let overCanvas = document.getElementById('overCanvas');
	overCanvas.style.top = displayLogs.clientHeight+'px'; //move text editor etc to just below displayLogs, on left of screen.
	//overCanvas.style.height = (window.innerHeight - displayLogs.clientHeight) + 'px';
	//let pixelsTextareaIsBelowBottomOfScreen = 0;
	//let pixelsTextareaIsBelowBottomOfScreen = 5;
	//let pixelsTextareaIsBelowBottomOfScreen = -3;
	let pixelsTextareaIsBelowBottomOfScreen = -15;
	overCanvas.style.height = (window.innerHeight - displayLogs.clientHeight + pixelsTextareaIsBelowBottomOfScreen) + 'px';
	//overCanvas.style.height = '200px';
};

//TODO since theres circ.isSelected, there could be multiple of them selected, maybe for bulk changes? If circ is null, unselect all. Unselects all except the given circ.
dagball.setSelectedCirc = function(circ){
	dagball.circles.forEach(c=>{ c.isSelected = (circ==c); });
};

//choose nearby circs (of at most 1000 total vars each, todo hopfield-without-storing-derived-from-distance-weights constraint solver by priority-vote-per-circ to make there be at most 1000 numGpuUniformVars in View)
//and they will become the potentialEnergy gradient for physics and potentialEnergy for graphics.
//This should cause those circs to be displayed instead of the example GPU code that dagball.game.tinyGlslCurveCode starts as, IF dagball.doPhysicsAndGraphicsFromGpuCodeInCircsElseTheExampleGpuCode.
dagball.updateView = function(){
	dagball.view = new dagball.View(dagball.circles.slice());
	//dagball.view = new dagball.View(dagball.circles.filter(c=>c.isSelected));
};

//a list of dagball.Circs that are merged in GPU to a single GPU code (use tinyGlsl.simple) to paint screen and compute potentialEnergy gradient.
dagball.View = function(circs){
	this.circs = circs;
	this.mergedGpuCode = 'TODO mergedGpuCode';
	this.numGpuUniformVars = null; //readOnly parr array.
	this.numGpuLocalVars = null; //read and write. TODO add this parallel to the parr array.
	this.updateLocalFields(); //updates this.mergedGpuCode, this.numGpuUniformVars, this.numGpuLocalVars, etc.
};
dagball.View.prototype.hasGpuCode = function(circ){
	return circ.text.toLowerCase().startsWith('tinyglsl:');
};

dagball.View.prototype.removeUpToFirstColon = function(str){
	let i = str.indexOf(':');
	if(i == -1) return str;
	return str.substring(i+1);
};
dagball.View.prototype.updateLocalFields = function(){
	let numGpuUniformVars = 0;
	let numGpuLocalVars = 0; //FIXME
	let n = '\n		';
	let mergedGpuCode = '//merging up to '+this.circs.length+' GPU codes (some might not contain GPU code so not appear below)...';
	for(let circ of this.circs){
		if(this.hasGpuCode(circ)){
			//FIXME todo numGpuLocalVars
			mergedGpuCode += n+"circY = "+dagball.jsNumToGlslFloat(circ.y)+";";
			mergedGpuCode += n+"circX = "+dagball.jsNumToGlslFloat(circ.x)+";";
			mergedGpuCode += n+"circR = "+dagball.jsNumToGlslFloat(circ.r)+";";
			mergedGpuCode += n+"circInfluence = "+dagball.jsNumToGlslFloat(circ.influence)+";";
			mergedGpuCode += n+'circWindow = (length(vec2(circY-y,circX-x))<circR ? 1. : 0.); //FIXME smoother near edges';
			//mergedGpuCode += n+'circWindow = 1.; //FIXME';
			mergedGpuCode += n+'potenCirc = 0.; //in case user code uses += or doesnt set it.';
			let nextCircO = numGpuUniformVars + circ.edsOut.length;
			mergedGpuCode += n+`o = ${numGpuUniformVars}; //next circ starts at ${nextCircO}. index in parr array this circ starts. You can use parr[o++] multiple times, for example.`;
			mergedGpuCode += n+this.removeUpToFirstColon(circ.text); //FIXME isolate them in {...} or something. Do basic checks on them. TODO prevent some code from breaking other code. Its still webgl sandboxed in browser either way, unless u run it outside browser somehow.
			mergedGpuCode += n+'potenOne += circInfluence*circWindow*potenCirc; //potenSum is all balls. potenOne is inner loop of potentialEnergy. potenCirc is part of that inner loop for a specific circ. circ GPU code should set potenCirc, not those other vars.';
			numGpuUniformVars = nextCircO;
			
			//TODO more vars here, maybe some combo of potenOne, potenSum, o, parr[o++], etc?
			
		}
	}
	this.numGpuUniformVars = numGpuUniformVars;
	this.numGpuLocalVars = numGpuLocalVars; //FIXME
	this.mergedGpuCode = mergedGpuCode;
};

dagball.Game.prototype.nextState = function(dt){
	this.countNextState++;
	//document.getElementById('countNextState').innerHTML = this.ptr()+'.countNextState='+this.countNextState;
	//affects doPhysics and paintOntoByteRect by changing dagball.view to some list of nearby circles
	//that each may have their own GPU code to merge into a combined GPU code to tinyGlsl.simple together.
	dagball.updateView();
	this.doPhysics(dt); //TODO more physics cycles than 1 per video frame? Check how fast it is first.
	this.pos[this.oBall()] = dagball.controls('mouseY') || 0; //move first ball to mouse
	this.pos[this.oBall()+1] = dagball.controls('mouseX') || 0;
	if(!dagball.screen){
		dagball.screen = new FullScreenCanvas(dagball.bootCanvasHeight, dagball.bootCanvasWidth);
		//dagball.aftrans = new dagball.SimpleAftrans(dagball.screen.byteRect.height/2, dagball.screen.byteRect.width/2, 1, 1)
		dagball.aftrans = new dagball.SimpleAftrans(dagball.screen.byteRect.height/2, dagball.screen.byteRect.width/2, 100, 100)
		let canvas = dagball.screen.dom;
		canvas.style.display = 'block';
		canvas.style.transformOrigin = '0 0';
		canvas.style.position = 'absolute';
		canvas.style.top = '0';
		canvas.style.left = '0';
		canvas.setAttribute('tabIndex', 0); //make canvas focusable
		dagball.canvasScaleY = window.innerHeight/canvas.height;
		dagball.canvasScaleX = window.innerWidth/canvas.width;
		canvas.style.transform = `scaleX(${dagball.canvasScaleX}) scaleY(${dagball.canvasScaleY})`;
		window.addEventListener('resize', () => {
			canvas.style.transform = `scaleX(${window.innerWidth / canvas.width}) scaleY(${window.innerHeight / canvas.height})`;
		});




		//dagball.screen.dom
		//FIXME what if its not resized to screen size yet (does that happen in beforePaint or afterPaint instead?)?
		dagball.byteRectTrail = dagball.screen.byteRect.copy();
		//let canv = dagball.screen.dom;
		let mousemove = event=>{
			//dagball.directControls.mouseY = (event.clientY/canv.height/dagball.canvasScaleY)*2-1; //approx range -1 to 1 but might go outside
			//dagball.directControls.mouseX = (event.clientX/canv.width/dagball.canvasScaleX)*2-1; //approx range -1 to 1 but might go outside
			//dagball.directControls.mouseY = event.clientY/dagball.canvasScaleY;
			//dagball.directControls.mouseX = event.clientX/dagball.canvasScaleX;
			dagball.directControls.mouseY = dagball.aftrans.reverseY(event.clientY/dagball.canvasScaleY);
			dagball.directControls.mouseX = dagball.aftrans.reverseX(event.clientX/dagball.canvasScaleX);
			/*moving this to afterEveryDomEvent if(!dagball.selectLock() && !dagball.isTextEditing()){ //FIXME merge selectLock with isTextEditing? They're tangled 2023-9-24.
				dagball.setSelectedCirc(dagball.uiCircNearYXElseNull(dagball.directControls.mouseY, dagball.directControls.mouseX));
			}*/
			//console.log('focusing on event.target='+event.target);

			
			//dont do this cuz 2023-9-27 changing to mouse left click on canvas switches modes. if(!dagball.selectLock()){
			//	event.target.focus(); //focus on whatever mouse is over, so keyboard controls work differently when mouse is over textarea vs over canvas
			//}

			//let mainEditTextarea = document.getElementById('mainEditTextarea');
			//if(event.target != mainEditTextarea) mainEditTextarea.blur(); //unfocus, so it doesnt keep getting typed into when mouse is over circles in canvas editing them with keyboard buttons
			dagball.afterEveryDomEvent(event);
		};
		let displayLogs = document.getElementById('displayLogs');
		displayLogs.addEventListener('mousemove', mousemove);
		canvas.addEventListener('mousemove', mousemove);
		let mousedown = event=>{
			dagball.directControls['mouseButton'+event.button] = 1;
			dagball.afterEveryDomEvent(event);
		};
		displayLogs.addEventListener('mousedown', mousedown);
		canvas.addEventListener('mousedown', mousedown);
		let mouseup = event=>{
			dagball.directControls['mouseButton'+event.button] = 0;
			dagball.afterEveryDomEvent(event);
		};
		displayLogs.addEventListener('mouseup', mouseup);
		canvas.addEventListener('mouseup', mouseup);
		let keydown = function(event){
			dagball.directControls[event.key] = 1;
			dagball.afterEveryDomEvent(event);
		};
		displayLogs.addEventListener('keydown', keydown);
		canvas.addEventListener('keydown', keydown);
		let keyup = function(event){
			dagball.directControls[event.key] = 0;
			dagball.afterEveryDomEvent(event);
		};
		displayLogs.addEventListener('keyup', keyup);
		canvas.addEventListener('keyup', keyup);
		//canv.dom.addEventListener('contextmenu', event=>event.preventDefault()); //prevent right click popup menu from canvas
	}
	dagball.screen.beforePaint();
	this.paintOntoByteRect(dagball.screen.byteRect);
	if(dagball.screen.byteRect.bytes.length != dagball.byteRectTrail.bytes.length){
		//FIXME copy that func in ByteRect thats something like "is same size as (param byterect) from my other code"
		throw 'Diff ByteRect sizes';
	}
	if(this.displayBallTrails){
		//let h = dagball.screen.byteRect.height;
		//let w = dagball.screen.byteRect.width;
		//let by = h*w*4; //number of bytes per ByteRect. Should equal byteRect.bytes.length
		let byMain = dagball.screen.byteRect.bytes;
		let byTrail = dagball.byteRectTrail.bytes;
		for(let i=0; i<byMain.length; i+=4){
			let isMainDefaultBallColor = (byMain[i+RED]==dagball.defaultBallColorRed) &&
				(byMain[i+GREEN]==dagball.defaultBallColorGreen) && (byMain[i+BLUE]==dagball.defaultBallColorBlue);
			let isTrailDefaultBallColor = (byTrail[i+RED]==dagball.defaultBallColorRed) &&
				(byTrail[i+GREEN]==dagball.defaultBallColorGreen) && (byTrail[i+BLUE]==dagball.defaultBallColorBlue);
			if(isMainDefaultBallColor || isTrailDefaultBallColor){
				byMain[i+RED] = byTrail[i+RED] = dagball.defaultBallColorRed;
				byMain[i+GREEN] = byTrail[i+GREEN] = dagball.defaultBallColorGreen;
				byMain[i+BLUE] = byTrail[i+BLUE] = dagball.defaultBallColorBlue;
			}
		}
	}
	dagball.screen.afterPaint();
	dagball.afterAfterPaint();

	dagball.changeGameStateByInputControls(); //uses dagball.controlChange('mouseY') and dagball.controlChange('moveView') etc.
	if(dagball.makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest){
		let i = 1;
		let time = dagball.time(); //UTC seconds
		for(let dimOut of dagball.sortedKeys(dagball.directControlsOut)){
			if(dagball.isGamepadRumbleDimName(dimOut)){
				let freq = 1/(i++);
				let strengthFraction = .5+.5*Math.sin(2*Math.PI*freq*time); //chatgpt4 says range should be 0 to 1
				if(dimOut.includes('_weakRumble')){
					strengthFraction *= dagball.makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest_maxWeakRumbleStrength;
				}
				if(dimOut.includes('_strongRumble')){
					strengthFraction *= dagball.makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest_maxStrongRumbleStrength;
				}
				dagball.directControlsOut[dimOut] = strengthFraction;
				console.log('makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest test rumbling dim='+dimOut+' strengthFraction='+strengthFraction);
			}
		}
	}
	dagball.update_prev_directControls();
	/*
	if(canv == null){
		canv = new FullScreenCanvas();
		canv.dom.addEventListener('mousemove', event=>{
			controls.mouseYCell = Math.max(0, Math.min(Math.floor(event.clientY/pixelsPerCell), rule110SquareSide-1));
			controls.mouseXCell = Math.max(0, Math.min(Math.floor(event.clientX/pixelsPerCell), rule110SquareSide-1));
		});
		canv.dom.addEventListener('mousedown', event=>{
			controls['mouseButton'+event.button] = 1;
		});
		canv.dom.addEventListener('mouseup', event=>{
			controls['mouseButton'+event.button] = 0;
		});
		canv.dom.addEventListener('contextmenu', event=>event.preventDefault()); //prevent right click popup menu from canvas, so that button paints black instead
	}
	let now = time();
	let age = now-timeStarted;
	let dt = Math.max(0, Math.min(now-prevTime, .2));
	prevTime = now;
	canv.beforePaint();
	doPageTransitioningGraphics(dt, age, canv.byteRect);
	canv.afterPaint();
	setTimeout(nextState, 1);
	*/
};
//pointer to me, kind of. Javascript code that evals to this existing Game object, or throws if unknown.
dagball.Game.prototype.ptr = function(){
	if(dagball.game != this) throw 'Where is this Game?';
	return 'dagball.game';
};

var between = (min,x,max)=>Math.max(min,Math.min(x,max));

//modified https://github.com/benrayfield/jsutils/blob/master/src/FullScreenCanvasPrototype.html
var FullScreenCanvas = function(optionalHeight, optionalWidth, optionalParentDom){ //FullScreenCanvas opensource MIT licensed by Ben F Rayfield
	let parentDom = optionalParentDom  || document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	this.dom.style.position = 'absolute';
	this.dom.style.left = '0px';
	this.dom.style.top = '0px';
	
	//else uses window size. FIXME also 
	this.resizeCanvas = function(optionalHeight, optionalWidth){
		let targetHeight = optionalHeight || window.innerHeight;
		let targetWidth = optionalWidth || window.innerWidth;
		if(this.dom.height != targetHeight) this.dom.height = targetHeight;
		if(this.dom.width != targetWidth) this.dom.width = targetWidth;
	};
	
	//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	//FIXME reuse some of these vars. might be slowing it down doing getContext and imageData every time, for example,
	//but careful with that cuz canvas doesnt update if you do this wrong.
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		
		//this.context = this.dom.getContext('2d');
		//cuz got this warning 2023-9-2: ForestCurveFit004.html:1503 Canvas2D: Multiple readback operations using getImageData
		//are faster with the willReadFrequently attribute set to true.
		//See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
		this.context = this.dom.getContext('2d', {willReadFrequently: true});

		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw 'No canvas';
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas(optionalHeight, optionalWidth);
	this.beforePaint();
};

var ByteRect = (()=>{
	let ByteRect = function(bytes, height, width){ //ByteRect opensource MIT licensed by Ben F Rayfield (has more funcs other places)
		this.bytes = bytes;
		this.height = height;
		this.width = width;
	};

	ByteRect.prototype.copy = function(){
		//let newBytes = new Uint8Array(this.bytes.length);
		//copyBytes(this.bytes, newBytes);
		let newBytes = new Uint8Array(this.bytes);
		return new ByteRect(newBytes, this.height, this.width);
	};

	//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

	ByteRect.prototype.index = function(y, x, colorDim){
		return (y*this.width+x)*4+colorDim;
	};

	ByteRect.prototype.read = function(y, x, colorDim){
		return this.bytes[(y*this.width+x)*4+colorDim];
	};

	//TODO bilinear interpolation for smoother color?
	ByteRect.prototype.readSafe = function(y, x, colorDim){
		return this.bytes[betweenInt(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)];
	};

	ByteRect.prototype.readBrightnessSafe = function(y, x){
		let i = between(0, (Math.round(y)*this.width+Math.round(x))*4, this.bytes.length-4);
		return (this.bytes[i+RED]+this.bytes[i+GREEN]+this.bytes[i+BLUE])/3;
	};

	/** same as readBrightnessSafe but as Float32Array whose length is this.bytes.length/4. a copy, not backing. */
	ByteRect.prototype.brightnessFloats = function(y, x){
		let ret = new Float32Array(this.bytes.length/4);
		let i = 0;
		for(let j=0; j<this.bytes.length; j+=4){
			ret[i++] = (this.bytes[j+RED]+this.bytes[j+GREEN]+this.bytes[j+BLUE])/3;
		}
		return ret;
	};

	ByteRect.prototype.write = function(y, x, colorDim, bright){
		this.bytes[(y*this.width+x)*4+colorDim] = bright;
	};

	ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
		this.bytes[between(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)] = bright;
	};

	ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
		if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
		let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
		this.bytes[index+RED] = redByte;
		this.bytes[index+GREEN] = greenByte;
		this.bytes[index+BLUE] = blueByte;
		this.bytes[index+ALPHA] = optionalAlphaByte;
	};

	ByteRect.prototype.writeSafeBright = function(y, x, brightByte){
		let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
		this.bytes[index+RED] = brightByte;
		this.bytes[index+GREEN] = brightByte;
		this.bytes[index+BLUE] = brightByte;
		this.bytes[index+ALPHA] = 255;
	};

	ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
		let ind = (y*this.width+x)*4;
		this.bytes[ind+RED] = redByte;
		this.bytes[ind+GREEN] = greenByte;
		this.bytes[ind+BLUE] = blueByte;
	};

	ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
		var indexStart = this.index(y, fromX, colorDim);
		var pixelSiz = toXExclusive-fromX;
		var siz = pixelSiz*4;
		var bright = fromBright;
		var brightAdd = (toBright-fromBright)/pixelSiz;
		for(var i=0; i<siz; i+=4){
			bright += brightAdd;
			this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
		}
	};

	ByteRect.prototype.flipHorizontal = function(){
		let bytes = this.bytes;
		for(let y=0; y<this.height; y++){
			let xMid = Math.floor(this.width/2);
			let offsetA = y*this.width*4; //first byte index of first pixel in row
			let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
			for(let x=0; x<xMid; x++){
				for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
					let temp = bytes[offsetA+colorDim];
					bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
					bytes[offsetB+colorDim] = temp;
				}
				offsetA += 4;
				offsetB -= 4;
			}
		}
	};

	ByteRect.prototype.verifySameSizeAs = function(byteRect){
		if(!byteRect) throw 'Param ByteRect = '+byteRect;
		if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
		if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
	};

	ByteRect.prototype.loopAve = function(loopSize, firstByteIndex, addByteIndex){
		let sum = 0;
		let i = firstByteIndex;
		for(let a=0; a<loopSize; a++){
			sum += this.bytes[i];
			i += addByteIndex;
		}
		return sum/loopSize;
	};

	ByteRect.prototype.loopFractionOfBytesThatAreAtLeastVal = function(loopSize, firstByteIndex, addByteIndex, brightnessIsAtLeastThisByteVal){
		let count = 0;
		let i = firstByteIndex;
		for(let a=0; a<loopSize; a++){
			if(brightnessIsAtLeastThisByteVal <= this.bytes[i]) count++;
			i += addByteIndex;
		}
		return count/loopSize;
	};

	ByteRect.prototype.loopWriteByte = function(loopSize, firstByteIndex, addByteIndex, writeByteVal){
		let i = firstByteIndex;
		for(let a=0; a<loopSize; a++){
			this.bytes[i] = writeByteVal;
			i += addByteIndex;
		}
	};

	ByteRect.prototype.loopWriteBlack = function(loopSize, firstByteIndex, addByteIndex){
		let i = firstByteIndex;
		for(let a=0; a<loopSize; a++){
			this.bytes[i+RED] = 0;
			this.bytes[i+GREEN] = 0;
			this.bytes[i+BLUE] = 0;
			i += addByteIndex;
		}
	};

	/** stdDev of looping over bytes (a row or column and colorDim).
	optionalAve is from loopAve or as optional param it computes that.
	*/
	ByteRect.prototype.loopDev = function(loopSize, firstByteIndex, addByteIndex, optionalAve){
		if(optionalAve === undefined) optionalAve = this.loopAve(byteRect, firstByteIndex, addByteIndex);
		let sumOfSquares = 0;
		let i = firstByteIndex;
		for(let a=0; a<loopSize; a++){
			let diff = this.bytes[i]-optionalAve;
			sumOfSquares += diff*diff;
			i += addByteIndex;
		}
		return Math.sqrt(sumOfSquares/loopSize);
	};

	/** ave brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
	ByteRect.prototype.rowAve = function(y, colorDim){
		return this.loopAve(this.width, y*this.width*4+colorDim, 4);
	};

	/** stdDev of brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
	ByteRect.prototype.rowDev = function(y, colorDim, optionalAve){
		return this.loopDev(this.width, y*this.width*4+colorDim, 4, optionalAve);
	};

	/** ave brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
	ByteRect.prototype.colAve = function(x, colorDim){
		return this.loopAve(this.height, x*4+colorDim, this.width*4);
	};

	/** stdDev of brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
	ByteRect.prototype.colDev = function(x, colorDim, optionalAve){
		return this.loopDev(this.height, x*4+colorDim, this.width*4, optionalAve);
	};

	ByteRect.prototype.setRowAndColordimToByte = function(y, colorDim, byteVal){
		this.loopWriteByte(this.width, y*this.width*4+colorDim, 4, byteVal);
	};

	ByteRect.prototype.setColAndColordimToByte = function(x, colorDim, byteVal){
		this.loopWriteByte(this.height, x*4+colorDim, this.width*4, byteVal);
	};

	ByteRect.prototype.rowFractionOfBytesThatAreAtLeastVal = function(y, colorDim, brightnessIsAtLeastThisByteVal){
		return this.loopFractionOfBytesThatAreAtLeastVal(this.width, y*this.width*4+colorDim, 4, brightnessIsAtLeastThisByteVal);
	};

	ByteRect.prototype.colFractionOfBytesThatAreAtLeastVal = function(x, colorDim, brightnessIsAtLeastThisByteVal){
		return this.loopFractionOfBytesThatAreAtLeastVal(this.height, x*4+colorDim, this.width*4, brightnessIsAtLeastThisByteVal);
	};

	ByteRect.prototype.setRowToBlack = function(y){
		this.loopWriteBlack(this.width, y*this.width*4, 4);
	};

	ByteRect.prototype.setColToBlack = function(x){
		this.loopWriteBlack(this.height, x*4, this.width*4);
	};

	//centerY, centerX, and radius can be scalars. Does bounds checking
	ByteRect.prototype.paintDonut = function(centerY, centerX, minRadius, maxRadius, redByte, greenByte, blueByte){
		let byteRect = this;
		if(minRadius > maxRadius) throw 'minRadius='+minRadius+' maxRadius='+maxRadius;
		var minYI = Math.max(0, Math.min(Math.floor(centerY-maxRadius), byteRect.height-1));
		var maxYI = Math.max(0, Math.min(Math.ceil(centerY+maxRadius), byteRect.height-1));
		var minXI = Math.max(0, Math.min(Math.floor(centerX-maxRadius), byteRect.width-1));
		var maxXI = Math.max(0, Math.min(Math.ceil(centerX+maxRadius), byteRect.width-1));
		var minRadiusSq = minRadius*minRadius;
		var maxRadiusSq = maxRadius*maxRadius;
		for(var y=minYI; y<=maxYI; y++){
			var i = byteRect.index(y, minXI, 0);
			for(var x=minXI; x<=maxXI; x++){
				var dy = y-centerY;
				var dx = x-centerX;
				let sq = dy*dy + dx*dx;
				if((minRadiusSq <= sq) && (sq <= maxRadiusSq)){
					//TODO optimize by skipping parts where this isnt true, in the loop before getting here.
					byteRect.bytes[i+RED] = redByte;
					byteRect.bytes[i+GREEN] = greenByte;
					byteRect.bytes[i+BLUE] = blueByte;
				}
				i += 4;
			}
		}
	};

	ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
		let diffY = toY-fromY;
		let diffX = toX-fromX;
		let len = Math.hypot(diffY, diffX);
		let numPoints = Math.ceil(len*1.5);
		for(let i=0; i<numPoints; i++){
			//TODO optimize
			let y = Math.round(fromY+diffY*i/numPoints);
			let x = Math.round(fromX+diffX*i/numPoints);
			this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
		}
	};

	ByteRect.prototype.paintCircleRadiusYXRGBSafe = function(radius, cy, cx, redByte, greenByte, blueByte){
		let circle = 2*Math.PI;
		let numPoints = Math.ceil(radius*circle*1.5);
		let anglePerPoint = 2*Math.PI/numPoints;
		for(let i=0; i<numPoints; i++){
			let angle = anglePerPoint*i;
			let x = cx+radius*Math.cos(angle);
			let y = cy+radius*Math.sin(angle);
			this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
		}
	};

	return ByteRect;
})();

window.onload = dagball.boot;




/*
const BIAS = 0;
const Y = 1;
const X = 2;


Dagball
Make the crossection move by ball weight.
Make line at angle door on hinge that ball can push.
Make whitneymusicbox that any of its circling icons can be pushed.
Make balancing scale at torque ratio.
Make 1way valve ball rolls on like ramp thats pushed down but then
fall into hole and hard to get out.
Make interesting game out of scalarfield, and make more dims of scalarfield
including balls, and do whole thing using gradient. And okayers can push balls
some. Have fun. Race. Solve puzzles. Build bendy shapes. Etc.

START WITH THIS SIMPLE THING... A SINE WAVE GROOVE FOR BALL TO ROLL IN, WITH WIGGLE ROOM,
THAT IMPLEMENTS DIODE AKA 1WAYVALVE BUT TIME-SYMMETRICLY, AS BALL ROLLING ON IT
CAN BE PUSHED A LITTLE ONE WAY BUT NOT AS EASILY THE OTHER WAY.
...
NO, start with wavefunctionlikeDagballExample_fourierLikeDitchAtRadiusesChosenBy(a*sine(b+3*angle)+c*sine(d+4*angle)...)AndWhereverBallsRollItFouriersOnThatByGradient

Dagball...
Play with it. Find way to make dags reusable so it goviral. Stay rubberbandpath
compatible and tinyglsl compatible so keep it simple. Port to wikib later,
or earlier if want the lambda opcode for scalar fields.



var Rect = function(y, x, h, w){
	this.y = y;
	this.x = x;
	this.h = h;
	this.w = w;
};

var MultiRectMap = function(rects){
	this.rects = rects;
};
MultiRectMap.prototype.height = function(vec){
	throw 'TODO';
};

//a rectangle windowed heightmap of n dimensions (including Y and X) to 1 dimension (scalar field).
//Its not a dag, or if viewed that way, is just 1 level above Vars.
//TODO make rectangle editor and javascript code editor inside it and get started making curvy shapes
//to roll balls around and game controls to change the n input dims that varies the heightmap shape
//by moving crossSection viewed of constant high dimensional heightmap.
var RectMap = function(rect, code){
	this.rect = rect;
	this.code = code;
};
RectMap.prototype.height = function(vec){
	return vec[this.index];
};

var Var = function(index){
	this.index = index;
};
Var.prototype.height = function(vec){
	return vec[this.index];
};



//FIXME should this be part of the state? How else is it going to
//be optimized for "rubberbandlike path of allballstogether pos and vel and input dims, between state now"?
//Or could just start with funDagballPrototypeButNoAIYet without that rubberbandy paths stuff.
var Ball = function(id){
	this.id = id;
};







/*TODO how can it be both sparse (aftrans bellcurve windowed dags) AND work by dag.height(vec)?
It seems each dag would need to depend on specific indexs in vec.
Maybe I should name them a to z, for the first 26. Might need more dims but could generate more names later.
Or f0 f982 etc like I named them in audivolv is another option. In any case,
those vars are shared between multiple bellcurves while reused at different aftranses
and summed into a combined heightmap. So its at least well defined what the height is.
All vars except x and y (2d on screen) are NOT aftransed.
Each aftransedBellcurveDagGroup (bedag).
*

//Like ForestCurveFit, lets make index 0 in vec always have value 1, and put y and x at indexs 1 and 2.

//TODO include bellcurves in the .height functions.

//This is a a whole game world's heightmap.
//sparse dag, a set (actually list, but order has no effect except roundoff) of Bedags that are summed.
//TODO could this be a Dag?
var Spag = function(childs){
	this.childs = childs;
};
Spag.prototype.height = function(vec){
	throw 'TODO aftrans x and y (2 values in vec)';
};

//Example: Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0.
//FIXME order of the 6 params.
var Aftrans = function(yx, yy, xy, xx, y, x){
	this.yx = yx;
	this.yy = yy;
	this.xy = xy;
	this.xx = xx;
	this.y = y;
	this.x = x;
	//this.radius is for optimization by not computing things that cant overlap.
	//circle centered at [this.y,this.x] that this fits in, if the thing transformed by this coordinate system fits in a unit circle.
	//FIXME check dotproduct and add something cuz if their angle is very parallel then it can add.
	this.radius = Math.sqrt(Math.max(this.yx**2+this.yy**2, this.xy**2+this.xx**2));
};
//a bellcurve whose max height is 1. FIXME how many stdDevs is radius outward.
//And should it be bellcurve or only similar to bellcurve but make it smoothly drop to exactly 0 within a finite distance?
Aftrans.prototype.bellHeightAtYX = function(y,x){
	throw 'TODO';
};
Aftrans.prototype.height = function(vec){
	return this.bellHeightAtYX(vec[Y], vec[X]);
};
Aftrans.prototype.forwardY = function(y,x){
	throw 'TODO';
};
Aftrans.prototype.forwardX = function(y,x){
	throw 'TODO';
};
Aftrans.prototype.reverseY = function(y,x){
	throw 'TODO';
};
Aftrans.prototype.reverseX = function(y,x){
	throw 'TODO';
};

/*Maybe later, but for now just do 2d aftrans and if need multiple instances of something, just copy it with different Vars...
TODO?? make a sparse permutation (of subset of dims in vec) thats similar to how Aftrans moves and rotates
to allow reuse of Vars and Dags on them...
I might want some SparsePermutation object that maybe goes in Bedag or something like Bedag,
that allows something higher in forest to permutate the Vars lower in it,
so the same Dags can be used as multiple instances of those Dags with separate input controls (indexs in vec),
like 2 of the "mostly flat platform with walls and obstacles in middle, that you tilt in 2d with 2 other dims" dags
that can be tilted by 4 dimensions, 2 dimensions each, even though theyre made of same dags.
Higher dimensional affine transforms can do that, so should I do that instead, merge Aftrans and SparsePermutation?
Not exactly, cuz storing it those 2 separate ways is more efficient.
Im not sure if I want such permutations or not.
*

var Bedag = function(dag, aftrans){
	this.dag = dag;
	this.aftrans = aftrans;
};
Bedag.prototype.height = function(vec){
	throw 'TODO bellcurveOrSomethingsimilarbutsmoothlydropsto0atfinitedistance-windowed aftrans x and y (2 values in vec)';
};

var Dag = function(childs, code){
	this.childs = childs;
	this.code = code; //TODO use cachedEval of this code, though it could also be TinyGLSL optimized.
	this.v = 0; //last val returned by cachedEval(this.code)(vec) or something like that.
};

Dag.prototype.height = function(vec){
	throw 'TODO use cachedEval(this.code)(vec) or something like that, but remember to ';
};

var Var = function(index){
	this.index = index;
};
Var.prototype.height = function(vec){
	return vec[this.index];
};

//TODO implement aftrans2d as Dag or make a new object type for it?
//Hopefully Dag is general enuf to do that itself? But maybe for sparse optimization, a few different types are good?


//FIXME should this be part of the state? How else is it going to
//be optimized for "rubberbandlike path of allballstogether pos and vel and input dims, between state now"?
//Or could just start with funDagballPrototypeButNoAIYet without that rubberbandy paths stuff.
var Ball = function(id){
	this.id = id;
};


var makeExampleGame = function(){
	let vars = [];
	for(let v=0; v<20; v++){
		vars.push(new Var(v));
	}
	let varBias = vars[BIAS]; //value should always be 1
	let varY = vars[Y];
	let varX = vars[X];
	let dagdistanceFromCenter = new Dag([varY,varX], '(a,b)=>Math.hypot(a,b)');

	throw 'TODO';
};
*/



</script></head><body style="margin: 0;padding: 0;overflow: hidden;width: 100%;height: 100%;">
	<h3><div id=displayLogs style="z-index:1;position:absolute;left:0px;top:0px;opacity:.6;user-select:none;">displayLogs</div></h3>
	<div id="overCanvas" style="z-index:1; position:absolute; left:0px; top:200px; opacity:.6; display: flex; flex-direction: column; height: 100%;">
		<nobr>
			<input type=button value="all gamepads rumble test" onclick="dagball.makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest = true;" style="z-index:0">
			<input type=button value="X" onclick="dagball.turnOff_makeAllGamepadRumblesTurnOnAndOffSmoothlyAsSineWavesAsATest();">
		</nobr>
		<textarea id=mainEditTextarea rows=50 cols=50 style="flex-grow: 1; resize: horizontal;" oninput="dagball.selectedCircs().forEach(circ=>{ circ.text = this.value; }); if(dagball.wasErrorNeedMainLoopRestart){ dagball.wasErrorNeedMainLoopRestart = false; console.log('dagball.wasErrorNeedMainLoopRestart restarting dagball.mainLoop()'); dagball.mainLoop(); }">
			The dagball.Player object with the votes for exists and median vote for priority
			will be useful even in single player, compared to the circs not working at all. Do it asap,
			and make some fun prototypes.

			blah blah
			TODO check how long since last user input (mouse movement, keyboard, etc) and if its been longer than 10 minutes, stop simulating, cuz wasting GPU power. Make this user adjustable.

			Dagball
Make a simpler demo, different code in dagball.Game constructor. Make elevators, gears, or something simple.

Dagball
A big part of the game will be exploring big areas that have unique stuff in them,
So i need a way to compute it solparsrly in 2d.
And might wantscrewballsctamblelike controls on some parts. Either that or a heavy ball that u can push to switch some parts by physics.
Start with just sparse bellcurveorrectanglewindowed glsl code that i can type in an editor in browser at chosen 2d positions.
Also consider LLMs helping design the game. But do it myself at first.
There will only be 1 kernelpair per near 2d area, sum of whichever are near.
So its smooth.
Some areas will emit balls. Some will consume balls.
Some will limit number of balls. Etc.
Object of the game will be to get a certain few balls, colored differently, to the end of the game far away, using many disposable balls along the way.
Also consider rubberbandlike paths as a weaker substitute for qlearning.
Plan is to port it to wikib later but it goviral soon first.

Dagball get working in mobile too
		</textarea>
	</div>

</body></html>